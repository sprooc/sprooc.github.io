<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据管理基础-期末复习</title>
      <link href="/2024/08/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据管理基础-期末复习"><a href="#数据管理基础-期末复习" class="headerlink" title="数据管理基础-期末复习"></a>数据管理基础-期末复习</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ol><li><p><strong>数据</strong>（Data）是数据库中存储的<strong>基本对象</strong></p></li><li><p>什么是<strong>数据库</strong>，有什么<strong>基本特点</strong></p><ul><li><p><strong>数据库</strong>（Database，简称DB）是<strong>长期储存在计算机内</strong>、<strong>有组织的</strong>、<strong>可共享的</strong>大量数据的集合</p></li><li><p>数据库的基本特征</p><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul></li></ul></li><li><p><strong>数据库系统</strong>（Database System，简称DBS），在计算机系统中<strong>引入数据库后的系统</strong>构成</p><ul><li>数据库</li><li>数据库管理系统（及其应用开发工具）</li><li>应用程序</li><li>数据库管理员（DBA） </li></ul></li><li><p>数据模型</p><ul><li>概念模型：按用户的观点来对数据和信息建模，主要用于数据库设计</li><li>逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现</li><li>物理模型：对数据最底层的抽象，是面向计算机系统的</li></ul></li><li><p>常见逻辑数据模型</p><ul><li>格式化模型<ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li></ul></li><li>关系模型（Relational Model)）</li><li>对象模型<ul><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li></ul></li></ul></li><li><p>关系模型的优缺点</p><ul><li>优点<ul><li>建立在严格的数学概念的基础上</li><li>概念单一</li><li>关系模型的存取路径对用户透明<ul><li>具有更高的数据独立性，更好的安全保密性</li><li>简化了程序员的工作和数据库开发建立的工作</li></ul></li></ul></li><li>缺点<ul><li>存取路径对用户透明，查询效率往往不如格式化数据模型</li><li>为提高性能，必须对用户的查询请求进行优化，增加了开发DBMS的难度</li></ul></li></ul></li><li><p>三级模式</p><ul><li>数据库系统的三级模式结构由外模式、模式和内模式组成</li><li>外模式，是<strong>数据库用户能够看见和使用</strong>的<strong>局部数据</strong>的逻辑结构和特征的描述，是<strong>数据库用户的数据视图</strong>。</li><li>模式，是数据库中<strong>全体数据的逻辑结构和特性的描述</strong>，是<strong>所有用户的公共数据视图</strong>。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集。一个数据库只有一个模式。</li><li>内模式，是数据在数据库系统<strong>内部的表示</strong>，即对数据的物理结构和存储方式的描述。一个数据库只有一个内模式。</li></ul></li><li><p>两级映像</p><ul><li>二级映象在数据库管理系统内部实现这<strong>三个抽象层次的联系和转换</strong></li><li>外模式／模式映像：保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li></ul></li><li>模式／内模式映：保证数据的物理独立性<ul><li>当数据库的存储结构改变了，数据库管理员修改模式／内模式映象，使模式保持不变。</li></ul></li></ul></li></ol><h2 id="第二章-关系型数据库"><a href="#第二章-关系型数据库" class="headerlink" title="第二章 关系型数据库"></a>第二章 关系型数据库</h2><ol><li>关系模型的完整性约束<ul><li>实体完整性规则（Entity Integrity）<ul><li>若属性<em>A</em>是基本关系<em>R</em>的主属性，则属性<em>A</em>不能取空值</li></ul></li><li>参照完整性规则<ul><li>若属性（或属性组）<em>F</em>是基本关系<em>R</em>的外码,它与基本关系<em>S</em>的主码K_s相对应（基本关系<em>R</em>和<em>S</em>不一定是不同的关系），则对于<em>R</em>中每个元组在<em>F</em>上的值必须为：<ul><li>或者取空值（<em>F</em>的每个属性值均为空值）</li><li>或者等于<em>S</em>中某个元组的主码值</li></ul></li></ul></li><li>用户定义的完整性<ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li></ul></li></ul></li><li>5种基本操作<ul><li>选择、投影、并、差、笛卡尔积</li></ul></li></ol><h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><ol><li><p>基本表和视图</p><ul><li>基本表<ul><li>本身独立存在的表</li><li>一个关系对应一个基本表</li></ul></li><li>视图<ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li></ul></li></ul></li><li><p>连接操作</p><ul><li>嵌套循环法</li><li>排序合并法</li><li>索引连接法</li></ul></li><li><p>EXISTS 子查询</p><ul><li><p>查询选修了全部课程的学生姓名。</p><p>SELECT Sname<br>FROM Student<br>WHERE NOT EXISTS<br>   (SELECT *</p><pre><code>FROM CourseWHERE NOT EXISTS  (SELECT * FROM SC   WHERE Sno= Student.Sno    AND Cno= Course.Cno   )</code></pre><p>   );</p></li><li><p>查询至少选修了学生201215122选修的全部课程的学生号码。<br>SELECT DISTINCT Sno<br>FROM SC SCX<br>WHERE NOT EXISTS<br>   (SELECT *</p><pre><code>FROM SC SCYWHERE SCY.Sno = &#39; 201215122 &#39;  AND       NOT EXISTS        (SELECT *         FROM SC SCZ         WHERE SCZ.Sno=SCX.Sno AND               SCZ.Cno=SCY.Cno        )</code></pre><p>   );</p></li></ul></li><li><p>行列子集视图</p><ul><li>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图</li></ul></li><li><p>视图有什么作用</p><ul><li><p>视图能简化用户的操作</p></li><li><p>视图使用户能以多种视角看待同一数据</p></li><li><p>视图对重构数据库提供了一定程度的逻辑独立性</p></li><li><p>视图能够对机密数据提供安全保护</p></li><li><p>适当的利用视图可以更清晰地表达查询</p></li></ul></li></ol><h2 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h2><ol><li><p>自主存取控制和强制存取控制</p><ul><li>自主存取控制<ul><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li></ul></li><li>强制存取控制<ul><li>每一个数据对象被标以一定的<strong>密级</strong></li><li>每一个用户也被授予某一个级别的<strong>许可证</strong></li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li><li>用户不能直接感知或进行控制</li></ul></li></ul></li><li><p>GRANT和REVOKE</p><ul><li>GRANT INSERT ON <strong>TABLE</strong> SC TO U5 <strong>WITH GRANT OPTION</strong>;</li><li>REVOKE INSERT  ON <strong>TABLE</strong> SC  FROM U5 <strong>CASCADE</strong> ;</li></ul></li><li><p>审计</p><ul><li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li></ul></li></ol><h2 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h2><ol><li><p>完整性和安全性</p><ul><li><p>数据的完整性</p><ul><li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li><li>防范对象：不合语义的、不正确的数据</li></ul></li><li>数据的安全性<ul><li>保护数据库，防止恶意的破坏和非法的存取</li><li>防范对象：非法用户和非法操作</li></ul></li></ul></li><li><p>参照完整性检查</p><p>| 被参照表               | 参照表                 | <strong>违约处理</strong>                 |<br>| ——————————— | ——————————— | —————————————— |<br>| <strong>可能破坏参照完整性</strong> | <strong>插入元组</strong>           | <strong>拒绝</strong>                     |<br>| <strong>可能破坏参照完整性</strong> | <strong>修改外码值</strong>         | <strong>拒绝</strong>                     |<br>| <strong>删除元组</strong>           | <strong>可能破坏参照完整性</strong> | <strong>拒绝/级连删除/设置为空值</strong> |<br>| <strong>修改主码值</strong>         | <strong>可能破坏参照完整性</strong> | <strong>拒绝/级连修改/设置为空值</strong> |</p></li><li><p>断言</p><ul><li><p>使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</p></li><li><p>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</p></li><li><p>CREATE ASSERTION ASSE_SC_CNUM1<br>CHECK(60 &gt;= ALL (SELECT count(*)    FROM  SC GROUP by cno);</p></li></ul></li><li><p>触发器</p><ul><li><p>触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程</p></li><li><p>CREATE TRIGGER SC_T<br>AFTER UPDATE OF Grade ON SC<br>REFERENCING<br>OLD row AS OldTuple,<br>NEW row AS NewTuple<br>FOR EACH ROW<br>WHEN (NewTuple.Grade &gt;= 1.1 * OldTuple.Grade)<br>INSERT INTO SC_U (Sno,Cno,OldGrade,NewGrade)<br>VALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)</p></li></ul></li></ol><h2 id="第六章-关系数据库理论"><a href="#第六章-关系数据库理论" class="headerlink" title="第六章 关系数据库理论"></a>第六章 关系数据库理论</h2><ol><li>范式<ul><li>1NF：每个分量必须是不可分开的数据项。</li><li>2NF：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF</li><li>3NF：设关系模式R<U,F>∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊉Y）, 使得X→Y，Y→Z成立，Y ↛ X，则称R<U,F> ∈ 3NF。</li><li>BCNF：设关系模式R<U,F>∈1NF，若X →Y且Y ⊈ X时X必含有码，则R<U,F>∈BCNF。</li></ul></li><li>简述规范化理论对数据库设计的指导意义 <ul><li>在数据分析阶段，用数据依赖的概念分析和表示各项数据项之间的关系</li><li>在设计概念结构阶段，用规范化理论消除初步 E-R 图冗余的联系</li><li>在 E-R 图向数据模型转化阶段，用模式分解的概念和方法指导设计</li></ul></li></ol><h2 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h2><ol><li>数据库设计的基本步骤<ul><li>需求分析</li><li>概念结构设计<ul><li>概念模式</li></ul></li><li>逻辑结构设计<ul><li>逻辑模式和外模式</li></ul></li><li>物理结构设计<ul><li>内模式</li></ul></li><li>数据库实施</li><li>数据库运行和维护</li></ul></li><li>逻辑模型设计中的水平分解和垂直分解<ul><li>水平分解：把（基本）关系的元组分为若干子集合，定义每个子集合为一个子关系 <ul><li>对符合”80/20“原则的，把经常被使用的数据分解出来，形成一个子关系 </li><li>水平分解为若干子关系，使每个事务存取的数据对应于一个子关系 </li></ul></li><li>垂直分解：经常在一起使用的属性从 R 中分解出来形成一个子关系模式 <ul><li>优点：提高某些事务的效率 </li><li>缺点：可能使另一些事务不得不执行连接操作，降低了效率</li></ul></li></ul></li></ol><h2 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h2><ol><li><p>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。事务是恢复和并发控制的基本单位</p></li><li><p>事务的特性（ACID）</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li><li><p>故障种类</p><ul><li>事务内部的故障<ul><li>事务没有达到预期的终点(COMMIT或者显式的ROLLBACK)</li></ul></li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li><li><p>恢复的基本原理：冗余</p><ul><li>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li></ul></li><li><p>静态转储和动态转储</p><ul><li>静态转储<ul><li>在系统中无运行事务时进行的转储操作</li><li>转储开始时数据库处于一致性状态</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>得到的一定是一个数据一致性的副本 </li><li>优点：实现简单</li><li>缺点：降低了数据库的可用性</li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存取或修改</li><li>优点<ul><li>不用等待正在运行的用户事务结束</li><li>不会影响新事务的运行</li></ul></li><li>缺点：不能保证副本中的数据正确有效</li></ul></li></ul></li><li><p>海量转储和增量转储</p><ul><li>海量转储: 每次转储全部数据库</li><li>增量转储: 只转储上次转储后更新过的数据</li></ul></li><li><p>日志文件</p><ul><li><p>日志文件是用来记录事务对数据库的更新操作的文件</p></li><li><p>作用</p><ul><li>事务故障恢复和系统故障恢复必须用日志文件。</li><li>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</li><li>在静态转储方式中，也可以建立日志文件。<ul><li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li><li>利用日志文件，把已完成的事务进行重做处理</li><li>对故障发生时尚未完成的事务进行撤销处理</li><li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li></ul></li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406251244168.png" alt="image-20240625124444028"></p></li></ul></li><li><p>为什么要先写日志文件</p><ul><li>写数据库和写日志文件是两个不同的操作</li><li>在这两个操作之间可能发生故障</li><li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li><li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性</li></ul></li><li><p>恢复策略</p><ul><li><p>事务故障</p><ul><li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。</li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ul></li><li><p>系统故障</p><ul><li>正向扫描日志文件，找出在故障发生前已经提交的事务队列(REDO队列)和未完成的事务队列(UNDO队列)。</li><li>对未完成的事务队列中的各个事务进行UNDO处理。反向扫描日志文件，对每个撤销事务的更新操作执行逆操作</li><li>对已经提交的事务队列中的各个事务进行REDO处理。正向扫描日志文件，对每个重做事务重新执行登记的操作</li></ul></li><li><p>介质故障</p><ul><li><p>装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到最近一次转储时的一致性状态。</p></li><li><p>装入转储结束时刻的日志文件副本，重做已完成的事务。</p></li></ul></li></ul></li><li><p>检查点记录</p><ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul></li><li><p>重新开始文件的内容</p><ul><li>记录各个检查点记录在日志文件中的地址</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406251305380.png" alt="image-20240625130505325"></p></li><li><p>动态维护日志文件的方法</p><ul><li>周期性地执行如下操作：建立检查点，保存数据库状态。</li><li>具体步骤是：<ul><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上</li><li>在日志文件中写入一个检查点记录</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ul></li></ul></li><li>利用检查点恢复步骤<ul><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li><li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST<ul><li>建立两个事务队列<ul><li>UNDO-LIST </li><li>REDO-LIST </li></ul></li><li>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li></ul></li><li>从检查点开始正向扫描日志文件，直到日志文件结束<ul><li>如有新开始的事务Ti ，把Ti暂时放入UNDO-LIST队列</li><li>如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列；直到日志文件结束</li></ul></li><li>对UNDO-LIST中的每个事务执行UNDO操作</li><li>对REDO-LIST中的每个事务执行REDO操作</li></ul></li></ol><h2 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h2><ol><li><p>并发操作带来的数据不一致</p><ul><li>丢失修改</li><li>不可重复读</li><li>读脏数据</li></ul></li><li><p>并发控制的主要技术</p><ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul></li><li><p>封锁：事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。在事务T释放它的锁之前，其它的事务不能更新此数据对象。</p><p>基本类型：排它锁、共享锁</p></li><li><p>封锁协议</p><ul><li>一级封锁协议<ul><li>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。</li><li>防止丢失修改</li></ul></li><li>二级封锁协议<ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。</li><li>防止丢失修改和读“脏”数据</li></ul></li><li>三级封锁协议<ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。</li><li>防止丢失修改、读脏数据和不可重复读</li></ul></li></ul></li><li><p>什么是活锁，如何避免？</p><ul><li>事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。</li><li>T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。</li><li>T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……</li><li>T2有可能永远等待，这就是活锁的情形</li><li>避免活锁：采用先来先服务的策略</li></ul></li><li><p>什么是死锁，如何解决？</p><ul><li>事务T1封锁了数据R1，T2封锁了数据R2</li><li>T1又请求封锁R2 ，因T2已封锁了R2 ，于是T1等待T2释放R2上的锁</li><li>接着T2又申请封锁R1 ，因T1已封锁了R1 ， T2也只能等待T1释放R1上的锁</li><li>这样T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁 </li><li>预防死锁的方法：<ul><li>一次封锁法，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li>顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁</li></ul></li><li>检测死锁的方法：<ul><li>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li><li>等待图法，并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁</li></ul></li><li>解除死锁的方法：<ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul></li></ul></li><li><p>可串行化调度</p><ul><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li></ul></li><li><p>冲突可串行化</p><ul><li>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度</li></ul></li><li><p>两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁。可保证并发调度的可串行性</p><ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul></li><li><p>封锁粒度</p><ul><li>封锁对象的大小称为封锁粒度</li></ul></li><li><p>意向锁</p><ul><li>提高对某个数据对象加锁时系统的检查效率</li><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li><li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406251404582.png" alt="image-20240625140408506"></p></li></ol><h2 id="第十二章-NoSQL"><a href="#第十二章-NoSQL" class="headerlink" title="第十二章 NoSQL"></a>第十二章 NoSQL</h2><ol><li><p>关系型数据库的优缺点</p><ul><li>优点<ul><li>建立在严格的数学概念的基础上 </li><li>概念单一 </li><li>关系模型的存取路径对用户透明</li><li>获取持久化数据</li><li>并发</li><li>近乎标准的模型</li></ul></li><li>缺点<ul><li>存取路径对用户透明，查询效率往往不如格式化数据模型（NoSQL） </li><li>为提高性能，必须对用户的查询请求进行优化，增加了开发 DBMS 的难度</li></ul></li></ul></li><li><p>阻抗失谐：关系模型和内存中的数据结构之间存在差异</p><ul><li>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译</li></ul></li><li><p>NoSQL共同特征</p><ul><li>不使用关系模型</li><li>在集群中运行良好</li><li>开源</li><li>适用于21世纪的互联网公司</li><li>无模式</li></ul></li><li><p>聚合</p><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。</li><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li><li><p>CAP定理：给定“一致性”(Consistency)、“可用性”(Availability)、“分区耐受性”( Partition tolerance) 这三个属性，我们只能同时满足其中两个属性。</p></li><li><p>仲裁</p><ul><li>写入仲裁<ul><li>对等式分布模型：如果发生两个相互冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可，W&gt;N/2 。即，参与写入操作的节点数(W)，必须超过副本节点数(N)的一半。副本个数又称为“复制因子”</li><li>主从式分布模型：只需要向主节点中写入数据</li></ul></li><li>读取仲裁<ul><li>对等式分布模型：只有当R+W&gt;N时，才能保证读取操作的“强一致性”。其中，执行读取操作时所需联系的节点数(R)，确认写入操作时所需征询的节点数(W)，以及复制因子(N)</li><li>主从式分布模型：只需从主节点中读取数据</li></ul></li></ul></li><li><p>键值数据库</p><ul><li>键值数据库(key-value store)是一张简单的哈希表(hash table)，主要用在所有数据库访问均通过主键(primary key)来操作的情况下。</li><li>客户端可以根据键查询值，设置键所对应的值，或从数据库中删除键。</li><li>适用场景<ul><li>保存会话</li><li>购物车数据</li><li>用户配置信息</li></ul></li><li>不适用场景<ul><li>数据间关系 </li><li>含有多项操作的事务 </li><li>查询数据（无法根据值来查询） </li><li>操作关键字集合（一次只能操作一个键）</li></ul></li></ul></li><li><p>文档数据库</p><ul><li>文档彼此相似，但不必完全相同。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。</li><li>文档数据库可视为其值可查的键值数据库。</li><li>“文档”( document)是文档数据库中的主要概念。</li><li>其格式可以是XML、JSON、BSON等。</li><li>文档具备自述性(self-describing)，呈现分层的树状数据结构(hierarchical tree data structure)，可以包含映射表、集合和标量值。</li><li>适用场景<ul><li>事件记录</li><li>内容管理系统及博客平台</li><li>网站分析与实时分析</li><li>电子商务应用程序</li></ul></li><li>不适用场景<ul><li>包含多项操作的复杂事务</li><li>查询持续变化的聚合结构</li></ul></li></ul></li><li><p>列族数据库</p><ul><li>列族数据库，可以存储关键字及其映射值， 并且可以把值分成多个列族，让每个列族代表一张数据映射表(map of data)。</li><li>列族数据库将数据存储在列族中，而列族里的行则把许多列数据与本行的“行键”(row key)关联起来。</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406251457407.png" alt="image-20240625145747288"></p><ul><li>适用场景<ul><li>事件记录</li><li>内容管理系统和博客平台</li><li>计数器</li><li>限期   </li></ul></li><li>不适用场景<ul><li>需要以“ACID事务”执行写入及读取操作的系统。</li><li>根据查询结果来聚合数据(例如SUM(求和)或AVG (求平均值))</li><li>在开发早期原型或刚开始试探某个技术方案时</li></ul></li></ul></li><li><p>图数据库</p><ul><li>图数据库可存放实体及实体间关系。</li><li>实体也叫“节点”(node)，它们具有属性(property)。可将节点视为应用程序中某对象的实例。</li><li>关系又叫“边”(edge)，它们也有属性。边具备方向性( directional significance)，而节点则按关系组织起来，以便在其中查找所需模式。</li><li>适用场景<ul><li>互联数据 </li><li>安排运输路线 </li><li>分派货物和基于位置的服务 </li><li>推荐引擎</li></ul></li><li>不适用场景<ul><li>更新全部或某子集内的实体</li><li>无法处理那么大的数据量，尤其在执行“全局图操作”，涉及整张图的操作)时更是如此</li></ul></li></ul></li><li><p>NoSQL汇总</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406251506876.png" alt="image-20220620212854163"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统-期末复习</title>
      <link href="/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231806666.png" alt="aacced7315d0252fe2b0b8856dfcd26"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231806336.png" alt="923f4488a463cd31519ccaaadd63b89"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807380.png" alt="b990732478443b28a967f347b76d8b8"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807961.png" alt="c0398820c094f8b5b7436ed9bc910ce"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807777.png" alt="dc48641147f466358d376599ea55e83"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807133.png" alt="6f282ef6c3cedb88170a25318e82cbf"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807625.png" alt="33e166818033150ccdf40712d64dc00"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807083.png" alt="397a59527aacf8c14c6a43dc8935492"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231807072.png" alt="7732605b5e77cfd67abf863975dc0f6"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808022.png" alt="a2d384f6aa9d61e65f7c17f6c2351dc"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808799.png" alt="6f0b14b05de90b6c868198aea3b423b"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808746.png" alt="8c9d0b9fe1543de0520265f96498f66"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808512.png" alt="cc19d9c1e917fa05dec3fd906b1d16c"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808983.png" alt="c04017f1340d9b255d7ae1c056c7ce2"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808718.png" alt="b16af551e37eefbe57f7538d8c0cb85"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231808151.png" alt="b410262347f3d2062a348ad0dde82f7"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809028.png" alt="0ee235021a6fef8dcda538b8b289362"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809419.png" alt="bf1c1e96e6ac4f1383b8dac148caa36"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809500.png" alt="b6414598cd00d7ae2cf4e13fd255da1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809121.png" alt="22e8322ce1cdb53520991e1abfa2053"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809212.png" alt="8c703e4af89d180581fd9cb1e14a711"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231809468.png" alt="ff3fef9e10d8941ff162312fabad15e"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231810479.png" alt="d57ba8b0b00ed311659a355f6379347"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231810954.png" alt="5b2f5189db2c85187f0c058223982d1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231810181.png" alt="3c973cdc2c5916c09271ff4c5718fbd"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231810112.png" alt="4114772b7bab2d38a83baf9919fe874"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231811645.png" alt="image-20240623181133609"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231812841.png" alt="5f1ef1f22177c42dce484641a51873a"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231812978.png" alt="5daca117823e5171aa2b809696cba05"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231812757.png" alt="d1f70956cdca5a924a3a7598a4a4f97"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231812407.png" alt="258add643affc6a0d02a30b51471f87"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231813124.png" alt="1bbe208151387d0ca4e115a5198dfc1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231813967.png" alt="9667a5bbef0c8ac8ed20ec3d621681d"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231813064.png" alt="d9369d23a5270ee03fa198556aef0dd"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231813021.png" alt="b3f3b889876346ffc02bc01509a437f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231813292.png" alt="f10c49fe2e08a5ced5bba5432e3b60e"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231814591.png" alt="bcf066a50a9ebc2c8b0686e7cf5c101"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231814988.png" alt="e0c4e1e3b55a10644f8e02e9424989a"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231814590.png" alt="0a016c437889a20bb29d68885d6f4bd"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815600.png" alt="0589abc92616a277baee5a2a80cb264"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815953.png" alt="074906f657e7d626aa8df7220b2d6ac"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815395.png" alt="9485853619b2fa7ec843a825656a69b"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815926.png" alt="6933d9f9f84cfe10ed26e2d50d93bce"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815430.png" alt="65f1b6b338489a9eca04112d700f1f9"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231815867.png" alt="630355d82a499950e4a49894b3368fd"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816097.png" alt="5b0ddbe48cde6b6b448fcadfd9edb5e"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816432.png" alt="52b254453f28b8da14f6bef179d3d15"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816627.png" alt="868e7d8428950cc991927ecb4e58da0"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816955.png" alt="fef94e5ab891a49c9a3f5075d9904c7"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816648.png" alt="1c68aef76332ea874230dde60b3c09f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816554.png" alt="812bc27162ed21d903ae83a0059d836"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231816792.png" alt="dfa023b40a150dd3f8102884eadb999"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231817068.png" alt="abd4bff17b12f6352b317a79884b699"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231817980.png" alt="573da50381ddf8d139bf0f9c832b95f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231817371.png" alt="2f18c8aa01a1ee9ff955c59ed8f58fa"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231817519.png" alt="ff5856560bb000462024fd0a7a6b3f1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231817287.png" alt="9dde388e3bf968fa6cefef99ea8d9b4"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231818657.png" alt="e1720f58c7fe4de8e96513eecbe85ed"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231818012.png" alt="95be88cd7c70dd5011b8cbdb8123b84"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231818063.png" alt="72e051de67877515aa89d434f765989"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231819356.png" alt="f276e66cef95521f604f96418d4f546"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231819378.png" alt="7ab6ac14ac2a55c5356deb0235a7b83"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231819065.png" alt="8e2aaee75c3e6102583cb0d61e9a29c"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231819677.png" alt="69782bc77a4196e6fd39e1a57f1e8d1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231819921.png" alt="070f8216c087c7dce91006f36134f5e"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231820702.png" alt="25c2ef134c2b819f9116568d7f35e5f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231820801.png" alt="a0dccb47799a279b41b9012486f9288"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231820933.png" alt="a789487b2e7ca26199c727bfcf61b5c"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231820349.png" alt="e05385d152a02c024170e9f1dc53abf"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231821945.png" alt="023c73e0a853c86322fc0645f8947fb"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231823675.png" alt="image-20240623182307644"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231823629.png" alt="1a92c07aed8e927cfd75995511d4f84"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231823326.png" alt="f6be2733f9a1880df937df91bda4290"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231824111.png" alt="29a08803ef1b9da13db48735c7ed4a2"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231824073.png" alt="97ce9408fb311e97282183f19dc697b"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231824335.png" alt="7230b830a58bbce4228e9cc6d621407"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231824147.png" alt="1cb08dcfc2460325e3ffd686aa2f83e"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231825385.png" alt="35c0272dd9673a54209f46b4b7a2bd9"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231825051.png" alt="bb2dfa361e9d3719dab05bfbf61fdd2"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231825475.png" alt="82bd05224f3d91793c7300e69382b35"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231826179.png" alt="1f27a3227f8a4b6918965f7206c6623"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231948134.png" alt="2329385f054d528d7fdeb2e0eff7e7c"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231951815.png" alt="f389e4c06a49314ab4405fc78f5e95f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231952040.png" alt="ba2f35ba25a0b3332d90fc4e149bd54"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231952862.png" alt="83622aa27a8521ab850a4e2db1e8843"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231952184.png" alt="c9aeb9d4dbb33e4201e530e8e2a31bb"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231953904.png" alt="560d91a7cf5f474e3f4a7c7161a88a4"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406232012021.png" alt="aca03b64dbc815261f98f5ffcfce10e"></p><h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><p>考试不考判断题，仅记录相关知识点</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231954700.png" alt="ad03c90f694e8d2bf242a59fc54d53f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231954628.png" alt="c829a86470c426c3f401adfde9afa42"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231954192.png" alt="b10b0869ea08c5fa15181e1b4640182"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231954276.png" alt="af79a2c92b2f009d4147c1671bf8a7d"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231954867.png" alt="302634558b09df9775505db0458b928"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231955936.png" alt="c1e1b7b743d7fc7b5ed4d60a09d287f"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231955510.png" alt="f17a2984775b0b57b1a203165e847bc"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231955247.png" alt="a68ae72ca4701130e6672c586c484b1"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231955758.png" alt="47e9d3665057754c5ddee32d58fd79c"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231956255.png" alt="c5024327f704cc809d4fec3551a0a01"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231956968.png" alt="07e71aab48c76dda8e22ad3f1593cf0"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231956003.png" alt="19d872b62c65b86d52334e07c0c38c4"></p><p>应该是错误的。Spooling实质是将独占设备转化为共享设备的技术</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231956849.png" alt="e53a38b9c0c9821c5d8c800d732bbb5"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231958202.png" alt="9497ea5be9ea98ae6d75cb279993733"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406231958332.png" alt="eb2945d35693c8a6a2d6dd6b235ba7a"></p><p>对一个具有三级索引表的文件，存取一个记录通常需要4次访问磁盘。x<br>答案解析：三级索引需要访问4次磁盘，3次磁盘索引块，1次读取数据。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="计算机操作系统概述"><a href="#计算机操作系统概述" class="headerlink" title="计算机操作系统概述"></a>计算机操作系统概述</h3><ol><li><p>试述操作系统中三个最基础的抽象，并回答为什么要引入它们？</p><ul><li>进程抽象、虚存抽象、文件抽象</li><li>防止硬件资源被应用程序滥用</li><li>屏蔽复杂的硬件资源操作细节，为应用程序提供使用硬 件资源的简单且一致的方法</li></ul></li><li><p>操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行，改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</p></li><li><p>操作系统的组成</p><ul><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ul></li><li><p>操作系统的分类</p><ul><li>多道批处理操作系统<ul><li>脱机控制方式</li></ul></li><li>分时操作系统<ul><li>交互式操作系统</li></ul></li><li>实时操作系统</li></ul></li><li><p>多道程序设计</p><ul><li>定义：让多个程序同时进入计算机的主存储器进行计算</li><li>目的：解决CPU速度与I/O速度不匹配的矛盾</li><li>特点：<ul><li>CPU与外部设备充分并行</li><li>外部设备之间充分并行</li><li>发挥CPU的使用效率</li><li>提高单位时间的算题量</li><li>但是单道程序运行时间会增加</li></ul></li></ul></li><li><p>操作系统内核结构</p><ul><li>单内核：内核各部件杂然混居的形态。Linux, Windows</li><li>微内核：结构性部件和功能性部件分离。将大部分功能模块置于用户态</li><li>混合内核：微内核与单内核折中。</li><li>外内核</li></ul></li><li><p>试述系统调用的实现原理，陷阱机制和绘制系统调用的处理过程，并阐述系统调用的处理逻辑。</p><ul><li><p>定义：操作系统实现的完成某种特定功能的过程，为所有运行程序提供访问操作系统的接口</p></li><li><p>系统调用的实现</p><ul><li>编写系统调用服务例程</li><li>设计系统调用入口地址表，每个入口地址都指向一个系统调用的服务例程，有些还包含系统调用自带参数的个数</li><li>陷阱处理机制，需要开辟现场保护区，以保存发生系统调用时应用程序的处理器现场。</li></ul></li><li>陷阱机制：操作系统实现系统调用功能的机制称为系统陷阱或系统异常处理机制，由于系统调用而引起处理器中断的机器指令称为陷入指令(trap)，它是非特权指令，在用户态下执行时会产生CPU 模式切换，即由用户态转换到内核态。每个系统调用都事先规定编号，称为功能号，执行陷入指令时，必须通过某种方式指明对应系统调用的功能号，大多数情况，还应附带有传递给相应服务例程的参数。</li><li>系统调用的处理过程：<ul><li>应用程序执行系统调用，产生中断转向内核态，进入陷阱处理程序</li><li>将按功能号来查询入口地址表，并转至对应服务例程执行</li><li>完成后退出中断，返回应用程序断点继续运行。</li></ul></li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406241500543.png" alt="image-20240624150009414"></p></li></ol><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><ol><li><p><strong>进程</strong>是一个具有一定独立功能的程序关于某个数据集合的一次运行活动；是操作系统进行<strong>资源分配和调度</strong>的一个<strong>独立单位</strong>。</p></li><li><p>进程实体</p><ul><li>操作系统管理的数据结构</li><li>内存代码</li><li>内存数据</li><li>通用寄存器信息</li><li>程序状态字信息</li></ul></li><li><p>进程映像的组成部分</p><ul><li>进程控制块：保存进程的标识信息、状态信息和控制信息</li><li>进程程序块: 进程执行的程序空间</li><li>进程数据块: 进程处理的数据空间，包括数据、处理函数的用户栈和可修改的程序</li><li>核心栈: 进程在内核模式下运行时使用的堆栈，中断或系统过程使用</li></ul></li><li><p>共享的代码称为可再入程序，是纯代码的。</p></li><li><p>结合进程状态转换模型，解释操作系统是中断驱动的</p><ul><li><p>中断是激活操作系统的唯一方式</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406241505341.png" alt="c6ebb95cca0640ec913ca3a885ddfde"></p></li></ul></li></ol><ol><li><p>中断系统：计算机系统中响应和处理中断的系统</p><ul><li><p>中断响应由硬件子系统完成</p></li><li><p>中断处理由软件子系统完成</p></li></ul></li></ol><ol><li><p>中断处理过程</p><ul><li>发现中断源。硬件发现中断/异常事件，并由CPU响应中断/异常请求。当发现多个中断源时，将根据预定的中断优先级先后响应中断请求。</li><li>保存现场。暂停当前程序运行，将现场信息（PSW）保存至核心栈。</li><li>转向中断/异常时间处理程序执行。</li><li><p>恢复现场。恢复原运行程序的PSW，重新返回中断点以便执行后续指令。</p><p>  <img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262101092.png" alt="19320255fbaccc796fca198472bdb26"></p></li></ul></li></ol><ol><li><p>进程三态模型</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262107848.png" alt="4131794f997adafc9dfd5eaf74b2c98"></p></li><li><p>进程五态模型</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271727094.png" alt="image-20230621002239523"></p></li></ol><ol><li><p>进程控制块PCB是用于记录和刻画进程状态及环境信息的数据结构</p><ul><li><p>标识信息</p></li><li><p>现场信息</p></li><li><p>控制信息</p></li></ul></li></ol><ol><li><p>进程控制与管理原语</p><ul><li><p>进程创建</p></li><li><p>进程撤销</p></li><li><p>进程阻塞</p></li><li><p>进程唤醒</p></li><li><p>进程挂起</p></li><li><p>进程激活</p></li></ul></li></ol><ol><li><p>多线程程序设计优点</p><ul><li><p>快速线程切换</p></li><li><p>减少系统管理开销</p></li><li><p>线程通信易于实现</p></li><li><p>并行程度提高</p></li><li><p>节省内存空间</p></li></ul></li></ol><ol><li><p>内核级线程KLT：线程管理的所有工作由OS内核来做</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262140724.png" alt="image-20240626214042576" style="zoom: 25%;" /></p></li><li><p>用户级线程ULT：用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262141393.png" alt="image-20240626214109248" style="zoom:25%;" /></p></li><li><p>Jacketing技术</p><ul><li><p>解决ULT中，一个线程阻塞导致整个进程阻塞的问题</p></li><li><p>把阻塞式系统调用改造成非阻塞式的</p></li><li><p>当线程陷入系统调用时，执行jacketing程序</p></li><li><p>由jacketing 程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程</p></li></ul></li></ol><ol><li><p>用户级线程和内核级线程</p><ul><li>ULT适用于解决逻辑并行性问题</li></ul></li></ol><ul><li>KLT适用于解决物理并行性问题</li></ul><ol><li>多线程实现的混合策略：单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果<br>  <img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262149025.png" alt="522914f8f61d2c56185e6e4a779e576"></li></ol><ol><li><p>多线程混合策略下的线程状态</p><ul><li><p>KLT三态，系统调度负责</p></li><li><p>ULT三态，用户调度负责</p></li><li><p>活跃态ULT代表绑定KLT的三态</p></li><li><p>活跃态ULT运行时可激活用户调度</p></li><li><p>非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</p></li></ul></li></ol><p>   <img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262152068.png" alt="b1c0e7b35d6f135a661c45ab6d7bc12"></p><p>   <img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262153096.png" alt="d5133f63851ebe082f92d71a4c5d46f"></p><ol><li><p>处理器调度的层次</p><ul><li>高级调度：决定能否加入到执行的进程池中</li><li>中级调度：决定主存中的可用进程集合</li><li>低级调度：决定哪个可用进程占用处理器执行</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262158569.png" alt="c6cb208b77f595d7d7a41f01ce7c945"></p></li><li><p>进程调度算法</p><ul><li><p>先来先服务 FCFS（非抢占式）</p><ul><li>按照进程进入系统的时间顺序排</li><li>多用于高级调度</li><li>以计算为主的进程过于优越，长时间占有CPU</li><li>一个短进程不得不等待很长时间</li></ul></li><li><p>最短进程优先 SPN（非抢占式）</p><ul><li>优先处理计算时间短的进程</li><li>对长进程不公平，导致长进程饿死</li></ul></li><li><p>最短剩余时间优先 SRT（抢占式）</p><ul><li>总是选择预期剩余时间更短的进程</li><li>当一个新进程加入就绪队列，他可能比当前运行的进程具有更短的剩余时间，只要该新进就绪，调度器就可能抢占当前正在运行的进程</li></ul></li><li><p>最高响应比优先HRRN（非抢占式）</p><ul><li>选择响应比最高的</li><li>改善对长进程极端不公平的问题</li></ul></li></ul></li></ol><ul><li>时间片轮转调度算法RR（抢占式）<ul><li>基于先来先服务的，但是每个选程占有 CPU 运 行必须受到时间片的限制，一旦进程运行时间超过了该时间片就得让出 CPU</li></ul></li></ul><ul><li><p>多级反馈调度MLFQ（抢占式）</p><ul><li><p>建立多个不同优先级的就绪进程队列</p></li><li><p>多个就绪进程队列之间按照优先数调度</p></li><li><p>高优先级的就绪进程, 分配的时间片短</p></li><li><p>单个就绪进程队列中的进程的优先数和时间片相同，按照先来先服务算法调度</p></li><li><p>优点：优先级可变、适应性强</p></li><li><p>缺点：长进程最终会进入最低优先级队列，可能会一直等待</p></li><li><p>解决方法：对低优先级队列中等待时间足够长的进程提升优先级</p></li><li><p>当一个进程第一次进入系统时，它被放置在RQ0，当它第一次被抢占后并返回就绪状态时，它被放置在RQ1。在随后的时间里，每当它被抢占时，它被降级到下一个低优先级队列中。一个短进程很快会执行完，不会在就绪队列中降很多级。</p></li></ul></li></ul><pre><code> ![6dca3f981fbb8529c5a23fcf5a2cfb5](https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262223491.png)</code></pre><ol><li><p>Unix SVR4调度算法</p><ul><li><p>实时优先级层次：优先数和时间片都是固定的，在抢占点执行抢占</p></li><li><p>分时优先级层次：优先数和时间片是可变的，从0优先数的100ms到59优先数的10ms<br> <img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262228020.png" alt="image-20240626222814967"></p></li></ul></li></ol><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><ol><li><p>虚存分页的原理，并画出流程图</p><ul><li><p>分页存储器将主存划分成多个大小相等的页架</p></li><li><p>受页架尺寸限制，程序的逻辑地址也自然分成页</p></li><li><p>不同的页可以放在不同页架中，不需要连续</p></li><li><p>页表用于维系进程的主存完整性，记录虚拟页面和页框的对应关系</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406262237283.png" alt="f22a7f3fa6c02a655351b8e0705984c"></p></li></ul></li></ol><ol><li><p>存储管理的基本模式</p><ul><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定分区或可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页框(页架)区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页框(页架)区</li></ul></li><li><p>地址转换：又称重定位，即把逻辑地址转换成绝对地址</p><ul><li>静态重定位：在程序装入内存时进行地址转换<ul><li>由装入程序执行，早期小型OS使用</li></ul></li><li>动态重定位：在CPU执行程序时进行地址转换<ul><li>从效率出发，依赖硬件地址转换机构</li></ul></li></ul></li><li><p>主存扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存</p><ul><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ul></li><li><p>虚拟存储器的基本思想</p><ul><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为随用随调入</li><li>如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息调出到辅存上去</li></ul></li><li><p>可变分区内存分配</p><ul><li><p>最先适应分配算法(First fit)</p></li><li><p>邻近适应分配算法(Next fit)</p></li><li><p>最优适应分配算法(Best fit)：最容易产生外零头</p></li><li><p>最坏适应分配算法(Worst fit)</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271023111.png" alt="image-20240627102308918" style="zoom: 67%;" /></p></li></ul></li><li><p>程序移动技术 （浮动技术）</p><ul><li><p>解决内存外零头</p></li><li><p>需要动态重定位</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271025630.png" alt="65b00b8ab1e435409f5c4269b2c8767"></p></li></ul></li><li><p>页的共享</p><ul><li>数据共享：不同进程可以使用<strong>不同页号</strong>共享数据页</li><li>程序共享：不同进程必须使用<strong>相同页号</strong>共享代码页（现代操作系统都不需要相同页号共享代码页了）</li></ul></li><li><p>抖动：如果一块正好将要被用到之前扔出，操作系统有不得不很快把它取回来，太多的这类操作会导致一种称为系统抖动的情况。在处理缺页中断期间，处理器的大部分时间都用于交换块，而不是用户进程的执行指令</p></li><li><p>页式虚拟存储管理</p><ul><li><p>基本思想：把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后，根据执行行为，动态调入不在主存的页，同时进行必要的页面调出</p></li><li><p>页表项</p><ul><li>每页的虚拟地址、实际地址</li><li>主存驻留标志、写回标志、保护标志、引用标志、可移动标志</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271055494.png" alt="8b631841f840bfb9b3fda3d7bde1ecf"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271055391.png" alt="5f436807eae64b65880e47f7f0b7e93"></p></li></ul></li><li><p>页面调度</p><ul><li>最佳算法OPT/Belady：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页。只可模拟，<strong>不可实现</strong>。</li><li>先进先出FIFO：总是淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页(常驻的除外)</li><li>最近最少使用LRU：淘汰最近一段时间较久未被访问的那一页，即那些刚被使用过的页面，可能马上还要被使用到。<strong>实现代价大</strong></li><li>最不常用LFU：淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好</li><li>时钟CLOCK：<ul><li>页面调入主存时，其引用标志位置1</li><li>访问主存页面时，其引用标志位置1</li><li>淘汰页面时，从指针当前指向的页面开始扫描循环队列把所遇到的引用标志位是1的页面的引用标志位清0，并跳过</li><li>把所遇到的引用标志位是0的页面淘汰，指针推进一步</li></ul></li><li>局部最佳页面替换算法MIN：不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</li><li>工作集替换算法：工作集模型用来对局部最佳页面替换算法进行模拟实现，不向前查看页面引用串，而是基于程序局部性原理向后看</li></ul></li><li><p>多级页表</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271117380.png" alt="image-20240627111704311"></p></li><li><p>反置页表</p><ul><li><p>基本思想：</p><ul><li>针对内存中的每个页框建立一个页表，按照块号排序</li><li>表项包含：正在访问该页框的进程标识、页号及特征位，和哈希链指针等</li><li>用来完成内存页框到访问进程页号的对应，即物理地址到逻辑地址的转换</li></ul></li><li><p>地址转换过程</p><ul><li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向IPT的一个表目</li><li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页框号，通过拼接位移便可生成物理地址</li><li>若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断，请求操作系统调入</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271120381.png" alt="e0826275d9292c3599f768b86e62a91"></p></li></ul></li><li><p>段式存储管理</p><ul><li><p>基本思想</p><ul><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区</li><li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段，附加段），供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：段始址、段限长，以及存储保护、可移动、可扩充等标志位</li></ul></li><li><p>地址转换流程</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271124661.png" alt="e968d4c14e021c78708127f83c3ab3c"></p></li></ul></li><li><p>段式虚拟存储管理</p><ul><li>基本思想：把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入。段式虚拟存储管理中段的调进调出是由OS自动实现的，对用户透明</li></ul></li><li><p>段页式存储管理</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271129568.png" alt="5e79345985c41d2b3b27af52398f5c8"></p></li></ol><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><ol><li><p>IO软件的四个层次</p><ul><li>用户空间的IO软件<ul><li>SPOOLing</li></ul></li><li>独立于设备的IO软件</li><li>设备驱动程序</li><li>中断处理程序</li></ul></li><li><p>设备分类</p><ul><li>字符设备：以字符为单位进行信息交换，例如鼠标、显示器</li><li>块设备：以固定大小的数据块为单位进行信息交换，例如磁盘</li></ul></li><li><p>总线：</p><ul><li>I/O和CPU速度、各设备I/O速度不匹配</li><li>使主机和设备充分并行，提高系统效率</li></ul></li><li><p>设备独立性</p><ul><li>设备独立性：用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离开来，再通过其它途径建立逻辑设备和物理设备之间的映射</li></ul></li><li><p>设备分配方式</p><ul><li>独占型外围设备：一次只能由一个进程独占使用</li><li>分配方式<ul><li>静态分配：进程运行前申请<ul><li>实现简单，能够防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul></li></ul></li><li><p>虚拟设备：使用一类物理设备模拟另一类物理设备</p></li><li><p>SPOOLing系统：用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</p><ul><li><p>预输入程序：预先把数据从输入设备传送到磁盘输入井</p></li><li><p>缓输出程序：把数据从磁盘输出井传送到输出设备</p></li><li><p>井管理程序：控制作进程和井之间的数据交换</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271328890.png" alt="e7f0416c00ce386478df5479b284c42"></p></li></ul></li><li><p>磁盘调度策略</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271345642.png" alt="image-20230616151146552"></p></li></ol><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ol><li><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul></li><li><p>逻辑文件，又称为文件的逻辑结构</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式<ul><li>用户能观察到的，并加以处理的数据集合</li></ul></li><li>文件的逻辑结构分为两种形式<ul><li>一种是流式文件</li><li>一种是记录式文件</li></ul></li></ul></li><li><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系</p><ul><li>顺序文件</li><li><p>连接文件（输入井、输出井）</p></li><li><p>直接文件（散列文件）</p></li><li>索引文件</li></ul></li><li><p>文件系统调用</p><ul><li><p><strong>文件创建</strong></p><p>int <strong>create</strong>(const char <strong>*pathname</strong>, mode_t <strong>mode</strong>);</p><ul><li>参数：文件名、模式（<strong>存取权限</strong>）</li><li>返回值：成功返回<strong>文件描述符</strong>，失败返回-1</li><li>实现步骤：<ul><li>为新文件分配<strong>索引节点</strong>和<strong>活动索引节点</strong>，并把<strong>索引节点编号与文件分量名</strong>组成<strong>新目录项</strong>，记到目录中。</li><li>在新文件所对应的活动索引节点中<strong>置初值</strong>，如置<strong>存取权限i_mode</strong>，连<strong>接计数i_nlink</strong>等。</li><li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，置表项初值，读写位移<strong>f_offset</strong>清“0”。</li><li>把各表项及文件<strong>对应的活动索引节点用指针连接起来</strong></li><li>把<strong>文件描述字</strong>返回给调用者。</li></ul></li></ul></li><li><p><strong>文件删除</strong></p><p>int <strong>unlink</strong>(const char <strong>*pathname)</strong>;</p><ul><li>参数：<strong>文件名</strong></li><li>返回值：成功返回0，失败返回-1</li><li>实现步骤：<ul><li>把指定文件从所在的目录文件中除去</li><li>将inode中的i_nlink减1</li><li>如果没有连接用户(i_nlink 为“0”)，还要把文件占用的存储空间释放。</li></ul></li></ul></li><li><p><strong>文件打开</strong></p><p>int <strong>open</strong>(const char <strong>*pathname</strong>, mode_t <strong>mode</strong>);</p><ul><li>参数：文件名、模式（<strong>存取权限</strong>）</li><li>返回值：成功返回<strong>文件描述符</strong>，失败返回-1</li><li>实现步骤：<ul><li>检索目录，如果inode还未被复制到内存，把它的<strong>inode复制到活动inode表</strong>。</li><li>根据参数mode核对权限，如果非法，则这次打开失败。</li><li>当“打开”合法时，为<strong>文件分配用户打开文件表项和系统打开文件表项</strong>，并为表项设置初值。</li><li>通过指针建立这些表项与活动索引节点间的联系。</li><li>把<strong>文件描述字</strong>，即用户打开文件表中相应文件表项的序号返回给调用者。</li></ul></li></ul></li><li><p><strong>文件关闭</strong></p><p>int <strong>close(</strong>int <strong>fd</strong>);</p><ul><li>参数：文件描述符</li><li>返回值：成功返回0，失败返回-1</li><li>实现步骤：<ul><li>根据fd找到<strong>用户打开文件表项</strong>，再找到系统打开文件表项。<strong>释放用户打开文件表项</strong>。</li><li>把对应<strong>系统打开文件表项中的f_count减“1”</strong>，如果<strong>非“0”</strong>，说明还有进程共享这一表项，<strong>不用释放直接返回</strong>；否则<strong>释放表项</strong>。</li><li>把<strong>活动索引节点中的i_count减“1”</strong>，<strong>若不为“0”</strong>，表明还有用户进程正在使用该文件，<strong>不用释放</strong>而直接返回，否则在把该<strong>活动索引节点中的内容复制回文件卷上的相应索引节点</strong>中后，释放该活动索引节点。</li></ul></li></ul></li><li><p><strong>文件读取</strong></p><p>size_t <strong>read</strong> (int <strong>fd</strong>, void<em> <strong>buf</strong>, size_t <em>*cnt</em></em>);</p><ul><li>参数：文件描述符、读取数据缓冲区、缓冲区大小</li><li>返回值：实际读取字节数</li><li>实现步骤：<ul><li>系统根据f_flag中的信息，<strong>检查读操作合法性</strong></li><li>再根据当前位移量f_offset值，<strong>要求读出的字节数</strong>，及活动索引节点中i_data[15]指出的文件物理块存放地址，把相应的<strong>物理块读到缓冲区</strong>中，然后<strong>再送到bufp指向的用户主存区</strong>中。</li></ul></li></ul></li><li><p><strong>文件写入</strong></p><p>size_t <strong>write</strong> (int <strong>fd</strong>, void<em> <strong>buf</strong>, size_t <em>*cnt</em></em>);</p><ul><li>参数：文件描述符、写入数据缓冲区、写入数据长度</li><li>返回值：实际写入的数据</li><li>实现步骤：<ul><li>系统根据f_flag中的信息，<strong>检查写操作合法性</strong></li><li>再根据当前位移量f_offset值，<strong>要求写入的字节数</strong>，及活动索引节点中i_data[15]指出的文件物理块存放地址，把数据缓冲区的数据写入到文件中。</li></ul></li></ul></li><li><p><strong>移动位移</strong></p><p>off_t <strong>lseek</strong>(int <strong>fd</strong>, off_t <strong>offset</strong>, int <strong>whence</strong>);</p><ul><li>参数：文件描述符、偏移量、位置</li><li>返回值：成功返回当前位置到开始的长度，失败返回-1</li><li>实现步骤：<ul><li>找到系统打开文件表项，修改f_offset的值</li></ul></li></ul></li><li><p><strong>文件链接</strong></p><p>int <strong>link</strong>(const char <strong>*oldpath</strong>, const char <strong>*newpath</strong>);</p><ul><li>参数：原始文件名、新的硬链接名</li><li>返回值：成功返回0，失败返回-1</li><li>实现步骤：<ul><li>检索目录找到oldnamep所指向<strong>文件的索引节点inode编号</strong>。</li><li>再次检索目录找到<strong>newnamep所指文件的父目录文件</strong>，并把<strong>已存在文件的索引节点inode编号与别名构成一个目录项</strong>，记入到该目录中去。</li><li>把已存在文件索引节点inode的<strong>连接计数i_nlink加“1”</strong>。</li></ul></li></ul></li></ul></li><li><p>文件系统的磁盘结构</p><ul><li>引导块</li><li>超级块：占用1#号块，存放文件系统结构和管理信息（位示图）</li><li>索引节点区</li><li>数据区</li></ul></li><li><p>文件系统数据结构</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271450093.png" alt="614f3e97b373c6f08fa7f09e08a3a26"></p></li><li><p>虚拟文件系统</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271511611.png" alt="51acf0f218dd3ac8eb90fd72806fed7"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202406271513898.png" alt="9ec11595379b2b9a45d2b00bebf12f2"></p></li></ol><h3 id="并发程序设计"><a href="#并发程序设计" class="headerlink" title="并发程序设计"></a>并发程序设计</h3><ol><li><p>并行和并发</p><ul><li><strong>并行性</strong>是指两个或多个事件在<strong>同一时刻</strong>发生（多核）</li><li><strong>并发性</strong>是指两个或多个事件在<strong>同一时刻间隔</strong>内发生</li></ul></li><li><p>n个进程共享m个同类资源，若每个进程都需要用该类资源，而且各进程对该类资源的最大需求量之和小于m+n。则该系统不会因竞争该类资源而阻塞。</p></li><li><p>并发程序设计的特性</p><ul><li>并行性</li><li>共享性</li><li>交往性</li></ul></li><li><p>进程间关系：竞争和协作</p></li><li><p>Bernstein条件</p><ul><li>R(pi)={ai1,ai2,…ain}，程序pi在执行期间引用的变量集</li><li>W(pi)={bi1,bi2,…bim}，程序pi在执行期间改变的变量集</li><li>若两个进程的程序p1和p2能满足Bernstein条件，即满足：<br>((R(p1)∩W(p2))∪(R(p2)∩W(p1))∪(W(p1)∩W(p2))= 空集<br>则并发进程的执行与时间无关</li></ul></li><li><p>临界资源：互斥共享变量所代表的资源。即一次只能被一个进程使用的资源</p></li><li><p>临界区指并发进程中与互斥共享变量相关的程序段</p></li><li><p>Peterson算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> inside[<span class="number">2</span>];</span><br><span class="line">inside[<span class="number">0</span>] = inside[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span><span class="number">0</span>, <span class="number">1</span>&#125; turn;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">    inside[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (inside[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">    &#123;临界区&#125;</span><br><span class="line">    inside[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    inside[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (inside[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">    &#123;临界区&#125;</span><br><span class="line">    inside[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现临界区管理的硬件设施</p><ul><li>关中断</li><li>测试并建立指令</li><li>对换指令</li></ul></li><li><p>PV操作数据结构及操作伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span>* <span class="title">list</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore s)</span> &#123;</span><br><span class="line">    s.value--;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore s)</span> &#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        wakeup(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么要引入管程？</p><ul><li>把分散在各进程中的临界区集中起来进行管理</li><li>防止进程有意或无意的违法同步操作</li><li>便于用高级语言来书写程序</li></ul></li><li>进程直接通信<ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信</li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需要命名发送者</li></ul></li><li>进程间接通信<ul><li>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些消息的队列组成的一个共享数据结构，这些队列通常成为信箱(mailbox)</li><li>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息</li></ul></li><li>高级通信机制<ul><li>管道/多路转接器/套接字</li><li>远程过程调用RPC</li></ul></li><li>死锁形成的四个必要条件<ul><li>互斥条件(mutual exclusion)：系统中存在临界资源，进程应互斥地使用这些资源</li><li>占有和等待条件(hold and wait)：进程请求资源得不到满足而等待时，不释放已占有的资源<ul><li><strong>静态分配</strong></li></ul></li><li>不剥夺条件(no preemption)：已被占用的资源只能由属主释放，不允许被其它进程剥夺<ul><li><strong>剥夺式调度方法</strong></li></ul></li><li>循环等待条件(circular wait)：存在循环等待链，其中，每个进程都在链中等待下一个进程所持有的资源，造成这组进程永远等待</li></ul></li><li>死锁防止（破坏循环等待条件）<ul><li>层次分配策略 <ul><li>一个进程得到某一层的一个资源后，它只能再申请在较高层的资源 </li><li>当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源 </li><li>当一个进程获得了某一层的一个资源后，它想再申请该层中的另一个资源，那么，必须先释放该层中的已占资源</li></ul></li><li>按序分配策略<ul><li>把系统的所有资源排一个顺序，每个进程只能按序上锁</li></ul></li></ul></li><li>死锁避免：银行家算法</li><li>死锁检测和解除<ul><li>资源分配图</li><li>死锁定理：系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是不可完全简化的。</li></ul></li></ol><h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><ol><li>假定系统中有五个进程｛P0, P1, P2, P3, P4｝和三类资源｛A, B, C｝，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图所示。</li></ol><div class="table-container"><table><thead><tr><th>资源情况</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td><strong>进程</strong></td><td>A  B  C</td><td>A  B  C</td><td>A  B  C</td><td>A  B  C</td></tr><tr><td>P0</td><td>7  5  3</td><td>0  1  0</td><td>7  4  3</td><td>3  3  2</td></tr><tr><td>P1</td><td>3  2   2</td><td>2  0   0</td><td>1  2   2</td><td></td></tr><tr><td>P2</td><td>9  0  2</td><td>3  0  2</td><td>6  0  0</td><td></td></tr><tr><td>P3</td><td>2  2  2</td><td>2  1  1</td><td>0  1  1</td><td></td></tr><tr><td>P4</td><td>4  3  3</td><td>0  0  2</td><td>4  3  1</td></tr></tbody></table></div><p>（1）利用下表来对T0 时刻系统是否为安全状态进行分析。检验T0 时刻系统是否为安全状态，若是在安全状态，请给出一个安全序列。</p><div class="table-container"><table><thead><tr><th style="text-align:left">资源情况</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td style="text-align:left"><strong>进程</strong></td><td>A  B C</td><td>A  B C</td><td>A  B  C</td><td>A  B C</td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>（2）在T0时刻如果进程P1发出请求向量Request1(1，0，2)，是否能实现安全分配？为什么？(画表进行分析)</p><p>答：</p><p>（1）</p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td>A  B C</td><td>A  B C</td><td>A  B  C</td><td>A  B C</td><td></td></tr><tr><td>P1</td><td>3  3  2</td><td>1  2  2</td><td>2  0  0</td><td>5  3  2</td><td>true</td></tr><tr><td>P3</td><td>5  3  2</td><td>0  1  1</td><td>2  1  1</td><td>7  4  3</td><td>true</td></tr><tr><td>P4</td><td>7  4  3</td><td>4  3  1</td><td>0  0  2</td><td>7  4  5</td><td>true</td></tr><tr><td>P2</td><td>7  4  5</td><td>6  0  0</td><td>3  0  2</td><td>10  4  7</td><td>true</td></tr><tr><td>P0</td><td>10 4  7</td><td>7  4  3</td><td>0  1  0</td><td>10  5  7</td><td>true</td></tr></tbody></table></div><p>答：在T0时刻存在着一个安全序列{P1，P3，P4 ，P2 ，P0}，故系统是安全的。</p><p>（2）P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查：</p><p>​    ① Request1(1，0，2)≤Need1(1，2，2)</p><p>​    ② Request1(1，0，2)≤Available1(3，3，2)</p><p>​    ③ 系统先假定可为P1分配资源，并修改Available, Allocation1和Need1向量，由此形成的资源变化情况如图 3-15所示。</p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td></td><td>A  B  C</td><td>A  B  C</td><td>A  B  C</td><td>A  B  C</td></tr><tr><td>P0</td><td>7  5  3</td><td>0  1  0</td><td>7  4  3</td><td>2  3  0</td></tr><tr><td>P1</td><td>3  2   2</td><td>3  0   2</td><td>0  2   0</td><td></td></tr><tr><td>P2</td><td>9  0  2</td><td>3  0  2</td><td>6  0  0</td><td></td></tr><tr><td>P3</td><td>2  2  2</td><td>2  1  1</td><td>0  1  1</td><td></td></tr><tr><td>P4</td><td>4  3  3</td><td>0  0  2</td><td>4  3  1</td></tr></tbody></table></div><p>​    ④ 再利用安全性算法检查此时系统是否安全。 </p><p>因为分配后能存在这样的一个安全序列{P1，P3，P4，P0，P2} 所以，这次分配是安全的。</p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td>A  B C</td><td>A  B C</td><td>A  B  C</td><td>A  B C</td><td></td></tr><tr><td>P1</td><td>2  3  0</td><td>0  2  0</td><td>3  0  2</td><td>5  3  2</td><td>true</td></tr><tr><td>P3</td><td>5  3  2</td><td>0  1  1</td><td>2  1  1</td><td>7  4  3</td><td>true</td></tr><tr><td>P4</td><td>7  4  3</td><td>4  3  1</td><td>0  0  2</td><td>7  4  5</td><td>true</td></tr><tr><td>P0</td><td>7  4  5</td><td>7  4  3</td><td>0  1  0</td><td>7  5  5</td><td>true</td></tr><tr><td>P2</td><td>7  5  5</td><td>6  0  0</td><td>3  0  2</td><td>10  5  7</td><td>true</td></tr></tbody></table></div><ol><li><p>假定系统中有五个进程｛P1, P2, P3, P4, P5｝和三类资源｛A, B, C｝，各种资源的数量分别为17、5、20，在T0时刻的资源分配情况如图所示。</p><p>| 资源情况 | Max        | Allocation | Need      | Available（Work） |<br>| ———— | ————— | ————— | ————- | ————————- |<br>| 进程     | A  B    C  | A  B    C  | A  B    C | A  B    C         |<br>| P1       | 5  5    9  | 2  1    2  | 3  4    7 | 2  3    3         |<br>| P2       | 5  3    6  | 4  0    2  | 1  3    4 |                   |<br>| P3       | 4  0    11 | 4  0    5  | 0  0    6 |                   |<br>| P4       | 4  2    5  | 2  0    4  | 2  2    1 |                   |<br>| P5       | 4  2    4  | 3  1    4  | 1  1    0 |                   |</p></li></ol><p>   （1）利用下表来对T0 时刻系统是否为安全状态进行分析。检验T0 时刻系统是否为安全状态，若是在安全状态，请给出一个安全序列。  <strong>（本问5分）</strong></p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td>A  B C</td><td>A  B C</td><td>A  B   C</td><td>A  B C</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>   （2）在T0时刻如果进程P1发出请求向量Request1(1，2，3)，是否能实现安全分配？为什么？(画表进行分析)  <strong>（本问10分）</strong></p><p>   参考答案：</p><p>   （1） <strong>（本问5分）</strong></p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td>A  B C</td><td>A  B C</td><td>A  B   C</td><td>A  B C</td><td></td></tr><tr><td>P4</td><td>2  3   3</td><td>2  2  1</td><td>2  0   4</td><td>4  3   7</td><td>True</td></tr><tr><td>P5</td><td>4  3   7</td><td>1  1   0</td><td>3  1   4</td><td>7  4   11</td><td>True</td></tr><tr><td>P1</td><td>7 4   11</td><td>3  4   7</td><td>2  1   2</td><td>9  5   13</td><td>True</td></tr><tr><td>P2</td><td>9 5 13</td><td>1  3   4</td><td>4  0   2</td><td>13 5 15</td><td>True</td></tr><tr><td>P3</td><td>13 5 15</td><td>0  0   6</td><td>4  0   5</td><td>17 5 20</td><td>True</td></tr></tbody></table></div><p>   答：在T0时刻存在着一个安全序列{P4，P5，P1 ，P2 ，P3}，故系统是安全的。</p><p>   （2）P1请求资源：P1发出请求向量Request1(1，2，3)，系统按银行家算法进行检查：</p><p>   ​    ① Request1(1，2，3)≤Need1(2，2，1)</p><p>   ​    ② Request1(1，2，3)≤Available(2，3，3)</p><p>   ​    ③ 系统先假定可为P1分配资源，并修改Available, Allocation1和Need1向量，由此形成的资源变化情况如下图所示。</p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Max</th><th>Allocation</th><th>Need</th><th>Available（Work）</th></tr></thead><tbody><tr><td></td><td>A  B    C</td><td>A  B    C</td><td>A  B    C</td><td>A  B    C</td></tr><tr><td>P1</td><td>5  5    9</td><td>3  3    5</td><td>2  2    4</td><td>1  1    0</td></tr><tr><td>P2</td><td>5  3    6</td><td>4  0    2</td><td>1  3    4</td><td></td></tr><tr><td>P3</td><td>4  0    11</td><td>4  0    5</td><td>0  0    6</td><td></td></tr><tr><td>P4</td><td>4  2    5</td><td>2  0    4</td><td>2  2    1</td><td></td></tr><tr><td>P5</td><td>4  2    4</td><td>3  1    4</td><td>1  1    0</td></tr></tbody></table></div><p>   ​    ④ 再利用安全性算法检查此时系统是否安全。 </p><p>   因为分配后能存在这样的一个安全序列{P5，P1，P2，P3，P4} 所以，这次分配是安全的。</p><div class="table-container"><table><thead><tr><th>资源情况  进程</th><th>Work</th><th>Need</th><th>Allocation</th><th>Work+ Allocation</th><th>Finish</th></tr></thead><tbody><tr><td></td><td>A  B C</td><td>A  B C</td><td>A  B   C</td><td>A  B C</td><td></td></tr><tr><td>P5</td><td>1  1   0</td><td>1  1   0</td><td>3  1   4</td><td>4    2  4</td><td>true</td></tr><tr><td>P1</td><td>4  2   4</td><td>2  2   4</td><td>3  3   5</td><td>7    5  9</td><td>true</td></tr><tr><td>P2</td><td>7  5   9</td><td>1  3   4</td><td>4  0   2</td><td>11   5  11</td><td>true</td></tr><tr><td>P3</td><td>11 5 11</td><td>0  0   6</td><td>4  0   5</td><td>15   5  16</td><td>true</td></tr><tr><td>P4</td><td>15 5 16</td><td>2  2   1</td><td>2  0   4</td><td>17  5   20</td><td>true</td></tr></tbody></table></div><ol><li><p>某请求分页系统的局部页面置换策略如下：</p><p>​    系统从0时刻开始扫描，每隔5个时间单位扫描一轮驻留集（扫描时间忽略不计），本轮没有被访问过的页框将被系统回收，并放入到空闲页框链尾，其中内容在下一次被分配之前不被清空。当发生缺页时，如果该页曾被使用过且还在空闲页框链表中，则重新放回进程的驻留集中；否则，从空闲页框链表头部取出一个页框。</p><p>假设不考虑其它进程的影响和系统开销，初始时进程驻留集为空。目前系统空闲页框链表中页框号依次为32、15、21、41。进程P依次访问的 &lt;虚拟页号，访问时刻&gt; 是：<1, 1>、<3, 2>、<0, 4>、<0, 6>、<1, 11>、<0, 13>、<2, 14>。请回答下列问题。</p><p>（1）访问 <0, 4> 时，对应的页框号是什么？说明理由。</p><p>（2）访问 <1, 11> 时，对应的页框号是什么？说明理由。</p><p>（3）访问 <2, 14> 时，对应的页框号是什么？说明理由。</p><p>（4）该策略是否适合于时间局部性好的程序？说明理由。</p><p>答案：</p><p>（1）页框号是21。</p><p>由于初始时进程驻留集为空，目前系统空闲页框链表中页框号依次为32、15、21、41。因此，访问<1, 1>时，将1号页装入32号页框，访问<3, 2>时，将3号页装入15号页框，访问<0, 4>时，将0号页装入21号页框。</p><p>（2）页框号是32。</p><p>因为访问 <1, 1> 时，1号页被装入32号页框，但在10时刻进行第2轮扫描时，1号页所在的32号页框由于在本轮未被访问而被系统收回，访问 <1, 11> 时，1号页所在的32号页框仍在空闲页框链表中，因此重新被放回进程的驻留集中。</p><p>（3）页框号是41。</p><p>因为2号页是首次访问，14时刻系统空闲页框链表中页框号依次为41、15，因此将取出链首的41号页框装入2号页。</p><p>（4）该策略适合于时间局部性好的程序。</p><p>因为置换时，选择的是最近未被访问的页面淘汰，根据局部性原理，这样的页面在最近的将来仍可能不被访问。而且即使刚被淘汰的页面又被访问，如果该页还在空闲页框链表中，只需重新将其放回进程的驻留集中即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV操作和管程题目汇总</title>
      <link href="/2024/06/20/PV%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AE%A1%E7%A8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
      <url>/2024/06/20/PV%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AE%A1%E7%A8%8B%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h2><h3 id="飞机票问题"><a href="#飞机票问题" class="headerlink" title="飞机票问题"></a>飞机票问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[m];</span><br><span class="line">semaphore s[m];</span><br><span class="line">cobegin</span><br><span class="line">process Pi &#123;</span><br><span class="line">    <span class="type">int</span> Xi;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        按乘客要求找到A[j];</span><br><span class="line">        P(s[j]);</span><br><span class="line">        Xi = A[j];</span><br><span class="line">        <span class="keyword">if</span> (Xi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Xi = Xi - <span class="number">1</span>;</span><br><span class="line">            A[j] = Xi;</span><br><span class="line">            输出一张票</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            输出“票已售完”</span><br><span class="line">        &#125;</span><br><span class="line">        V(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：每次最多4人进入房间</span></span><br><span class="line">semaphore fork[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    fork = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">semaphore room = <span class="number">4</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">philosopher_i</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(room);</span><br><span class="line">        P(fork[i]);</span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        V(frok[i]);</span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        V(room);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 方法二：偶数位先左再右；奇数先右再左</span></span><br><span class="line">semaphore fork[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    fork = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">philosopher_i</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        think();</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            P(fork[i]);</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">            eat();</span><br><span class="line">            V(frok[i]);</span><br><span class="line">            V(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">            P(fork[i]);</span><br><span class="line">            eat();</span><br><span class="line">            V(frok[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">            V(fork[i]);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buffer[k];</span><br><span class="line"><span class="type">int</span> putptr = <span class="number">0</span>, getptr = <span class="number">0</span>;</span><br><span class="line">semaphore sput = k;</span><br><span class="line">semaphore sget = <span class="number">0</span>;</span><br><span class="line">semaphore m1 = <span class="number">1</span>, m2 = <span class="number">1</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sput);</span><br><span class="line">        P(m1);</span><br><span class="line">        buffer[putptr] = product;</span><br><span class="line">        putptr = (putptr + <span class="number">1</span>) % k;</span><br><span class="line">        V(m1);</span><br><span class="line">        V(sget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">comsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sget);</span><br><span class="line">        P(m2);</span><br><span class="line">        product = buffer[getptr];</span><br><span class="line">        getptr = (getptr + <span class="number">1</span>) % k;</span><br><span class="line">        V(m2);</span><br><span class="line">        V(sput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="🍎🍊问题"><a href="#🍎🍊问题" class="headerlink" title="🍎🍊问题"></a>🍎🍊问题</h3><p>桌上有一只盘子，每次只能放入一只水果。爸爸专向盘子中放苹果(apple)，妈妈专向盘子中放桔子(orange)，一个儿子专等吃盘子中的桔子，一个女儿专等吃盘子里的苹果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore sp = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">father</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sp);</span><br><span class="line">        V(apple)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">mother</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sp);</span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">son</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        V(sp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        V(sp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><h4 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore wlock = <span class="number">1</span>;</span><br><span class="line">semaphore rlock = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(rlock);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>) &#123;</span><br><span class="line">            P(wlock);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rlock);</span><br><span class="line">        <span class="comment">// reading...</span></span><br><span class="line">        P(rlock);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wlock);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(wlock);</span><br><span class="line">        <span class="comment">// writing;</span></span><br><span class="line">        V(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h4 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">semaphore rlock = <span class="number">1</span>;</span><br><span class="line">semaphore wlock = <span class="number">1</span>;</span><br><span class="line">semaphore S1 = <span class="number">1</span>, S2 = <span class="number">1</span>, S3 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readercount = <span class="number">0</span>, writercount;</span><br><span class="line">cobegin </span><br><span class="line">process <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    P(S3);</span><br><span class="line">    P(rlock);</span><br><span class="line">    P(S1);</span><br><span class="line">   <span class="keyword">if</span> (readercount == <span class="number">0</span>) &#123;</span><br><span class="line">        P(wlock);</span><br><span class="line">    &#125;</span><br><span class="line">    readercount++;</span><br><span class="line">    V(S1);</span><br><span class="line">    V(rlock);</span><br><span class="line">    V(S3);</span><br><span class="line">    <span class="comment">// reading</span></span><br><span class="line">    P(S1);</span><br><span class="line">    readercount--;</span><br><span class="line">   <span class="keyword">if</span> (readercount == <span class="number">0</span>) &#123;</span><br><span class="line">        V(wlock);</span><br><span class="line">    &#125;</span><br><span class="line">    V(S1);    </span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    P(S2);</span><br><span class="line">    <span class="keyword">if</span> (writercount == <span class="number">0</span>) &#123;</span><br><span class="line">        P(rlock);</span><br><span class="line">    &#125;</span><br><span class="line">    writercount++;</span><br><span class="line">    V(S2);</span><br><span class="line">    P(wlock);</span><br><span class="line">    <span class="comment">// writing...</span></span><br><span class="line">    V(wlock);</span><br><span class="line">    P(S2);</span><br><span class="line">    writercount--;</span><br><span class="line">    <span class="keyword">if</span> (writercount == <span class="number">0</span>) &#123;</span><br><span class="line">        V(rlock);</span><br><span class="line">    &#125;</span><br><span class="line">    V(S2);   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="读写公平"><a href="#读写公平" class="headerlink" title="读写公平"></a>读写公平</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">semaphore wlock = <span class="number">1</span>;</span><br><span class="line">semaphore rlock = <span class="number">1</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readercount = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        P(s);</span><br><span class="line">        P(rlock);</span><br><span class="line">        <span class="keyword">if</span> (readercount == <span class="number">0</span>) &#123;</span><br><span class="line">            P(wlock);</span><br><span class="line">        &#125;</span><br><span class="line">        readercount++;</span><br><span class="line">        V(rlock);</span><br><span class="line">        V(s);</span><br><span class="line">        <span class="comment">// reading...</span></span><br><span class="line">        P(rlock);</span><br><span class="line">        readercount--;</span><br><span class="line">        <span class="keyword">if</span> (readercount == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wlock);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(s);</span><br><span class="line">        P(wlock);</span><br><span class="line">        <span class="comment">// writing...</span></span><br><span class="line">        V(wlock);</span><br><span class="line">        V(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="睡眠理发师问题"><a href="#睡眠理发师问题" class="headerlink" title="睡眠理发师问题"></a>睡眠理发师问题</h3><p>理发店理有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子如果没有顾客，理发师便在理发椅上睡觉一个顾客到来时，它必须叫醒理发师如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开使用PV操作求解该问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore barber = <span class="number">0</span>;</span><br><span class="line">semaphore customer = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> CHAIRS = n;</span><br><span class="line"><span class="type">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> customercount = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">barber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(customer);</span><br><span class="line">        P(mutex);</span><br><span class="line">        waiting--;</span><br><span class="line">        V(barber);</span><br><span class="line">        V(mutex);</span><br><span class="line">        cut_hair();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">cuntomer</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex)</span><br><span class="line">    <span class="keyword">if</span> (waiting &lt; CHAIRS) &#123;</span><br><span class="line">        waiting++;</span><br><span class="line">        V(customer);</span><br><span class="line">        V(mutex);</span><br><span class="line">        P(barber);</span><br><span class="line">        get_haircut();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        leave; <span class="comment">// 椅子满，离开</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="农夫猎人问题"><a href="#农夫猎人问题" class="headerlink" title="农夫猎人问题"></a>农夫猎人问题</h3><p>有一个铁笼子，每次只能放入一个动物。猎手向笼中放入老虎，农夫向笼中放入羊；动物园等待取笼中的老虎，饭店等待取笼中的羊。请用P、V操作原语写出同步执行的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore cage = <span class="number">1</span>;</span><br><span class="line">semaphore tiger = <span class="number">0</span>;</span><br><span class="line">semaphore sheep = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">hunter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(cage);</span><br><span class="line">        V(tiger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">farmer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(cage);</span><br><span class="line">        V(sheep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">zoo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(tiger);</span><br><span class="line">        V(cage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">restaurant</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sheep);</span><br><span class="line">        V(cage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="银行业务问题"><a href="#银行业务问题" class="headerlink" title="银行业务问题"></a>银行业务问题</h3><p>某大型银行办理人民币储蓄业务，由n个储蓄员负责。每个顾客进入银行后先至取号机取一个号，并且在等待区找到空沙发坐下等着叫号。取号机给出的号码依次递增，并假定有足够多的空沙发容纳顾客。当一个储蓄员空闲下来，就叫下一个号。请用信号量和P，V操作正确编写储蓄员进程和顾客进程的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span>;</span><br><span class="line">semaphore server = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">customer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// take a number </span></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">// take a seat</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(customer);</span><br><span class="line">    P(server);</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">    P(customer);</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">// call a number</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="comment">// serve a customer</span></span><br><span class="line">    <span class="comment">// customer leave</span></span><br><span class="line">    V(server);</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p>有n个进程将字符逐个读入到一个容量为80的缓冲区中(n&gt;1)，当缓冲区满后，由输出进程Q负责一次性取走这80个字符。这种过程循环往复，请用信号量和P、V操作写出n个读入进程(P1， P2，…Pn)和输出进程Q能正确工作的动作序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">semaphore sget = <span class="number">0</span>;</span><br><span class="line">semaphore sput = <span class="number">80</span>;</span><br><span class="line">semaphore mutex = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> buffer[<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function">cobegin</span></span><br><span class="line"><span class="function">process <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// input x</span></span><br><span class="line">        <span class="built_in">P</span>(sput);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        buffer[i] = x;</span><br><span class="line">        in = (in + <span class="number">1</span>) % <span class="number">80</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">80</span>) &#123;</span><br><span class="line">            <span class="built_in">V</span>(sput);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">process <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(sget);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">out</span>(buffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">V</span>(sput);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="售票问题"><a href="#售票问题" class="headerlink" title="售票问题"></a>售票问题</h3><p>汽车司机与售票员之间必须协同工作，一方面只有售票员把车门关好了司机才能开车，因此，售票员关好门应通知司机开车，然后售票员进行售票。另一方面，只有当汽车已经停下，售票员才能开门上下客，故司机停车后应该通知售票员。假定某辆公共汽车上有一名司机与两名售票员，汽车当前正在始发站停车上客，试用信号量与P、V操作写出他们的同步算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore stop = <span class="number">0</span>;</span><br><span class="line">semaphore run = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">driver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">P(run);</span><br><span class="line">        P(run);</span><br><span class="line">        <span class="comment">// runing...</span></span><br><span class="line">        V(stop);</span><br><span class="line">        V(stop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">seller</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 上乘客</span></span><br><span class="line">        <span class="comment">// 关门</span></span><br><span class="line">        V(run);</span><br><span class="line">        <span class="comment">// sell ticket</span></span><br><span class="line">        P(stop);</span><br><span class="line">        <span class="comment">// 开门</span></span><br><span class="line">        <span class="comment">// 下乘客</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>一个经典同步问题：吸烟者问题(patil，1971)。三个吸烟者在一个房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴，供应者有丰富货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸和第三个有自己的火柴。供应者随机地将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再把两样东西放在桌子上，唤醒另一个吸烟者。试用信号量和P、V操作求解该问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore sput = <span class="number">1</span>;</span><br><span class="line">semaphore sget[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">businessman</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = RAND() % <span class="number">3</span>;</span><br><span class="line">            j = RAND() % <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i == j);</span><br><span class="line">        P(sput);</span><br><span class="line">        <span class="comment">// put i on table</span></span><br><span class="line">        <span class="comment">// put j on table</span></span><br><span class="line">        <span class="keyword">if</span> ((i == <span class="number">0</span> &amp;&amp; j == <span class="number">1</span>) || (i == <span class="number">1</span> &amp;&amp; j == <span class="number">0</span>)) V(sget[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> ((i == <span class="number">0</span> &amp;&amp; j == <span class="number">2</span>) || (i == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span>)) V(sget[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> ((i == <span class="number">2</span> &amp;&amp; j == <span class="number">1</span>) || (i == <span class="number">1</span> &amp;&amp; j == <span class="number">2</span>)) V(sget[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">consumer</span><span class="params">(k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(sget[k]);</span><br><span class="line">        <span class="comment">// take k from table</span></span><br><span class="line">        <span class="comment">// smoking</span></span><br><span class="line">        V(sput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独木桥问题"><a href="#独木桥问题" class="headerlink" title="独木桥问题"></a>独木桥问题</h3><h4 id="LV1"><a href="#LV1" class="headerlink" title="LV1"></a>LV1</h4><p>独木桥问题1：东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。请用信号量和PV操作写出过独木桥问题的同步算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore turn = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>, mutex2 = <span class="number">1</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">east</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex1);</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        count1++;</span><br><span class="line">        V(mutex1);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        P(mutex1);</span><br><span class="line">        count1--;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process west&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        count2++;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        P(mutex2);</span><br><span class="line">        count2--;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h4 id="LV2"><a href="#LV2" class="headerlink" title="LV2"></a>LV2</h4><p>在独木桥问题1中，限制桥面上最多可以有k辆汽车通过。试用信号量和P，V操作写出过独木桥问题的同步算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore turn = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>, mutex2 = <span class="number">1</span>;</span><br><span class="line">semaphore bridge = k;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">east</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex1);</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        count1++;</span><br><span class="line">        V(mutex1);</span><br><span class="line">        P(bridge);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        V(bridge);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        count1--;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process west&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        count2++;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        P(bridge);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        V(bridge);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        count2--;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(turn);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h4 id="LV3"><a href="#LV3" class="headerlink" title="LV3"></a>LV3</h4><p>在独木桥问题1中，以三辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。试用信号量和P，V操作写出汽车过独木桥问题的同步算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">semaphore S1 = <span class="number">3</span>, S2 = <span class="number">0</span>;</span><br><span class="line">semaphore wait = <span class="number">1</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>, semaphore mutex2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> countu1 = <span class="number">0</span>, countd1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> countu2 = <span class="number">0</span>, countd2 = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">east</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(S1);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        countu1++;</span><br><span class="line">        <span class="keyword">if</span> (countu1 == <span class="number">1</span> &amp;&amp; countd1 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        V(S2);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        countu1--, countd1++;</span><br><span class="line">        <span class="keyword">if</span> (countu1 == <span class="number">0</span> &amp;&amp; countd1 == <span class="number">3</span>) &#123;</span><br><span class="line">            V(wait);</span><br><span class="line">            countd1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">west</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(S2);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        countu2++;</span><br><span class="line">        <span class="keyword">if</span> (countu2 == <span class="number">1</span> &amp;&amp; countd2 == <span class="number">0</span>) &#123;</span><br><span class="line">            P(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        V(S1);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        countu2--, countd2++;</span><br><span class="line">        <span class="keyword">if</span> (countu2 == <span class="number">0</span> &amp;&amp; countd2 == <span class="number">3</span>) &#123;</span><br><span class="line">            V(wait);</span><br><span class="line">            countd2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LV4"><a href="#LV4" class="headerlink" title="LV4"></a>LV4</h4><p>在独木桥问题1中，要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。试用信号量和P、V操作写出过独木桥问题的同步算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">semaphore wait = <span class="number">1</span>;</span><br><span class="line">semaphore stop = <span class="number">1</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">0</span>, mutex2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">process <span class="title function_">east</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(stop);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        count1++;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">1</span>) &#123;</span><br><span class="line">            P(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">        V(stop);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        P(mutex1);</span><br><span class="line">        count1--;</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">west</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(stop);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        count2++;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">1</span>) &#123;</span><br><span class="line">            P(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        V(stop);</span><br><span class="line">        <span class="comment">// 过桥</span></span><br><span class="line">        P(mutex2);</span><br><span class="line">        count2--;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wait);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="仓库进货（2019年）"><a href="#仓库进货（2019年）" class="headerlink" title="仓库进货（2019年）"></a>仓库进货（2019年）</h4><p>⼀个仓库，最多能放A，B产品各m个。每次⽣产需要A，B产品各⼀个。两组供应商分别⽣产A，B产品。当某个产品的数量⽐另⼀个产品数量多n(n&lt;m)个时，仓库暂时停⽌该产品的进货，集中进货另⼀个产品。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">semaphore emptyA, emptyB;</span><br><span class="line">emptyA = m, emptyB = m;</span><br><span class="line">semaphore fullA, fullB;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">fullA = <span class="number">0</span>, fullB = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span>;</span><br><span class="line">process <span class="title function_">producerA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(emptyA);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span> (countA - countB &gt;= n) &#123;</span><br><span class="line">            V(emptyA);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V(fullA);</span><br><span class="line">            countA++;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">producerB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(emptyB);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span> (countB - countA &gt;= n) &#123;</span><br><span class="line">            V(emptyB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V(fullB);</span><br><span class="line">            countB++;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">comsumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(fullA);</span><br><span class="line">        P(fullB);</span><br><span class="line">        P(mutex);</span><br><span class="line">        countA--, countB--;</span><br><span class="line">        P(mutex);</span><br><span class="line">        V(emptyA);</span><br><span class="line">        V(emptyA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><h4 id="Hoare管程的PV操作实现"><a href="#Hoare管程的PV操作实现" class="headerlink" title="Hoare管程的PV操作实现"></a>Hoare管程的PV操作实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">InterfaceModule</span> &#123;</span></span><br><span class="line">    semaphore mutex;</span><br><span class="line">    semaphore next;</span><br><span class="line">    <span class="type">int</span> next_count;</span><br><span class="line">&#125; InterfaceModule;</span><br><span class="line">mutex = <span class="number">1</span>, next = <span class="number">0</span>, next_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter</span><span class="params">(InterfaceModule &amp;IM)</span> &#123;</span><br><span class="line">    P(IM.mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave</span><span class="params">(InterfaceModule &amp;IM)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (IM.next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        V(IM.next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V(IM.mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore &amp;x_sem, <span class="type">int</span> &amp;x_count, InterfaceModule &amp;IM)</span> &#123;</span><br><span class="line">    x_count++;</span><br><span class="line">    <span class="keyword">if</span> (IM.next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        V(IM.next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V(IM.mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    P(x_sem);</span><br><span class="line">    x_xount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore &amp;x_sem, <span class="type">int</span> &amp;x_count, Interface &amp;IM)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        IM.next_count++;</span><br><span class="line">        V(x_sem);</span><br><span class="line">        P(IM.next);</span><br><span class="line">        IM.next_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写者问题-1"><a href="#读写者问题-1" class="headerlink" title="读写者问题"></a>读写者问题</h4><h5 id="写者优先-1"><a href="#写者优先-1" class="headerlink" title="写者优先"></a>写者优先</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">TYPE read_write = monitor &#123;</span><br><span class="line">    <span class="type">int</span> rc, wc;</span><br><span class="line">    semaphore R, W;</span><br><span class="line">    R = <span class="number">0</span>, W = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> R_count, W_count;</span><br><span class="line">    R_count = W_count = <span class="number">0</span>;</span><br><span class="line">    InterfaceModlule IM;</span><br><span class="line">    DEFINE start_read, end_read, start_write, end_write;</span><br><span class="line">    USE wait, signal, enter, leave;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">start_read</span><span class="params">()</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        <span class="keyword">if</span> (wc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait(R, R_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        rc++;</span><br><span class="line">        signal(R, R_count, IM);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">end_read</span><span class="params">()</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        rc--;</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            signal(W, W_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">start_write</span><span class="params">()</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        wc++;</span><br><span class="line">        <span class="keyword">if</span> (wc &gt; <span class="number">1</span> || rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait(W, W_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">end_write</span><span class="params">()</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        wc--;</span><br><span class="line">        <span class="keyword">if</span> (wc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        signal(W, W_count, IM);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signal(R, R_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cobegin </span><br><span class="line">process <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    read_write.start_write();</span><br><span class="line">    <span class="comment">// writing...</span></span><br><span class="line">    read_write.end_write();</span><br><span class="line">&#125;</span><br><span class="line">process <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    read_write.start_read();</span><br><span class="line">    <span class="comment">// reading</span></span><br><span class="line">    read_write.end_read();</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure><h4 id="哲学家就餐问题-1"><a href="#哲学家就餐问题-1" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TYPE ining_philosophers = monitor &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;HUNGRY, EATING, THINKING&#125; state[<span class="number">5</span>];</span><br><span class="line">    semaphore self[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> self_count[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        self[i] = <span class="number">0</span>;</span><br><span class="line">        self_count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InterfaceModule IM;</span><br><span class="line">    DEFINE pickup, putdown;</span><br><span class="line">    USE enter, leave, wait, signal;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span> (state[i] != EATING) &#123;</span><br><span class="line">            wait(self[i], self_count[i], IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        test(i);</span><br><span class="line">        test((i + <span class="number">1</span>) % <span class="number">5</span>);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i] == HUNGRY </span><br><span class="line">            &amp;&amp; state[(i + <span class="number">4</span>)&amp; <span class="number">5</span>] != EATING </span><br><span class="line">            &amp;&amp; state[(i + <span class="number">1</span>) % <span class="number">5</span>)] != EATING) &#123;</span><br><span class="line">            state[i] = EATING;</span><br><span class="line">            signal(self[i], self_count[i], IM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TYPE producer_consumer = monitor &#123;</span><br><span class="line">    <span class="type">int</span> buffer[k];</span><br><span class="line">    <span class="type">int</span> in, out;</span><br><span class="line">    in = out = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    semaphore notfull, notempty;</span><br><span class="line">    notfull = <span class="number">0</span>, notempty = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> notfull_count = <span class="number">0</span>, notempty_count = <span class="number">0</span>;</span><br><span class="line">    InterfaceModule IM;</span><br><span class="line">    DEFINE append, take;</span><br><span class="line">    USE enter, leave, wait, signal;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">append</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            wait(notfull, notfull_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[in] = p;</span><br><span class="line">        in = (in + <span class="number">1</span>) % k;</span><br><span class="line">        count++;</span><br><span class="line">        signal(notempty, notempty_count, IM);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">take</span><span class="params">(<span class="type">int</span> &amp;p)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            wait(notempty, notempty_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        p = buffer[out];</span><br><span class="line">        out = (out + <span class="number">1</span>) % k;</span><br><span class="line">        count--;</span><br><span class="line">        signal(notfull, notfull_count, IM);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍎🍊问题-1"><a href="#🍎🍊问题-1" class="headerlink" title="🍎🍊问题"></a>🍎🍊问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">TYPE apple_orange = monitor &#123;</span><br><span class="line">    semophore sp, ss, sd;</span><br><span class="line">    sp = <span class="number">0</span>, ss = <span class="number">0</span>, sd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sp_count = <span class="number">0</span>, ss_count = <span class="number">0</span>, sd_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> apple = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>APPLE, APPLE&#125; FRUIT;</span><br><span class="line">    FRUIT plate;</span><br><span class="line">    <span class="type">bool</span> full;</span><br><span class="line">    DEFINE put, get;</span><br><span class="line">    USE enter, leave, wait, signal;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">put</span><span class="params">(FRUIT fruit)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        <span class="keyword">if</span> (full) &#123;</span><br><span class="line">            wait(sp, sp_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        plate = fruit;</span><br><span class="line">        full = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fruit == APPLE) &#123;</span><br><span class="line">            signal(sd, sd_count, IM);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            signal(ss, ss_count, IM);</span><br><span class="line">        &#125;</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">get</span><span class="params">(FRUIT fruit, FRUIT &amp;x)</span> &#123;</span><br><span class="line">        enter(IM);</span><br><span class="line">        <span class="keyword">if</span> (!full || fruit != plate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fruit == ORANGE) &#123;</span><br><span class="line">                wait(ss, ss_count, IM);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait(sd, sd_count, IM);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = plate;</span><br><span class="line">        full = <span class="literal">false</span>;</span><br><span class="line">        signal(sp, sp_coumt, IM);</span><br><span class="line">        leave(IM);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程与计算II-复习</title>
      <link href="/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程与计算II-复习"><a href="#软件工程与计算II-复习" class="headerlink" title="软件工程与计算II-复习"></a>软件工程与计算II-复习</h1><h2 id="1-软件工程基础"><a href="#1-软件工程基础" class="headerlink" title="1 软件工程基础"></a>1 软件工程基础</h2><ol><li><p>软件工程的定义</p><p>1）应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</p><p>2）对1）中各种方法的研究。</p></li><li><p>从1950s到2000s之间的特点</p><ul><li>1950s:  科学计算；以机器为中心进行编程；像生产硬件一样生产软件</li><li>1960s: 业务应用(批量数据处理和事务计算)；软件不同于硬件；用软件工艺的方式生产软件</li><li>1970s: 结构化方法；瀑布模型；强调规则和纪律。奠定了软件工程的基础，是后续年代软件工程发展的支撑</li><li>1980s: 追求生产力的最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用</li><li>1990s: 企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；Web应用出现</li><li>2000s: 大规模Web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新</li></ul></li></ol><h2 id="2-项目启动"><a href="#2-项目启动" class="headerlink" title="2 项目启动"></a>2 项目启动</h2><ol><li><p>团队结构</p><ul><li>主程序员团队：有一名技术能力出色的成员被指定为主程序员，主程序员负责领导团队完成任务。</li><li>民主团队：每个成员都能发挥能动性。</li><li>开放团队：为创新而存在；黑箱管理方式。</li></ul></li><li><p>团队建设</p><ul><li>建立团队章程</li><li>持续成功</li><li>和谐沟通</li><li>避免团队杀手<ul><li>防范式管理</li><li>官僚主义</li><li>地理分散</li><li>时间分割</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子控制</li></ul></li></ul></li><li><p>质量保障的措施</p><ul><li>需求开发：需求评审和需求度量。</li><li>体系结构：体系结构评审、集成测试（持续集成）</li><li>详细设计：详细设计评审、设计度量、集成测试（持续集成）</li><li>实现：代码评审、代码度量、测试（测试驱动、持续集成）</li><li>测试：测试、测试度量</li></ul></li><li><p>配置管理活动</p><ol><li><p>标识配置项：确定哪些配置项需要被保存和管理；给配置项确定标识，设置唯一的ID；详细说明配置项的特征，包括生产者、基线建立时间、使用者。</p></li><li><p>版本管理：为纳入配置管理的配置项赋予初始版本号，并在发生变更时更新版本号。</p></li><li><p>变更控制：配置项发生变更时，需要依据变更控制过程进行处理。</p></li><li><p>配置审计：验证配置项的完整性、正确性、一致性和可追踪性。</p></li><li><p>状态报告：对在动态演化着的配置项信息及其度量取快照。</p></li><li><p>软件发布管理：将配置项发布到开发活动之外。</p></li></ol></li><li><p>配置项：需要进行配置管理的软件开发制品，包括最终制品和中间制品。</p></li><li><p>基线：已经经过正式评审的规格说明或制品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能变更。</p></li><li><p>变更控制</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/4599885bc240c65969be9e5885bad13-17186391259173.png" alt="4599885bc240c65969be9e5885bad13"></p></li><li><p>项目管理的目标</p><ul><li>在限定时间内</li><li>在一定的成本内</li><li>在要求的质量水平上</li><li>高效使用资源</li><li>获得客户认可</li></ul></li></ol><h2 id="3-需求基础"><a href="#3-需求基础" class="headerlink" title="3 需求基础"></a>3 需求基础</h2><ol><li><p>需求工程的活动</p><ul><li>需求开发<ul><li>需求获取</li><li>需求分析</li><li>需求规格说明</li><li>需求验证</li></ul></li><li>需求管理</li></ul></li><li><p>需求获取的重要任务</p><ul><li>目标分析<ol><li>根据问题确定目标</li><li>通过分析利害关系人确定目标</li></ol></li><li>用户需求获取<ol><li>面谈</li><li>集体获取方法</li><li>头脑风暴</li><li>原型</li></ol></li></ul></li><li><p>需求分析的任务</p><ul><li>边界分析</li><li>需求建模</li></ul></li><li><p>什么是需求</p><p>1）用户为了解决问题或达到某些目标所需要的条件或能力。</p><p>2）系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力。</p><p>3）对1或2中的一个条件或一种能力的一种文档化表述。</p></li><li><p>需求分层</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/62791ef2a1cd403bd825b576afb3dc5-17186391387966.png" alt="62791ef2a1cd403bd825b576afb3dc5"></p><ol><li><p>业务需求（BR）</p><p>1）业务需求是<strong>高层次的解决方案和系统特性</strong>、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。为了满⾜⽤户的业务需求，需求⼯程师需要描述系统⾼层次的解决⽅案，定义系统应该具备的特性（Feature），即系统特性（SF）。</p><p>2）Eg. 在系统使用3个月后，销售额度应该提高20%(期望，没有从软件角度进行描述，业务需求)</p></li><li><p>用户需求（UR）</p><p>1）执行具体任务的用户对系统<strong>所能完成任务的期望</strong>，描述了系统能帮用户做什么(直接用户、间接用户)</p><p>2）每一个系统特性对应一组用户需求</p><p>3）特性</p><ul><li>模糊、不清晰（允许适度的用形容词和副词）</li><li>多特性混杂（功能和非功能的混杂）</li><li>多逻辑混杂（一个任务需要多次系统交互才能完成）</li></ul><p>4）Eg.在系统要帮助收银员完成销售处理</p></li><li><p>系统级需求（SR）</p><p>1）需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的一个实现细节</strong>(和用户需求有着很大的区别)</p><p>2）Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个⼈信息。</p></li></ol></li><li><p>需求分类</p><ul><li>需求<ul><li>项目需求(人的数量、计划成本、时间)<ul><li>R5：项⽬的成本要控制在60万元人民币以下。</li><li>R6：项⽬要在6个月内完成。</li></ul></li><li>过程需求(人的分工、合作、方法、工具)<ul><li>R7：在开发中，开发者要提交软件需求规格说明文档、设计描述文档和测试报告。</li><li>R8：项目要使用持续集成⽅法进行开发。</li></ul></li><li>系统需求<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li><li>其他需求<ul><li>R9：系统要购买专用服务器，其规格不低于….。</li><li>R10：系统投⼊使⽤时，需要对⽤户进⾏1个星期的集中培训。</li></ul></li></ul></li><li>不切实际的期望<ul><li>R11：系统要分析会员的购买记录，预测该会员将来⼀周和⼀个月内、会购买的商品；(技术上不可行)</li><li>R12：系统要能够对每月的出入库以及销售行为进行标准的财务分析；(在有限的资源条件下不可行)</li><li>R13：在使用系统时，收银员必须要在2个⼩时内完成一个销售处理的所有操作。(超出了软件所影响的问题域范围)</li></ul></li></ul></li><li><p>软件需求的分类</p><ol><li><p>功能需求：和系统主要共作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。功能需求主要表现为系统和环境之间的行为交互。</p><p>Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。</p></li><li><p>性能需求：系统整体或系统组成部分应该拥有的性能特征，例如CPU使⽤率、内存使⽤率等。</p><ul><li>速度：系统完成任务的时间(所有用户查询必须在10s内完成)</li><li>容量：系统能存储的数据量(系统因该能够存储至少100万个销售信息)</li><li>吞吐量：系统在连续的时间内完成的事务数量(解释器每分钟应该能够至少解析5000条没有错误的语句)</li><li>负载：系统可以承载的并发工作量(系统应该允许50个营业服务器同时从集中服务器上进行数据的上传或下载)</li><li>实时性：严格的实时要求(系统监测到异常时，监视器必须在0.5s内发出警报，和故障警报不一样，故障不是系统的正常功能)</li></ul></li><li><p>质量需求(QA)：系统为了满足规定的及隐含的所有要求而需要具备的要素称为质量</p><ul><li>可靠性：在规格时间间隔内和规定条件下，系统或部件执行所要求能力的能力。(在进⾏数据的下载和上传中，如果网络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复)</li><li>可用性：软件系统在投⼊使用时可操作和可访问的程度或能实现其指定系统功能的概率。(系统的可用性要达到98%)</li><li>安全性：软件组织对其程序和数据进⾏未授权访问的能力，未授权的访问可能是有意，也可能是无意的。(VIP顾客只能查看⾃⼰的个⼈信息和购买记录)</li><li>可维护性：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。(如果系统要增加新的特价类型，要能够在2个人月内完成。)</li><li>可移植性：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。(集中服务器要能够在1人月内从Window 7操作系统更换到Solaris 10操作系统。)</li><li>易用性：与⽤户使用软件所花费的努力及其对使用的评价相关的特性。(使⽤系统1个月的收银员进⾏销售处理的效率要达到10件商品/分钟。)</li><li>往往会有形容词和副词</li></ul></li><li><p>对外接口：系统和环境中其他系统之间需要建立的接口，包括硬件接口、软件接口、数据库接口等等。</p><ul><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li><li>Eg.注册使用Google Maps API</li></ul></li><li><p>约束：进⾏系统构造时需要遵守的约束，例如编程语言、硬件设施等</p><ul><li>系统开发及运行的环境(包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等,Eg.系统使用Java语言进行开发)</li><li>问题域内的相关标准(包括法律法规、行业协定、企业规章等。)</li><li>商业规则:(用户在任务执⾏中的一些潜在规则也会限制开发⼈员设计和构建系统的选择范围)</li><li>Eg. 已过保质期的食品不能销售</li><li>Eg. 顾客可以使用美元付款</li></ul></li><li><p>数据需求(属于功能需求的一种,DR)：功能需求的补充：如果在功能需求部分明确定义了相关的数据结构，那么就不需要再行定义数据需求。数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：</p><ul><li>各个功能使用的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li><li>Eg.系统需要存储的数据实体及其关系为图6-14的内容。(数据实体及其关系)</li><li>Eg.系统需要存储1年内的销售记录和退货记录。(数据保持)</li></ul></li></ol></li><li><p>需求汇总</p><ul><li>项目的成本要控制在60万元人民币以下。<ul><li>项目需求</li></ul></li><li>项目要在6个月内完成。<ul><li>项目需求</li></ul></li><li>在开发中，开发者要提交软件需求规格说明⽂档、设计描述⽂档和测试报告。<ul><li>过程需求</li></ul></li><li>项目要使用持续集成方法进行开发。<ul><li>过程需求</li></ul></li><li>系统要分析会员的购买记录，预测会员将来一个月内会购买的商品<ul><li>不切实际的需求</li></ul></li><li>系统要能够对每月的出入库以及销售行为进行标准的财务分析<ul><li>不求实际的需求</li></ul></li><li>在使用系统时，收银员必须要在2个小时内完成一个销售处理的所有操作<ul><li>不求实际的需求</li></ul></li><li>所有用户查询必须在10秒内完成<ul><li>性能需求（速度）</li></ul></li><li>系统应该能够存储至少100万个销售信息<ul><li>性能需求（容量）</li></ul></li><li>解释器每分钟应该至少解析5000条没有错误的语句<ul><li>性能需求（吞吐量）</li></ul></li><li>系统应该允许50个营业服务器同时从集中服务器上进行数据的上传或下载<ul><li>性能需求（吞吐量）</li></ul></li><li>监测到病人异常后，监控器必须在0.5秒内发出警报<ul><li>性能需求（实时性）</li></ul></li><li>在进行数据的下载和上传中，如果网络故障，系统不能出现故障<ul><li>质量需求（可靠性）</li></ul></li><li>系统的可用性要达到98%<ul><li>质量需求（可用性）</li></ul></li><li>VIP顾客只能查看自己的个人信息和购买记录<ul><li>质量需求（安全性）</li></ul></li><li>收银员只能查看，不能修改、删除VIP顾客的信息<ul><li>质量需求（安全性）</li></ul></li><li>如果系统要增加新的特价类型，需要能够在2个人月内完成<ul><li>质量需求（可维护性）</li></ul></li><li>集中服务器要能够在1个人月内从Window操作系统更换到Solaris操作系统<ul><li>质量需求（可移植性）</li></ul></li><li>使用系统1个月的收银员进行销售处理的效率要达到10件商品/分钟<ul><li>质量需求（易用性）</li></ul></li><li>系统要能够存储1年内的销售记录和退货记录<ul><li>数据需求</li></ul></li><li>当订单数量大于现有数量时，系统必须通知操作员<ul><li>功能需求</li></ul></li><li>顾客使用信用卡付款时，系统必须使用银联专用刷卡设备与银行交易；<ul><li>其他需求（硬件需求）</li></ul></li><li>系统<strong>应该能够</strong>存储3年的交易数据<ul><li>性能需求（”应该能够“描述的是对容量的需求，如果是”需要存储“则是数据需求）</li></ul></li><li>系统应支持使用第三方凭证如Google, Github登录<ul><li>功能需求</li></ul></li><li>该软件管理工具软件必须帮助项目管理者进行开发管理工作，以通过CMMI-4的评估<ul><li>用户需求（系统能为用户实现什么）</li></ul></li><li>系统的成本计算为：成本=人力成本+库存成本<ul><li>软件规格（不懂）</li></ul></li><li>系统使用之前 ，需要对收银员进行 10天的专门培训。<ul><li>其他需求（人力需求）</li></ul></li><li>经过10天培训的收银员就能够熟练使用系统<ul><li>质量需求（易用性）</li></ul></li><li>该软件管理工具的 开发过程自身必须符合CMMI-4的评估<ul><li>过程需求</li></ul></li><li>产品在发布1年之后，必须在出版的A、B、C三个产品评论刊物中被评为最可靠的产品<ul><li>业务需求</li></ul></li><li>系统必须能够与Oracle数据库交互<ul><li>约束（数据库不是其他系统软件，是系统的一部分，因此不是对外接口）</li></ul></li><li>商品标识的类型要能够在0.5个人月内更改为长整型<ul><li>质量需求（可修改性）</li></ul></li><li>默认的信用卡类型是“银联”<ul><li>数据需求（默认值）</li></ul></li><li>使用扫描仪扫描文件，传递回的数据为pdf格式文件。<ul><li>对外接口（强调软件与硬件之间的传递数据）</li></ul></li><li>超市的成本主要由人力成本和库存成本组成<ul><li>问题域信息</li></ul></li><li>系统应该一周7天每天24小时可用<ul><li>不切实际的需求</li></ul></li><li>系统每小时能够处理3000次呼叫<ul><li>性能需求（负载）</li></ul></li><li>订单数量不能大于现有库存数量<ul><li>约束（商业规则）</li></ul></li><li>系统开发必须在6个月内完成<ul><li>项目需求</li></ul></li><li>软件产品必须能够在3秒内对用户请求作出响应<ul><li>性能需求</li></ul></li><li>收银员完成一次商品交易过 程中操作失误的数不得超3次 ，且每失误都能在 5秒内更正<ul><li>质量需求（易用性 – 出错率）</li></ul></li><li>系统投入运行后，通过调查问卷的方式用户满意程度应在 70%以 上<ul><li>质量需求（易用性 – 主观满意度）</li></ul></li><li>每日报表中，标题的形式必须是 每日报告：dd-mm-yy<ul><li>不确定，对外接口/数据需求</li></ul></li><li>在销售商品之后，系统应该更新库存的数量如果低于最低限值，系统应该发出警示信号<ul><li>功能需求</li></ul></li><li>每一个收银员都应该有一个记录，记录的内容包括名字和 ID号。记录应该被建立成链表的形式。<ul><li>数据需求</li></ul></li><li>使用银联专刷卡设备，向银行传递的交易数据格式为 …<ul><li>对外接口</li></ul></li><li>过期商品的每日报表必须列出其名称、制造商和批号。<ul><li>数据需求</li></ul></li><li>商品的标识是由 0~24 位字母、数字混合组成的字符串。<ul><li>数据需求</li></ul></li><li>付款单上，默认的信用卡类型是 银联<ul><li>数据需求（默认数据）</li></ul></li><li>电梯的默认停运楼层必须是最低楼层到最高楼层范围内的某个数字<ul><li>数据需求</li></ul></li><li>当存储设备发生故障时，系统要在10秒内发现<ul><li>质量需求（可靠性；系统本身故障不是正常功能，因此不是性能需求）</li></ul></li><li>数据库与服务器之间的通信必须是加密的<ul><li>质量需求（安全性）</li></ul></li></ul></li></ol><h2 id="4-需求分析方法"><a href="#4-需求分析方法" class="headerlink" title="4 需求分析方法"></a>4 需求分析方法</h2><h3 id="4-1-用例图"><a href="#4-1-用例图" class="headerlink" title="4.1 用例图"></a>4.1 用例图</h3><ol><li>用例的定义：在系统（或者子系统或者类）和外部对象的交互中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种<strong>有价值的服务</strong>。</li><li><p>用例图基本元素：</p><ul><li><p>用例：水平椭圆</p></li><li><p>参与者：与系统交互（顾客不是参与者，只有收银员与系统交互）；不一定是人。</p></li><li><p>关系</p></li><li><p>系统边界 </p></li></ul></li><li><p>用例图的建立</p><ul><li><p>目标分析与解决方案的确定</p></li><li><p>寻找参与者</p></li><li>寻找用例</li><li>细化用例：粒度合适的判断标准：用例描述了为<strong>应对一个业务事件</strong>，由<strong>一个用户发起</strong>，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务。</li></ul></li></ol><h3 id="4-2-概念类图（领域模型、分析类图）"><a href="#4-2-概念类图（领域模型、分析类图）" class="headerlink" title="4.2 概念类图（领域模型、分析类图）"></a>4.2 概念类图（领域模型、分析类图）</h3><ol><li><p>基本元素</p><ul><li><p>对象：标识符、状态、行为</p></li><li><p>类：共享相同属性和行为的对象的集合</p></li><li><p>链接：<strong>对象</strong>之间的互相协作关系；对象之间的物理或业务联系</p></li><li><p>关联：<strong>类</strong>之间的关系；关联是对象之间链接的抽象</p><ul><li>聚合：表示部分与整体之间的关系</li><li>组合：整体包含部分，且对部分有完全的管理职责，部分无法同时属于其它整体，也无法单独存在</li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/18.png" alt="img"></p></li><li><p>继承：<img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/19.png" alt="img"></p></li></ul></li><li><p>建立概念类图</p><p>1）对每个用例文本描述，尤其是场景描述，建立局部的概念类图</p><ul><li>根据用例的文本描述，<strong>识别候选类</strong></li><li><strong>筛选候选类</strong>，确定概念类</li><li>识别<strong>关联</strong></li><li>识别<strong>重要属性</strong></li></ul><p>2）将所有用例产生的局部概念类图进行合并，建立软件系统的整体概念类图</p></li><li><p>识别候选类</p><ul><li>行为分析</li><li>名词分析：从用例文档描述中识别出有关的名词和名词短语，作为候选类</li><li>CRC</li></ul></li><li><p>确定概念类</p><ul><li>准则：依据系统的需求，该类的对象实例的状态与行为是否全部必要</li><li>既需要维护状态，又依据状态表现一定行为，可确定为概念类</li><li>只需维护状态，不需要表现行为，应该成为其他概念类的属性</li><li>不需要维护状态，却需要表现行为：审视需求是否有遗漏；剔除候选类，转交行为给其他概念类</li><li>不维护状态也不表现行为，完全剔除</li></ul></li><li><p>识别关联</p><ul><li>分析用例文本描述，发现概念类之间的协作</li><li>分析和补充问题域内的关系</li><li>去除冗余关联和导出关联</li></ul></li><li><p>识别重要属性</p></li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614001601976.png" alt="image-20240614001601976"></p><h3 id="4-3-系统顺序图"><a href="#4-3-系统顺序图" class="headerlink" title="4.3 系统顺序图"></a>4.3 系统顺序图</h3><p>将整个系统看做一个黑箱的对象描述，不是多个对象的详细顺序图</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/7031758cf6f6c7aaf208ca5070beaad.png" alt="7031758cf6f6c7aaf208ca5070beaad"></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614001840886.png" alt="image-20240614001840886"></p><h3 id="4-4-状态图"><a href="#4-4-状态图" class="headerlink" title="4.4 状态图"></a>4.4 状态图</h3><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/7df4a00d7df7655526e191d68ce1c1f.png" alt="7df4a00d7df7655526e191d68ce1c1f"></p><ol><li><p>建立状态图：</p><ul><li>确定上下文环境：识别状态的主体</li><li>识别状态</li><li>建立状态转移</li><li>补充详细信息</li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614002732376.png" alt="image-20240614002732376"></p></li></ol><h2 id="5-需求文档化与验证"><a href="#5-需求文档化与验证" class="headerlink" title="5 需求文档化与验证"></a>5 需求文档化与验证</h2><ol><li>用例文档<ul><li>在⽤户的⻆度以⽤例⽂本为主描述软件系统与外界的交互</li><li>基本职责是把问题域信息和需求传达给软件系统解决⽅案的设计者</li></ul></li><li>需求规格说明文档（SRS）<ul><li>在软件产品的⻆度以系统级需求列表的⽅式描述软件系统解决⽅案</li></ul></li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/f4c370f366895c691e03c226182ff18.png" alt="f4c370f366895c691e03c226182ff18"></p><ol><li>为什么需要需求规格说明<ol><li>方便交流：软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以要编写软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li>跟踪和度量：需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li>过程管理：在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化。</li></ol></li><li>需求文档要点<ul><li>技术文档写作要点<ol><li>简洁</li><li>精确：不能使用模糊和起义词汇</li><li>易读<ul><li>有效使用引言、目录、索引等能够增强文档易读性的方法</li><li>使用系统化的方法组织内容信息，提供文档内容的可读性</li></ul></li><li>易修改</li></ol></li><li>需求书写要点<ol><li>使用用户术语<ul><li>不能使用计算机术语：函数、参数</li></ul></li><li>可验证<ul><li>不可验证的例子：用户查询的界面应该友好</li></ul></li><li>可行性<ul><li>不可行需求：系统必须持续可用，即每周7天，每天24小时可用</li></ul></li></ol></li><li>软件需求规格说明文档书写要点<ul><li>充分利用标准的文档模板，保持所有内容位置得当</li><li>保持文档内的需求集具有完备性和一致性</li><li>为需求划分优先级</li></ul></li></ul></li><li>以需求为基础开发系统测试用例<ul><li>以需求列表为线索，开发<strong>测试用例套件</strong>。</li><li>对确定的测试用例套件，使用软件测试技术，主要是基于规格的技术，设计测试场景的输入与输出数据，建立测试用例。</li></ul></li></ol><h2 id="8-软件设计基础"><a href="#8-软件设计基础" class="headerlink" title="8 软件设计基础"></a>8 软件设计基础</h2><ol><li><p>软件设计：</p><ul><li>软件设计是关于软件对象的设计，是一种设计活动。</li><li>既指软件对象实现的规格说明，也指产生这个规格说明的过程。</li><li>软件设计阶段以需求开发的制品（需求规格说明和分析模型）作为设计的基础，构建软件设计方案描述和软件原型，为后期的构造活动提供规划和蓝图。</li></ul></li><li><p>软件设计的核心思想</p><ul><li>分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象:在纵向上聚焦各子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度。</li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614122324270.png" alt="image-20240614122324270"></p></li><li><p>软件设计的核心层次</p><ol><li>高层设计：基于反映软件高层抽象的构件设计，描述系统的高层结构、关注点和设计决策。<ol><li><strong>部件</strong>承载了系统主要的<strong>计算与状态</strong></li><li><strong>连接件</strong>承载部件之间的<strong>交互</strong></li><li>部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，<strong>配置</strong>将它们的实例连接起来</li></ol></li><li>中层设计：更加关注组成构件的模块的划分、导入/导出、过程之间调用关系或者类之间的协作，模块划分<strong>隐藏</strong>⼀些程序片段(数据结构+算法)的细节，暴露接口于外界</li><li>低层设计：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</li></ol></li></ol><h2 id="9-软件体系结构基础"><a href="#9-软件体系结构基础" class="headerlink" title="9 软件体系结构基础"></a>9 软件体系结构基础</h2><ol><li><p>软件体系结构是由部件，连接件，配置组成的。</p><ul><li><p>部件 </p><p> 是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;</p><ol><li>原始部件</li><li>复合部件</li></ol></li><li><p>连接件</p><p>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;</p><ol><li>原始连接件</li><li>复合连接件:是由更细粒度的部件和连接件组成。</li></ol></li><li><p><strong>配置</strong>是对”形式”的发展,定义了”部件”以及”连接件”之间的关联方式,将它们组织成系统的总体结构。</p></li></ul></li><li><p>主程序/子程序风格</p><ul><li>优点<ol><li>流程清晰，易于理解</li><li>强控制性</li></ol></li><li>缺点<ol><li>程序调用是一种强耦合的链接方式，非常依赖交互方的接口规格，这会使得系统难以修改和复用。</li><li>程序调用的连接方式限制了各部件之间的数据交互，可能会使得不同部件使用隐含的共享数据交流，产生不必要的公共耦合，从而破坏它的“正确性”控制能力。</li></ol></li></ul></li><li><p>面向对象式</p><ul><li>优点<ol><li>内部实现的可修改性</li><li>易开发、易理解、易复用</li></ol></li><li>缺点<ol><li>接口的耦合性</li><li>标识的耦合性</li><li>副作用</li></ol></li></ul></li><li><p>分层</p><ul><li>优点<ol><li>设计设计清晰，易于理解</li><li>支持并行开发</li><li>更好的可复用性与内部可修改性</li></ol></li><li>缺点<ol><li>交互协议难以修改</li><li>性能损失</li><li>难以确定层次数量和粒度</li></ol></li></ul></li><li><p>MVC风格</p><ul><li>优点<ol><li>易开发性</li><li>视图和控制的可修改性</li><li>适宜于网络系统开发的特征</li></ol></li><li>缺点<ol><li>复杂性</li><li>模型修改困难</li></ol></li></ul></li><li><p>观察者模式</p><p><img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240618133551101.png" alt="image-20240618133551101"></p></li></ol><h2 id="10-软件体系结构设计与构建"><a href="#10-软件体系结构设计与构建" class="headerlink" title="10 软件体系结构设计与构建"></a>10 软件体系结构设计与构建</h2><ol><li><p>体系结构设计过程</p><ol><li>分析关键需求和项⽬约束；</li><li>选择体系结构⻛格；</li><li>进⾏软件体系结构逻辑（抽象）设计；</li><li>依赖逻辑设计进⾏软件体系结构（实现）设计；</li><li>完善体系结构设计；</li><li>添加构件接⼝；</li><li>迭代过程3-7</li></ol></li><li><p>包设计原理</p><ol><li>重用发布等价原则(REP):重用的粒度就是发布的粒度<ol><li>为重用器分组组件(类)</li><li>单个类通常是不可重用的：几个协作类组成一个包</li><li>包中的类应构成可重用和可释放的模块：模块提供一致的功能</li><li>减少重新使用者的工作</li><li>和相关联的类一起发布，而不是单独进行发布</li></ol></li><li>共同封闭原则(CCP):包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。<ol><li>最小化修改程序员的影响</li><li>包尽可能大，和CRP互斥</li><li>方法<ol><li>将具有相似闭包的类分组</li><li>面向可以预期的变更封闭包</li><li>将更改限制为几个软件包</li><li>降低包装释放频率</li><li>减少程序员的工作量</li><li>只对可预测的变更有作用，不可预测的变更会为系统带来极大的破坏能力，并且无法进行预测。</li></ol></li></ol></li><li>共同重用原理(CRP):一个包中的所有类应该是能够共同重用的。<ol><li>根据常见重用对类进行分组：避免给用户不必要的依赖</li><li>遵循CRP通常会导致软件包拆分：获得更多，更小，更专注的包</li><li>减少重新使用者的工作</li><li>包尽可能小，和CCP互斥</li></ol></li><li>无环依赖原则(ADP):在包的依赖关系图中不能存在环。必须是有向无环图。<ol><li>第一种单环，DIP依赖倒置即可解决</li><li>第二种互环，A依赖B，且B依赖A</li></ol></li></ol><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/summary/3.png"><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/3.png" alt="img"></a></p><ol><li><p>稳定依赖原则(SDP):朝着稳定(别人的修改不影响我)的方向进行依赖</p><ol><li><p>Ca:输入耦合度，包外部依赖本包的类个数</p></li><li><p>Ce:输出耦合度，包内部依赖于包外部的类的个数</p></li><li><p>不稳定性: I=Ce/(Ce+Ca), I越小越稳定</p></li></ol></li></ol><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt10/16.png"><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/16.png" alt="img"></a></p><ol><li>稳定抽象原则(SAP):包的抽象程度应该和其稳定程度一致<ol><li>稳定的包应该是抽象的包</li><li>不稳定的包应该是具体的包</li><li>Na:包中抽象类个数</li><li>Nc:包中所有类个数</li><li>抽象度A=Na/Nc</li></ol></li><li>前三条描述的是依赖性，后三条描述的是耦合性</li><li>包设计过程:<ol><li>开发包(构件)设计</li><li>运⾏时的进程</li><li>物理部署</li></ol></li><li>接口定义步骤<ul><li>根据分配的需求确定模块对外接口</li><li>初步设计关键类</li><li>编写接口规范</li></ul></li><li>体系结构开发集成测试用例<ul><li>Stub: 为了完成程序的编译和连接而使用的暂时代码；对外模拟和代替承担模块接口的关键类；比真实程序简单，使用最为简单的逻辑</li><li>Dirver: 模拟上层模块，驱动一个测试, 就是驱动一个Service的行为</li></ul></li></ol></li></ol><h2 id="11-人机交互设计"><a href="#11-人机交互设计" class="headerlink" title="11 人机交互设计"></a>11 人机交互设计</h2><ol><li>易用性<ul><li>易学性：新手用户容易学习，能够很快使用系统</li><li>效率：熟练用户使用系统完成任务的速度快</li><li>易记忆性：以前使用过软件系统的用户，能够有效记忆或者快速地重新学会使用该系统</li><li>出错率：用户在使用系统时，会犯多少错，错误有多严重，以及是否能从错误中很容易地恢复</li><li>主观满意度：让用户有良好的体验</li></ul></li><li>人机交互设计原则<ul><li>简洁设计<ul><li>7±2原则</li><li>摘要图片比描述文字更简洁和清晰</li><li>不要使用太大的菜单，不要在一个串口中表现过多的信息类别，不要在一个表单中使用太多的颜色和字体作为线索</li></ul></li><li>一致性设计<ul><li>若一个系统中相似的任务具有完全不一致的交互机制，会导致用户精神模型的不一致，如按OK和Cancel钮位置不一致</li></ul></li><li>低出错率设计<ul><li>不适当的菜单功能灰色屏蔽；禁止数值输入域出现字母字符；提供建议来消除错误</li></ul></li><li>易记性设计<ul><li>减少短期记忆负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ul></li><li>可视化设计<ul><li>按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来</li></ul></li></ul></li><li>精神模型：用户进行人机交互时头脑中的任务模型。人机交互设计需要依据精神模型进行<strong>隐喻设计</strong></li><li>差异性<ul><li>新手用户：对业务不熟悉的人</li><li>专家用户：能够熟练操作计算机完成业务的人</li><li>熟练用户：介于新手用户和专业用户之间的人</li><li>好的人机交互应该为不用的用户群体提供差异化的交互机制。</li></ul></li><li>导航：为用户提供一个很好的完成任务的入口，好的导航会让这个入口非常符合人的精神模型<ul><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主体提供给不同的用户；常用的导航控件包括窗口、菜单、列表、快捷方式、热键</li><li>局部结构通过安排界面布局细节，制造视觉上的线索来给用户提供导航；常用导航控件包括可视化控件布局与组合、按钮设计、文本颜色或字体大小；局部结构的设计主要以用户关注的任务细节为主要依据</li></ul></li><li>反馈<ul><li>目的是提示用户交互行为的结果，但不能打断用户工作时的意识流</li></ul></li><li>协作式交互：⼈和计算机是⼈机交互的两⽅，其中⼈的因素是⽐较固定的，⼀定时期内不会发⽣⼤的变化，所以要让⼆者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。<br>这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计</li></ol><h2 id="12-详细设计"><a href="#12-详细设计" class="headerlink" title="12 详细设计"></a>12 详细设计</h2><ol><li>详细设计的出发点：软件详细设计是在软件体系结构设计之后进行，以需求开发的结果（需求规格说明和需求分析模型）和软件体系结构的结果（软件体质结构设计方案与原型）为出发点。</li><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ol><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作。</li></ol></li><li>职责分配：将大的职责分给很多对象<ul><li>降低耦合提高内聚</li></ul></li><li>协作：每个类/对象的职责都是比较有限的，但是通过对象之间进行协作可以完成更大的职责。<ul><li>从小到大，将对象的小职责聚合形成大职责</li><li>从大到小，将大职责分配给各个小对象</li></ul></li><li>控制风格<ul><li>集中式：做决策的只有一个对象，其他对象都只和这个中心控制对象进行交互</li><li>委托式：做决策的对象不止一个，这些对象分别承担一定的职责，作出一定决策</li><li>分散式：无法找到明确的控制对象，每个对象都只承担一个相对较小的职责，完全靠各个对象自治的方式来实现大的职责。</li></ul></li><li>协作的测试<ul><li>Mock Objedt</li></ul></li></ol><h2 id="13-模块化与信息隐藏"><a href="#13-模块化与信息隐藏" class="headerlink" title="13 模块化与信息隐藏"></a>13 模块化与信息隐藏</h2><ol><li><p>耦合：两个模块之间关系的复杂程度</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/15.png" alt="img"></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614204514195.png" alt="image-20240614204514195"></p></li></ol><p>   <img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/11.png" alt="img"></p><ol><li><p>内聚：一个模块内部的联系的紧密性</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/16-17183644108143.png" alt="img"></p></li></ol><ol><li><p>信息隐藏：隐藏会改变的设计决策，把每个设计秘密指派给单独的模块，封装每个秘密，使得即使发生变化，变化也不会对其他部分产生影响</p><ul><li>主要秘密：模块所要实现的<strong>用户需求</strong></li><li>次要秘密：模块在实现职责时所涉及的关键实现细节</li><li>角色：模块在整个系统中所承担的角色、所起的作用，以及与哪些模块有关系</li><li>对外接口：模块提供给别的模块的接口</li><li>两种常见的信息隐藏决策：职责的实现；实现的变更</li></ul></li></ol><h2 id="14-详细设计中面向对象方法下的模块化"><a href="#14-详细设计中面向对象方法下的模块化" class="headerlink" title="14 详细设计中面向对象方法下的模块化"></a>14 详细设计中面向对象方法下的模块化</h2><h3 id="14-1-设计原则"><a href="#14-1-设计原则" class="headerlink" title="14.1 设计原则"></a>14.1 设计原则</h3><ol><li><p>Global Variables Consider Harmful 全局变量有害</p><ul><li>公共耦合有风险，增加潜在的链接数量</li></ul></li><li><p>To be Explicit 让代码清晰一点</p><ul><li><p>让代码兼顾清晰性和可修改性</p></li><li><p>例如：可修改性强，但代码不清晰</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614205533497.png" alt="image-20240614205533497"></p><p>修改：</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614205546539.png" alt="image-20240614205546539"></p></li></ul></li><li><p>Do not Repeat 避免重复</p><ul><li>面向接口编程，而不是重复地写逻辑上一致的代码</li></ul></li><li><p>Programming to Interface 针对接口编程</p></li><li><p>The Law of Demeter 迪米特法则</p><ul><li>每个单元对于其他的单元只能拥有有限的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己直接的朋友交谈</li><li>若对象O有方法M，那么M只能调用下列对象的方法：<ul><li>O自己</li><li>M中的参数对象</li><li>任何在M中创建的对象</li><li>O的成员变量</li></ul></li></ul></li><li><p>Interface Segregation Principle(ISP) 接口分离原则</p><ul><li>将一个统一的接口匹配为多个更独立的接口，避免不必要的耦合，实现接口最小化</li></ul></li><li><p>Liskov Subsititution Principle(LSP) 里氏替换法则</p><ul><li>子类型必须能够替换掉基类型而起同样的作用</li><li>为满足LSP：（前置更弱，后置更强）<ul><li>子类方法的前置条件必须与超类方法的前置条件相同或者要求更少</li><li>子类方法的后置条件必须与超类方法的后置条件相同或者要求更多</li></ul></li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614211112157.png" alt="image-20240614211112157"></p><ul><li>子类是父类的一个特殊类型，而不是父类扮演的一个角色</li></ul></li><li><p>Favor Composition Over Inheritance 使用组合替代继承</p><ul><li>只为了复用而不为了组织类型差异的继承用法往往不符合LSP，应该用组合替代继承</li></ul></li><li><p>Single Responsibility Principle(SRP) 单一职责原则</p><ul><li>信息与行为除了要集中之外，还要联合起来表达一个内聚的概念，而不是单纯的堆砌</li><li>一个类只能有一个改变的理由</li></ul></li><li><p>面向对象的内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311530732.png" alt="image-20240618160635011"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311530416.png" alt="image-20240618160709314"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311530737.png" alt="image-20240618160741546"></p></li></ol><h2 id="15-详细设计中面向对象方法下的信息隐藏"><a href="#15-详细设计中面向对象方法下的信息隐藏" class="headerlink" title="15 详细设计中面向对象方法下的信息隐藏"></a>15 详细设计中面向对象方法下的信息隐藏</h2><ol><li><p>信息隐藏：一个模块应该通过稳定的接口对外表现其所承载的需求，而隐藏它对需求的内部实现细节。</p></li><li><p>封装的含义：</p><ul><li>将数据和行为同时包含在类中</li><li>分离对外接口与内部实现</li></ul></li><li><p>封装实现细节</p><ul><li>封装数据和行为：Getter和Setter</li></ul></li></ol><ul><li><p>封装内部结构：<img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311531978.png" alt="image-20240618161255475">迭代器模式</p></li><li><p>封装其他对象的引用</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311531834.png" alt="image-20240618161738087"></p></li><li><p>封装类型信息：LSP使用父类接口隐藏子类的类型信息</p></li><li><p>封装潜在变更：如果预测会发生变更，就应该将其独立为单独的类或者方法，然后为单独的类或方法抽象建立稳定的接口，并在原类中使用该稳定接口以屏蔽潜在变更的影响</p></li></ul><ol><li><p>Minimize The Accessibility of Classes and Members 权限最小化原则</p></li><li><p>Open Close Principle(OCP) 开闭原则</p><ul><li>对扩展开放；对修改封闭</li><li>RTTI is Ugly and Dangerous：运行时类型信息很丑（instanceof😡丑归丑，用还是得用）</li></ul></li><li><p>Dependency Inversion Principle(DIP) 依赖倒置原则</p><ul><li>抽象不应该依赖与细节，细节应该依赖于抽象</li><li>高层模块不应该依赖与低层模块，而是双方都依赖于抽象</li></ul></li></ol><h2 id="16-详细设计的设计模式"><a href="#16-详细设计的设计模式" class="headerlink" title="16 详细设计的设计模式"></a>16 详细设计的设计模式</h2><ol><li>可修改性的含义<ul><li>（狭义）可修改性（对已有实现的修改）</li><li>可扩展性（对新的实现的扩展）</li><li>灵活性（对实现的动态配置）</li></ul></li><li>如何实现可修改性、可扩展性、灵活性<ul><li>接口与实现的分离<ul><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离</li></ul></li></ul></li><li>策略模式：首先，可以把上下文和策略分割为不同的类实现不同的职责。上下文Context类负责通过执行策略实现自己职责；而策略类Strategy只负责复杂策略的实现。<ul><li>上下文(Context): 被配置了具体策略信息；ConcreteStrategy；拥有Strategy对象的一个引用；实现了一些方法以供Strategy访问其数据。</li><li>策略(Strategy): 声明了所支持策略的接口。Context利用这些被ConcreteStrategy定义的接口。</li><li>具体策略(ConcreteStrategy): 实现了Strategy声明的接口，给出了具体的实现。</li><li>优点：<ul><li>避免多重选择语句</li><li>可以动态选择不同的策略</li></ul></li><li>缺点：<ul><li>用户必须事先知道所有的策略</li><li>会创建出较多的对象</li></ul></li><li>使用的原则：依赖倒置、减少耦合、用组合代替继承、OCP、LSP</li></ul></li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614215900889.png" alt="image-20240614215900889"></p><ol><li><p>抽象工厂</p><ul><li>抽象工厂：声明了创建抽象产品的各个接口</li><li>具体工厂：实现了对具体产品的创建</li><li>抽象产品：声明一种产品的接口</li><li>具体产品：定义了具体工厂中创建出来的具体产品，实现了抽象产品的接口</li><li>客户：使用抽象工厂和抽象产品的类。使用抽象工厂的方法来创建产品</li></ul></li></ol><p>   <img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614221227223.png" alt="image-20240614221227223"></p><ol><li><p>单件模式：内存中只存在一个对象实例，只能通过getInstance()获取唯一的静态实例对象</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614221757033.png" alt="image-20240614221757033"></p></li><li><p>迭代器模式：提供一种顺序访问一个聚合对象的各个元素，而不暴露其内部表示。</p><ul><li>迭代器：迭代器定义访问和遍历元素的接口</li><li>具体迭代器：实现迭代器接口。对该聚合遍历时跟踪当前位置</li><li>聚合：聚合定义创建相应迭代器对象的接口</li><li>具体聚合：具体聚合是想创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例</li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614222147326.png" alt="image-20240614222147326"></p></li></ol><h2 id="17-软件构造"><a href="#17-软件构造" class="headerlink" title="17 软件构造"></a>17 软件构造</h2><ol><li>构造包含的活动：详细设计、编程、测试、调试、代码评审、集成与构建、构造管理</li><li>重构：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。</li><li>测试驱动开发：要求程序员在编写一段代码之前，优先完成该段代码的测试代码。完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性</li><li>结对编程：两个程序员挨着坐在一起，共同协作进行软件构造活动</li></ol><h2 id="18-代码设计"><a href="#18-代码设计" class="headerlink" title="18 代码设计"></a>18 代码设计</h2><h3 id="18-1-易读性"><a href="#18-1-易读性" class="headerlink" title="18.1 易读性"></a>18.1 易读性</h3><ol><li>格式<ul><li>使用缩进与对齐表达逻辑结构</li><li>将相关逻辑组织在一起：变量声明、构造函数、析构函数、public方法、private方法分别放在一起</li><li>使用空行分割逻辑</li><li>语句分行</li></ul></li><li>命名<ul><li>使用有意义的名称进行命名</li><li>名称要与实际内容相符</li><li>如果存在惯例，命名时要遵守惯例</li><li>临时变量命名要符合常规：i, j计数；c字符;s 字符串</li><li>不要使用太长的名称</li><li>不要使用易混字符进行命名：如I, l, o, 0</li><li>不要仅仅使用不易区分的多个名称：sales和sale</li><li>不要使用没有任何逻辑的字母缩写进行命名</li></ul></li><li>注释<ul><li>文档注释</li><li>内部注释<ul><li>注释要有意义，不要简单重复代码的含义</li><li>重视对数据类型的注释</li><li>重视对复杂控制结构的注释</li></ul></li></ul></li></ol><h3 id="18-2-易维护性"><a href="#18-2-易维护性" class="headerlink" title="18.2 易维护性"></a>18.2 易维护性</h3><ol><li>小型任务：通过将不同的代码片段抽象为不同的任务接口，可以解决复杂代码的几种不理想但无法回避的内聚—时间内聚、过程内聚和通信内聚。</li><li>复杂决策：业务规则容易发生修改，表现为对复杂决策（布尔表达式）的修改<ul><li>使用新的布尔变量简化复杂决策</li><li>使用有意义的名称封装复杂决策</li><li>表驱动编程</li></ul></li><li>数据使用<ul><li>不要将变量应用于与命名不符的目的</li><li>不要将单个变量用于多个目的。例如total用来表示销售的总结，使用结束后客串for的计数器</li><li>限制全局变量的使用</li><li>不要使用突兀的数字与字符，要将它们定义为常量或变量后使用</li></ul></li><li>明确依赖关系<ul><li>明确注释</li></ul></li></ol><h3 id="18-3-可靠性"><a href="#18-3-可靠性" class="headerlink" title="18.3 可靠性"></a>18.3 可靠性</h3><ol><li>契约式设计<ul><li>基本思想：如果一个函数或方法，在前置条件满足的情况下开始执行，完成后能够满足后置条件，那么这个函数或方法就是正确的、可靠的。</li><li>实现方式：异常和断言</li></ul></li><li>防御式编程<ul><li>基本思想：在一个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害</li></ul></li></ol><h3 id="18-4-单元测试用例的设计"><a href="#18-4-单元测试用例的设计" class="headerlink" title="18.4 单元测试用例的设计"></a>18.4 单元测试用例的设计</h3><h3 id="18-5-代码复杂度度量"><a href="#18-5-代码复杂度度量" class="headerlink" title="18.5 代码复杂度度量"></a>18.5 代码复杂度度量</h3><p>衡量圈复杂度的基本思想是计算程序中独立路径的最大数量</p><ul><li>方法一：节点数N，边数E，圈复杂度V = E - N + 2</li><li>方法二：<ul><li>从1开始，往下通过程序</li><li>遇到下列关键字加1：if, while, loop, for</li><li>case语句中的每一种情况都加一</li></ul></li></ul><h2 id="19-软件测试"><a href="#19-软件测试" class="headerlink" title="19 软件测试"></a>19 软件测试</h2><h3 id="19-1-黑盒测试"><a href="#19-1-黑盒测试" class="headerlink" title="19.1 黑盒测试"></a>19.1 黑盒测试</h3><p>把测试对象看做一个黑盒子，完全基于输入和输出数据来判定测试对象的正确性。使用规格说明来设计输入和输出数据</p><ol><li><p>等价类划分：将所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一个子集中选取少数具有代表性的数据作为测试用例。需要同时考虑有效等价类和无效等价类</p></li><li><p>边界值分析：针对边界情况设计测试用例</p></li><li><p>决策表：决策表是为复杂逻辑判断设计测试用例的技术。决策表示由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。</p></li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614232340242.png" alt="image-20240614232340242"></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/image-20240614232334281.png" alt="image-20240614232334281"></p><ol><li>状态转移：状态转换是针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定；状态转换包含有效转换和无效转换，只有在复杂情况和可靠性要求较高的情况下才会为无效转换设计测试用例。</li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/25.png" alt="img"></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/26.png" alt="img"></p><h3 id="19-2-白盒测试"><a href="#19-2-白盒测试" class="headerlink" title="19.2 白盒测试"></a>19.2 白盒测试</h3><p>白盒测试是将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。</p><ol><li>语句覆盖：确保被测试对象的每一行程序代码都至少执行一次<ul><li>比较弱，不能覆盖所有的执行路径</li></ul></li><li>条件覆盖：确保程序中每个判断的每个结果都至少满足一次<ul><li>比语句覆盖强，但仍不保证覆盖所有执行路径</li></ul></li><li>路径覆盖：确保程序中每条独立的执行路径都至少执行一次</li></ol><h3 id="19-3-测试方法"><a href="#19-3-测试方法" class="headerlink" title="19.3 测试方法"></a>19.3 测试方法</h3><p>给出一个场景，判断应该使用哪种测试方法，如何去写（*）</p><ul><li>对给定的场景和要求的测试方法，设计测试用例</li><li>给出功能需求，则要求写功能测试用例</li><li>给出设计图，则要求写集成测试用例，Stub and Driver</li><li>给出方法的描述，则要求写单元测试用例，Mock Object</li><li>JUnit基本使用方法</li></ul><h2 id="20-软件交付"><a href="#20-软件交付" class="headerlink" title="20 软件交付"></a>20 软件交付</h2><ol><li>用户文档<ul><li>用户文档是指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。</li><li>文档内容的组织应当支持其使用模式，常见的是指导模式和参考模式两种。</li></ul></li><li>系统文档<ul><li>与用户文档注重系统使用细节不同，系统管理员文档更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。</li></ul></li></ol><h2 id="21-软件维护与演化"><a href="#21-软件维护与演化" class="headerlink" title="21 软件维护与演化"></a>21 软件维护与演化</h2><ol><li>软件维护是在交付之后修改软件系统或其部件的活动过程，以修正缺陷、提高性能或其他属性、适应变化的环境。</li><li><p>如何理解软件维护的重要性</p><ul><li>由于会出现新的需求，如不维护软件将减小甚至失去服务用户的作用。</li><li>随着软件产品的生命周期越来越长，在软件生存期内外界环境发生变化的可能性越来越大，因此，软件经常需要修改以适应外界环境的改变</li><li>软件产品或多或少的会有缺陷，当缺陷暴露出来时，必须予以及时的解决</li></ul></li><li>开发可维护软件的方法<ul><li>考虑软件的可变更性：分析需求易变性、为变更进行设计</li><li>为降低维护困难而开发：编写详细的技术文档并保持及时更新、保证代码可读性、维护需求跟踪链、维护回归测试基线</li></ul></li><li>演化式生命周期模型<ul><li>初始开发阶段完成第一个运行版本</li><li>演化阶段通过修改保持软件产品的持续增值，让软件产品能够满足用户越来越多的需要，实现更大的业务价值</li><li>服务阶段不再增加自己的价值，周期性地修复已有缺陷</li><li>逐步淘汰阶段不再维护软件，但用户可能继续使用软件</li><li>停止状态开发者不再维护，用户也不再使用</li></ul></li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/25de59344fa5ee985070bc95f44c3a9.png" alt="25de59344fa5ee985070bc95f44c3a9"></p><ol><li><p>逆向工程</p><ul><li><p>处理遗留软件时，维护人员接受的维护对象可能是一个没有任何文档也没有程序源代码的软件程序，此时，维护人员需要使用逆向工程技术</p></li><li><p>逆向工程技术是指：”分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程[Chikofsky1990]”。</p></li><li><p>逆向工程的基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/6-165487204938238.png" alt="img"></p></li></ul></li><li><p>再工程：检查和改造一个目标系统，用新的模式及其实现复原该目标系统</p><ul><li><p>[Arnold1993]认为再工程主要是下列两类活动：</p><ol><li>改进人们对软件的理解</li><li>改进软件自身，通常是提高其可维护性、可复用性和可演化性</li></ol></li><li><p>常见的具体活动有</p><ol><li>重新文档化</li><li>重组系统的结构</li><li>将系统转换为更新的编程语言</li><li>修改数据的结构组织。</li></ol><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/3d5571b7f3d6db4879167775db38ea7.png" alt="3d5571b7f3d6db4879167775db38ea7"></p></li></ul></li></ol><h2 id="22-软件开发过程模型"><a href="#22-软件开发过程模型" class="headerlink" title="22 软件开发过程模型"></a>22 软件开发过程模型</h2><h3 id="22-1-软件生命周期模型"><a href="#22-1-软件生命周期模型" class="headerlink" title="22.1 软件生命周期模型"></a>22.1 软件生命周期模型</h3><p>人们将软件从<strong>生产到报废</strong>的生命周期分割为不同阶段，每段阶段有明确的典型输入/输出、主要活动和执行人，各个阶段形成明确、连续的顺次过程，这些阶段划分就被称为软件生命周期模型。</p><h3 id="22-2-构建—修复模型"><a href="#22-2-构建—修复模型" class="headerlink" title="22.2 构建—修复模型"></a>22.2 构建—修复模型</h3><p>开发人员在开始生产软件时，依靠个人分析和理解直接构建软件的第一个版本，并提交给用户使用。第一版提交后常常会发现缺陷，开发人员就修改代码修复缺陷，把发现的缺陷都修复完成后才算是完成了有效的交付，进入维护阶段</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/f1add1c16c04b046549a38ce7f9973b.png" alt="f1add1c16c04b046549a38ce7f9973b"></p><ul><li><p>特点：</p><ul><li><p>没有对开发过程进行规范和组织，因此一旦开发过程超出个人控制能力，就会导致开发过程无法有效进行而失败。</p></li><li><p>对需求的真实性没有进行分析</p></li><li><p>没有考虑软件结构的质量，导致结构在修改中越来越糟，直至无法修改</p></li><li><p>没有考虑测试和程序的可维护性，也没有任何文档，导致难以维护     </p></li></ul></li><li>适用场景：软件规模很小，只需要几百行程序，其开发复杂度是个人能力能够胜任的；软件对质量的要求不高，即使出错也无所谓；只关注开发活动，对后期维护的要求不高，甚至不需要进行维护。</li></ul><h3 id="22-3-瀑布模型"><a href="#22-3-瀑布模型" class="headerlink" title="22.3 瀑布模型"></a>22.3 瀑布模型</h3><p>按照软件生命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付和软件维护等活动，并且规定了它们自上而下、相互邻接的次序。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/7f971da9af02a78ddef80477a29e286.png" alt="7f971da9af02a78ddef80477a29e286"></p><ul><li><p>优点：为软件开发活动定义了清晰的阶段划分(包括输入/输出、主要工作及其关注点)，这让开发者能够以关注点分离的方式更好地进行那些复杂度超越个人能力的软件项目的开发活动。</p></li><li><p>缺点：</p><ul><li>对文档的过高的期望具有局限性</li><li>对开发活动的线性顺序假设具有局限性</li><li>客户、用户的参与具有局限性：成功的项目开发需要客户、用户从始至终的参与，而不仅仅是一个阶段。</li><li>里程碑粒度具有局限性：里程碑粒度过粗，基本丧失了”早发现缺陷早修复”这一思想</li></ul></li><li><p>适用</p><ul><li>需求非常成熟、稳定，没有不确定的内容，也不会发生改变</li><li>所需的技术成熟、可靠，没有不确定的技术难点，也没有开发人员不熟悉的技术问题</li><li>复杂度适中，不至于产生太大的 文档负担和过粗的里程碑</li></ul></li></ul><h3 id="22-4-增量迭代模型"><a href="#22-4-增量迭代模型" class="headerlink" title="22.4 增量迭代模型"></a>22.4 增量迭代模型</h3><p>增量迭代模型是在项目开始时，通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，然后再将后续开发活动组织为多个迭代、并行的瀑布式开发模型。需求驱动。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/7.png" alt="img"></p><ul><li><p>优点:</p><ul><li>迭代式开发更加符合软件开发的实践情况，具有更好的适用性；</li><li>并行开发可以帮助缩短软件产品的开发时间；</li><li>渐进交付可以加强用户反馈，降低开发风险。</li></ul></li><li><p>缺点：</p><ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。</li><li>增量交付模型需要一个完备、清晰的项目前景和范围以进行并发开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围。</li></ul></li><li><p>适用：适用于大规模软件系统的开发</p></li></ul><h3 id="22-5-演化模型"><a href="#22-5-演化模型" class="headerlink" title="22.5 演化模型"></a>22.5 演化模型</h3><p>演化模型将软件开发活动组织为多个迭代、并行的瀑布式开发活动。初始开发后根据用户反馈规划后续迭代。对需求的反馈是演化模型进行迭代规划、开发活动组织和控制的主要依据，因此它也是“需求驱动”的。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/8.png" alt="img"></p><ul><li><p>优点：</p><ul><li><strong>使用了迭代式开发，具有更好的适用性</strong>，尤其是其演化式迭代安排能够适用于那些需求变更比较频繁或不确定性较多的软件系统的开发；</li><li>并行开发可以帮助<strong>缩短</strong>软件产品的开发时间；</li><li>渐进交付可以<strong>加强用户反馈</strong>，降低开发风险。</li></ul></li><li><p>缺点：</p><ul><li>无法在项目早期阶段建立项目范围，所以项目的整体计划、进度调度、尤其是商务协商事宜无法准确把握；</li><li>后续迭代的开发活动是在前导迭代基础上进行修改和扩展的，这容易让后续迭代忽略设计分析与设计工作，蜕变为构建-修复方式。</li></ul></li><li><p>适用：不稳定领域的大规模软件系统开发</p></li></ul><h3 id="22-6-原型模型"><a href="#22-6-原型模型" class="headerlink" title="22.6 原型模型"></a>22.6 原型模型</h3><p>为了解决不确定性，原型模型将需求开发活动展开为抛弃式原型开发的迭代，充分利用抛弃式原型解决新颖领域的需求不确定问题。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/9.png" alt="img"></p><ul><li><p>优点：</p><ul><li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度；</li><li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性。</li></ul></li><li><p>缺点</p><ul><li><p>原型方法能够解决风险，但是自身也能带来新的风险，例如原型开发的成本较高，可能会耗尽项目的费用和时间；</p></li><li><p>实践中，很多项目负责人不舍得抛弃”抛弃式原型”，使得质量较差的代码进入了最终产品，导致了最终产品的低质量。</p></li></ul></li><li><p>适用：适用于具有大量不确定的新颖领域进行开发活动组织。</p></li></ul><h3 id="22-7-螺旋模型"><a href="#22-7-螺旋模型" class="headerlink" title="22.7 螺旋模型"></a>22.7 螺旋模型</h3><ul><li><p>螺旋模型是风险驱动的，完全按照风险解决的方式组织软件开发活动。</p></li><li><p>将软件开发活动组织为风险解决的迭代：确定目标、解决方案和约束-&gt;评估方案，发现风险-&gt;寻找风险解决方法-&gt;落实风险解决方案-&gt;计划下一个迭代</p></li></ul><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/10.png" alt="img"></p><ul><li><p>自内向外，螺旋模型有4次风险解决迭代，分别解决了几个高风险的阶段的问题</p><ol><li><p>解决系统需求开发中的风险，尤其是产品概念设计风险，得到一个确定的产品前景和范围。</p></li><li><p>解决软件需求开发中的风险，得到清晰的软件需求</p></li><li><p>解决软件体系结构设计中的技术风险，构建高质量的核心体系结构原型。</p></li><li><p>解决详细设计和实现中的关键技术风险，建立一个可实现的高质量软件结构。</p></li></ol></li><li><p>优点：可以降低风险，减少项目因风险造成的损失</p></li><li><p>缺点：</p><ul><li>风险解决需要使用原型手段，也就会存在原型自身带来的风险，这一点与原型模型相同；</li><li>模型过于复杂，不利于管理者依据其组织软件开发活动</li></ul></li><li><p>适用：高风险的大规模软件系统开发</p></li></ul><h3 id="22-8-Rational统一过程模型"><a href="#22-8-Rational统一过程模型" class="headerlink" title="22.8 Rational统一过程模型"></a>22.8 Rational统一过程模型</h3><ul><li><p>统一过程(Rational Unified Process，RUP)总结和借鉴传统上的各种有效经验，建立最佳实践方法的集合，并提供有效的过程定制手段，允许开发者根据特定的需要定制一个有效的过程模型。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%A4%8D%E4%B9%A0/11-171842384538610.png" alt="img"></p></li><li><p>实践方法：</p><ul><li>迭代式开发，这是过去被反复证明的最佳实践方法；</li><li>管理需求，重视需求工程中除了需求开发之外的需求管理活动；</li><li>使用基于组件的体系结构，它帮助建立一个可维护、易开发、易复用的软件体系结构；</li><li>可视化建模，利用UML进行建模；</li><li>验证软件质量，尽早和持续地开展验证，以尽早发现缺陷，降低风险和成本；</li><li>控制软件变更，适应1990s以后需求变更越来越重要的事实。</li></ul></li><li><p>优点：</p><ul><li>吸收和借鉴了传统上的最佳实践方法，尤其是其核心的6个实践方法，能够保证软件开发过程的组织是基本有效和合理的。</li><li>RUP依据其定制机制的不同，可以适用于小型项目，也可以适用于大型项目的开发，适用面广泛。</li><li>RUP有一套软件工程工具的支持，这可以帮助RUP的有效实施。</li></ul></li><li><p>缺点：</p><ul><li><p>没有考虑交付之后的软件维护问题</p></li><li><p>裁剪和配置工作不是一个简单的任务，无法保证每个项目都能定制一个有效的RUP过程。</p></li></ul></li><li><p>适用：RUP是重量级过程，能够胜任大型软件团队开发大型项目时的活动组织。但RUP经过裁剪和定制，也可以变为轻量级过程，也能够胜任小团队的开发活动组织。</p></li></ul><h3 id="22-9-敏捷过程"><a href="#22-9-敏捷过程" class="headerlink" title="22.9 敏捷过程"></a>22.9 敏捷过程</h3><ul><li><p>并不是要为软件开发活动组织提供一种特定的过程模型，而是倡导一些指导性的思想和原则。</p></li><li><p>最为重要的敏捷思想是敏捷联盟宣言所声明的价值观：</p><ul><li><p>个体和互动 高于 流程和工具</p></li><li><p>工作的软件 高于 详尽的文档</p></li><li><p>客户合作 高于 合同谈判</p></li><li><p>响应变化 高于 遵循计划</p></li></ul></li><li><p>极限编程：利用简单、有效的方法解决问题</p></li></ul><h2 id="23-软件工程职业基础"><a href="#23-软件工程职业基础" class="headerlink" title="23 软件工程职业基础"></a>23 软件工程职业基础</h2><ol><li>软件工程知识体系的知识域：<ul><li>软件需求</li><li>软件设计</li><li>软件构造</li><li>软件测试</li><li>软件维护</li><li>软件配置管理</li><li>软件工程管理</li><li>软件工程过程</li><li>软件工程工具和方法</li><li>软件质量</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程与计算II </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程与计算II-往年试题</title>
      <link href="/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/"/>
      <url>/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本文资料来源于：</p><ul><li>软院学长学姐代代相传的资料</li><li>网络搜集的资料</li><li>AI辅助生成的文字</li><li>本人的胡言乱语</li><li>部分题目来源于书本或PPT，可能并非考试真题</li></ul><h2 id="耦合内聚判断"><a href="#耦合内聚判断" class="headerlink" title="耦合内聚判断"></a>耦合内聚判断</h2><h4 id="计算前50名成绩"><a href="#计算前50名成绩" class="headerlink" title="计算前50名成绩"></a>计算前50名成绩</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grade</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">averageGradefroTop50</span><span class="params">(ArrayList&lt;Student&gt;allStudent)</span>&#123;</span><br><span class="line">        ArrayList&lt;Student&gt; sortedStudent = allStudent.sort();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalGrade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            totalGrade += sortedStudent.get(i).getGrade();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">averageGrade</span> <span class="operator">=</span> totalGrade/<span class="number">50.0</span>;</span><br><span class="line">        <span class="keyword">return</span> allStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：<code>averageGradeforTop50</code>和<code>ArrayList&lt;Student&gt;</code>类之间是哪种类型的耦合</p><p>解答：内容耦合。<code>allStudent.sort()</code>直接修改了数组的排序顺序。</p><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Grade</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">averageGradefroTop50</span><span class="params">(ArrayList&lt;Student&gt;allStudent)</span>&#123;</span><br><span class="line">        ArrayList&lt;Student&gt; sortedStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(allStudent);</span><br><span class="line">        sortedStudent.sort();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalGrade</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">            totalGrade += sortedStudent.get(i).getGrade();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">averageGrade</span> <span class="operator">=</span> totalGrade/<span class="number">50.0</span>;</span><br><span class="line">        <span class="keyword">return</span> allStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证信息"><a href="#验证信息" class="headerlink" title="验证信息"></a>验证信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">validate_checkout_request(input_form i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!valid_string(i.name))&#123;</span><br><span class="line">        error_message(<span class="string">&#x27;&quot;invalid name&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!valid_month(i.date))&#123;</span><br><span class="line">        error_message(<span class="string">&#x27;invalid month&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">valid_month</span><span class="params">(date d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.month&gt;<span class="number">1</span> &amp;&amp; d.month &lt;=<span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><ul><li>印记耦合：valid_month只需要data内的一部分信息</li><li>通信内聚：valid_string和valid_string因为用到同一份数据i才被放在一起</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">validdata_checkout_request</span><span class="params">(input_form i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!valid(i.name,STRING))&#123;</span><br><span class="line">        error_message(<span class="string">&quot;invalid name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!valid(i.data,DATE))&#123;</span><br><span class="line">        error_message(<span class="string">&quot;invalid month&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">valid</span><span class="params">(string s, <span class="type">int</span> type)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> STRING:<span class="keyword">return</span> strlen(s) &lt; MAX_STRING_SIZE;</span><br><span class="line">        <span class="keyword">case</span> DATE:</span><br><span class="line">            <span class="type">date</span> <span class="variable">d</span> <span class="operator">=</span> parse_date(s);</span><br><span class="line">            <span class="keyword">return</span> d.month &gt;=<span class="number">1</span> &amp;&amp; d.month &lt;=<span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：控制耦合。type是控制信息</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311535969.png" alt="image-20240618153210993"></p><p>解答：公共耦合</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311535380.png" alt="image-20240618153253552"></p><p>解答：内容耦合。修改了另一个模块的内部数据</p><h4 id="sales"><a href="#sales" class="headerlink" title="sales"></a>sales</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311536612.png" alt="截屏2019-10-26下午8.16.54"></p><p>解答（教材P237）：类的内聚差，方法和行为不一致。Sales的属性是所有saleLineItem的Map，计算单个saleLineItem总价应该是saleLineItem的职责。</p><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSubtotal</span><span class="params">(<span class="type">int</span> commodityId)</span>&#123;</span><br><span class="line">        <span class="type">SalesLineItem</span> <span class="variable">salesLineItem</span> <span class="operator">=</span> SalesLineItemMap.get(commodityId);</span><br><span class="line">        <span class="keyword">return</span> salesLineItem.getSubtoal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesLineItem</span>&#123;</span><br><span class="line">    Commodity commodity;</span><br><span class="line">    <span class="type">int</span> nums;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getSubtotal</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commodity.getPrice * nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Commodity</span>&#123;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311536098.png" alt="截屏2019-10-26下午9.04.25"></p><p>解答：时间内聚。初始化财务报告、初始化天气、初始化计数器只是因为都是在初始化时执行而放在一起。</p><p>修改：</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311537335.png" alt="截屏2019-10-26下午9.05.00"></p><h4 id="Rous"><a href="#Rous" class="headerlink" title="Rous"></a>Rous</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311538293.png" alt="image-20240618151401619"></p><p>解答：偶然内聚</p><h4 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311538480.png" alt="image-20240618151452622"></p><p>解答：印记耦合。发送邮件只需要Employee的emailID，不需要name</p><h4 id="Employee"><a href="#Employee" class="headerlink" title="Employee"></a>Employee</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311539395.png" alt="image-20240618155256566"></p><p>解答：继承耦合，精化规格</p><h4 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311540507.png" alt="image-20240618153402280"></p><p>解答：逻辑内聚、控制耦合</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311540024.png" alt="image-20240618153441426"></p><p>解答：时间内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311540571.png" alt="image-20240618153513566"></p><p>解答：过程内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311541693.png" alt="image-20240618153545295"></p><p>解答：通信内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311541227.png" alt="image-20240618153607242"></p><p>解答：功能内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311541676.png" alt="image-20240618153629357"></p><p>解答：信息内聚</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311541351.png" alt="image-20240618153714850"></p><p>解答：内容耦合。slant应该修改为Vector3D的方法。</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311541279.png" alt="image-20240618153748790"></p><p>解答：控制耦合</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311542415.png" alt="image-20240618153822354"></p><p>解答：数据耦合</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311542101.png" alt="image-20240618153850709"></p><p>解答：公共耦合</p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h4 id="ATM机"><a href="#ATM机" class="headerlink" title="ATM机"></a>ATM机</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311542548.png" alt="截屏2019-10-26下午8.33.55"></p><h4 id="图书馆系统"><a href="#图书馆系统" class="headerlink" title="图书馆系统"></a>图书馆系统</h4><p>为下列描述建立用例模型，要求给出明确的建模过程。</p><p>现在需要开发一个简化了的大学图书馆系统，它有几种类型的借书人。包括教职工借书人，研究生借书人和本科生借书人等。借书人的基本信息包括姓名、地址和电话号码等。对于教职工借书人，还要包括诸如办公室地址和电话等信息。对于研究生借书人，还要包括研究项目和导师信息等。对于本科借书人，还要包括项目和所有学分信息等。<br>图书馆系统要跟踪借出书本信息，当一个借书人捧着一堆书去借书台办理借书手续时，借出这个事件就发生了，随着时间的过去，一个借书人可以多次从图书馆中借书，一次可以借出多本图书。如果借书人想要的书已经被借出，他可以预约，每个预约只针对一个借书人和一个标题，预约日期，优先权和完成日期等信息需要维护，当借书完成，系统会将这本书与借出联系起来。<br>借书人根据图书馆的信息来检索书名，同时检索这本书是否可以被借出，如果一本书的所有副本都被借出了，那么借书人可以根据书名预定这本书，当借书人把书拿到借书台的时候，管理员可以为这些书办理归还手续，管理员要跟踪新书到达的情况。图书的管理者有属于自己的活动，他们要分类打出关于书的标题的表格，还要在线检查所有过期未还的图书也标出来，而且图书馆系统还可以从另外一个大学的数据库中访问和下载借书人的信息。</p><p>解答：</p><p>建模过程：</p><ul><li>明确系统的目标和确定解决方向：管理图书馆的书本借阅与维护信息</li><li>寻找参与者：借书人，管理员</li><li>寻找用例：借阅图书，归还图书，预约图书，检索图书，管理图书，查看借阅情况，查看借书人信息</li><li>细化用例：</li></ul><h4 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h4><p>消费者可以使用支付宝“扫一扫”，输入金额和密码进行支付，也可以让商家扫描用户的付钱码进行支付。<br>卡包内有优惠券、红包等可以在支付时用于抵现。</p><h4 id="ATM取款"><a href="#ATM取款" class="headerlink" title="ATM取款"></a>ATM取款</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311542903.png" alt="截屏2019-10-28下午3.01.34"></p><h4 id="机场导游"><a href="#机场导游" class="headerlink" title="机场导游"></a>机场导游</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543529.png" alt="image-20240618123127832"></p><h4 id="超市销售系统"><a href="#超市销售系统" class="headerlink" title="超市销售系统"></a>超市销售系统</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543686.png" alt="c6d5f89aedd4e7cb60cd3e60a047595"></p><ul><li><p>不要将用户管理细化 为增加、修改和删除三个更小的用例,因为它们要联合起来才能体现出业务价值。</p></li><li><p>不要将同一个业务目标细化为不同用例。例如特教策略制定和赠送策略制定</p></li><li><p>不要将没有业务价值的内容作为用例</p><ul><li>登录（应该是安全性质量需求）</li><li>数据验证（应该是数据需求）</li><li>连接数据库（软件内部实现，不是需求）</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543453.png" alt="d6fed29d342579c9cf29ea0af33ba51"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543183.png" alt="96a9d2729a2a2e7196f9230f635c143"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543953.png" alt="2ba2e5c2dd6a0b2bcabb433e82af107"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311543129.png" alt="589f3805c71af7e3f7dc6dfcf1212bf"></p></li></ul><h2 id="概念类图"><a href="#概念类图" class="headerlink" title="概念类图"></a>概念类图</h2><h4 id="支付宝-1"><a href="#支付宝-1" class="headerlink" title="支付宝"></a>支付宝</h4><p>以下为活动“扫描商家的⼆二维码进⾏行行付款”的⽤用例例的概念类的候选类：<br>消费者，商家，蚂蚁积分，付款码，付款⽅方式，花呗⽀支付，余额⽀支付，余额宝⽀支付，<br>银⾏行行卡⽀支付<br>请识别概念类之间的关系（依赖、聚合、关联、组合、继承等），识别重要属性，画<br>出概念类图。</p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/image-20240617215624005.png" alt="image-20240617215624005"></p><h4 id="自驾游路线"><a href="#自驾游路线" class="headerlink" title="自驾游路线"></a>自驾游路线</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-27%E4%B8%8B%E5%8D%8810.48.41.png" alt="截屏2019-10-27下午10.48.41"></p><h4 id="创建路单"><a href="#创建路单" class="headerlink" title="创建路单"></a>创建路单</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-27%E4%B8%8B%E5%8D%889.14.16.png" alt="截屏2019-10-27下午9.14.16"></p><h4 id="购房评估系统"><a href="#购房评估系统" class="headerlink" title="购房评估系统"></a>购房评估系统</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%884.28.53.png" alt="截屏2019-10-28下午4.28.53"></p><h4 id="按钮-门"><a href="#按钮-门" class="headerlink" title="按钮-门"></a>按钮-门</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%884.47.01.png" alt="截屏2019-10-28下午4.47.01"></p><ol><li>每个Button实例控制一盏门，抽象Door，使得Door可灵活更改。二者直接依赖关系</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span>&#123;</span><br><span class="line">    Door door;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Button</span><span class="params">(Door d)</span>&#123;</span><br><span class="line">        door = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnON</span><span class="params">()</span>&#123;</span><br><span class="line">        door.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOFF</span><span class="params">()</span>&#123;</span><br><span class="line">        door.clost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorA</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorB</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorC</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string []args)</span>&#123;</span><br><span class="line">        <span class="type">Door</span> <span class="variable">doora</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoorA</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">buttona</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(doora);</span><br><span class="line">        buttona.turnON();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-12-08%E4%B8%8B%E5%8D%887.44.50.png" alt="截屏2019-12-08下午7.44.50"></p><ol><li>一个Button控制多个灯</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Door&gt; doorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Button</span><span class="params">(ArrayList&lt;List&gt; doorlist&#123;</span></span><br><span class="line"><span class="params">        doorList = doorlist;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">void</span> turnON()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(door:doorList)&#123;</span><br><span class="line">            door.open</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOFF</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(door:door:List)&#123;</span><br><span class="line">            door.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDoor</span><span class="params">(Door d)</span>&#123;</span><br><span class="line">        doorList.add(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteDoor</span><span class="params">(Door d)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorA</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorB</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorC</span> <span class="keyword">implements</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>需要控制多种设备，把包括灯在内的所有设备抽象为Device接口，Button只持有Device接口，不区分具体是什么设备</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.uitl.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Button</span>&#123;</span><br><span class="line">    LinkedList&lt;Device&gt; deviceList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Button</span><span class="params">(LinkedList devicelist)</span>&#123;</span><br><span class="line">        deviceList = deviceList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnON</span><span class="params">()</span>&#123;</span><br><span class="line">        door.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOFF</span><span class="params">()</span>&#123;</span><br><span class="line">        door.clost();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDevice</span><span class="params">(Device d)</span>&#123;</span><br><span class="line">        deviceList.add(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteDevice</span><span class="params">(Device d)</span>&#123;</span><br><span class="line">        deviceList.remove(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Device</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Door</span> <span class="keyword">implements</span> <span class="title class_">Device</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Door</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorA</span> <span class="keyword">extends</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorB</span> <span class="keyword">extends</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorC</span> <span class="keyword">extends</span> <span class="title class_">Door</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> <span class="keyword">implements</span> <span class="title class_">Device</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirConditioner</span> implenents Device&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-12-08%E4%B8%8B%E5%8D%888.13.55.png" alt=""></p><h4 id="销售系统"><a href="#销售系统" class="headerlink" title="销售系统"></a>销售系统</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311546667.png" alt="image-20240618124359428"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311546012.png" alt="image-20240618124901718"></p><h4 id="大富翁"><a href="#大富翁" class="headerlink" title="大富翁"></a>大富翁</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311547834.png" alt="image-20240618151016081"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311547411.png" alt="image-20240618151157801"></p><h4 id="ATM"><a href="#ATM" class="headerlink" title="ATM"></a>ATM</h4><p>题目（教材P114，<a href="(https://courses.ischool.berkeley.edu/i255/f01/misc/oodesign.html">来源</a>)）</p><p>University Bank will be opening in Oxford, Mississippi, in January, 2000. We plan to use a full service automated teller machine (ATM) system.</p><p>The <strong>ATM system</strong> will interact with the <strong>customer</strong> through a <strong>display screen</strong>, <strong>numeric</strong> and <strong>special input keys</strong>, a <strong>bankcard reader</strong>, a <strong>deposit</strong> slot, and a <strong>receipt printer</strong>.</p><p>Customers may make <strong>deposits</strong>, <strong>withdrawals</strong>, and <strong>balance inquires</strong> using the ATM machine, but the update to <strong>accounts</strong> will be handled through an interface to the <strong>Accounts system</strong>.</p><p>Customers will be assigned a <strong>Personal Identification Number (PIN)</strong> and <strong>clearance level</strong> by the <strong>Security system</strong>. The PIN can be verified prior to any transaction.</p><p>In the future, we would also like to support routine operations such as a <strong>change of address</strong> or <strong>phone number</strong> using the ATM</p><p>概念类：</p><ul><li>FinancialTransaction</li><li>Account</li><li>BalanceInquiry</li><li>Withdrawal</li><li>Deposit</li><li>AuthorizeSystemInteraction</li><li>BankCard</li></ul><p>参考资料：<a href="https://www.startertutorials.com/uml/uml-diagrams-atm-application.html">ATM UML Diagrams (startertutorials.com)</a></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311547556.jpg" alt="ATM-class-diagram"></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h4 id="手机应用"><a href="#手机应用" class="headerlink" title="手机应用"></a>手机应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> averageRate;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NewFeature&gt; newFeatureItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NewFeature&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescriptionForIOS</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        result.append(<span class="string">&quot;This is &quot;</span>+ <span class="built_in">this</span>.applicationName + <span class="string">&quot; for IOS platform\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;newFeatureItems.size();i++)&#123;</span><br><span class="line">            result.append(newFeatureItems.get(i).getDescription);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;Average Rate from APP Store\n&quot;</span>);</span><br><span class="line">        result.append(String.valueOf(avarageRate));</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescriptionForAndriod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        result.append(<span class="string">&quot;This is &quot;</span>+ <span class="built_in">this</span>.applicationName + <span class="string">&quot; for Andriod platform\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;newFeatureItems.size();i++)&#123;</span><br><span class="line">            result.append(newFeatureItems.get(i).getDescription);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;Average Rate from Google Play\n&quot;</span>);</span><br><span class="line">        result.append(String.valueOf(avarageRate));</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：违反了什么原则，解释并修改代码；应用某种设计模式来重构</p><p>解答：</p><ul><li>违反了<strong>OCP原则</strong>：<code>getDescriptionForIOS</code> 和 <code>getDescriptionForAndriod</code> 方法中有大量重复的代码，尤其是拼接字符串和遍历 <code>newFeatureItems</code> 的部分。如果需要修改描述生成逻辑，比如改变 <code>newFeatureItems</code> 的描述方式，必须修改这两个方法，这违反了开闭原则。</li><li>违反<strong>Do not repoat</strong>：大量重复代码</li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平台描述接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    String <span class="title function_">getPlatformName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getStoreName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IOS平台描述类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOSPlatformDescription</span> <span class="keyword">implements</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getPlatformName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IOS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getStoreName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;APP Store&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android平台描述类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidPlatformDescription</span> <span class="keyword">implements</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getPlatformName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Android&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getStoreName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Google Play&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> averageRate;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NewFeature&gt; newFeatureItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NewFeature&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">(PlatformDescription platform)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        result.append(<span class="string">&quot;This is &quot;</span> + <span class="built_in">this</span>.applicationName + <span class="string">&quot; for &quot;</span> + platform.getPlatformName() + <span class="string">&quot; platform\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (NewFeature feature : newFeatureItems) &#123;</span><br><span class="line">            result.append(feature.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;Average Rate from &quot;</span> + platform.getStoreName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        result.append(String.valueOf(averageRate));</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  String <span class="title function_">getDescriptionForIOS</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDescription(<span class="keyword">new</span> <span class="title class_">IOSPlatformDescription</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescriptionForAndriod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDescription(<span class="keyword">new</span> <span class="title class_">AndriodPlatformDescription</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平台描述接口(策略类)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    String <span class="title function_">getPlatformName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getStoreName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IOS平台描述类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOSPlatformDescription</span> <span class="keyword">implements</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getPlatformName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IOS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getStoreName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;APP Store&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android平台描述类（具体策略）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidPlatformDescription</span> <span class="keyword">implements</span> <span class="title class_">PlatformDescription</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getPlatformName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Android&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getStoreName &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Google Play&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application类（具体策略）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> averageRate;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NewFeature&gt; newFeatureItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NewFeature&gt;();</span><br><span class="line"><span class="keyword">private</span> PlatformDescription platform;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlatformDescription</span><span class="params">(PlatformDescription platform)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        result.append(<span class="string">&quot;This is &quot;</span> + <span class="built_in">this</span>.applicationName + <span class="string">&quot; for &quot;</span> + platform.getPlatformName() + <span class="string">&quot; platform\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (NewFeature feature : newFeatureItems) &#123;</span><br><span class="line">            result.append(feature.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;Average Rate from &quot;</span> + platform.getStoreName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        result.append(String.valueOf(averageRate));</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="影片出租店"><a href="#影片出租店" class="headerlink" title="影片出租店"></a>影片出租店</h4><p>Rukawa同学开发一个影片出租店用的程序，其中需要计算客户的积分，如果电影是新发布的电影并且租用的时间超过1天，则可以得到2点积分，否则是1点积分。指出是否违反了某些设计原则，并解释 <div id = '影片出租店1'></div></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    Rental rental;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNewRentPoint</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Movie</span> <span class="variable">m</span> <span class="operator">=</span> rental.getMovieRented(); </span><br><span class="line">        <span class="keyword">if</span>((m.getPriceCode == Movie.NEW_RELEASE)&amp;&amp; rental.getDaysRented()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Rental</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> daysRented;</span><br><span class="line">    <span class="keyword">private</span> Movie movieRented;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDaysRented</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> daysRented;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Movie getMovieRented&#123;</span><br><span class="line">        <span class="keyword">return</span> movieRented;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priceCode;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHILDRENS</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGUALR</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW_RELEASE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> getPriceCode&#123;</span><br><span class="line">        <span class="keyword">return</span> priceCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：违反了迪米特法则。Customer的方法调用了Movie类的方法，但Movie不是Customer的朋友。</p><p>修改：<div id = '影片出租店2'></div></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    Rental rental;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNewRentPoint</span><span class="params">()</span>&#123;</span><br><span class="line">        rental.getMovieRentPoint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Rental</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> daysRented;</span><br><span class="line">    <span class="keyword">private</span> Movie movieRented;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDaysRented</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> getMovieRentPoint&#123;</span><br><span class="line">        <span class="keyword">if</span>(movieRented.getPriceCode == Movie.NEW_RELEASE &amp;&amp; <span class="built_in">this</span>.getDaysRented())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priceCode;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHILDRENS</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGUALR</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW_RELEASE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> getPriceCode&#123;</span><br><span class="line">        <span class="keyword">return</span> priceCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的设计"><a href="#栈的设计" class="headerlink" title="栈的设计"></a>栈的设计</h4><p>数据结构栈有四个功能:压栈、弹栈、得到栈的大小、得到栈是否为空。Akagi同学使用继承如下设计了栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> <span class="keyword">extends</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object element)</span>&#123;</span><br><span class="line">        insertElementAt(element,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> firstElement();</span><br><span class="line">        removeElementAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：违反了LSP。MyStack修改了父类的规格，不能用子类替换父类并起同样的作用</p><p>修改：用组合代替继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object element)</span>&#123;</span><br><span class="line">        vector.insertElement(element, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> vector.firstElement();</span><br><span class="line">        vector.removeElement(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="雇员"><a href="#雇员" class="headerlink" title="雇员"></a>雇员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答（存疑）：违反了LSP。子类应该表达一个特殊类型，而不是一个扮演角色</p><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        person.getName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a>图书管理系统</h4><p>图书管理系统中有多个借阅者角色。本科生、研究生和教师。所有借阅者都可以借阅图书。教师借阅图书的行为和本科生,研究生略有不同时。当教师希望借阅的某种图书被借空时,系统将自动通知借阅者归还图书,本科生只可借阅普通图书，最多可同时借阅5本;研究生可以最多可同时借阅10本;老师可以借阅20本。Hyoga同学熟悉结构化编程,给出了如下设计。请根据以上借阅图书相关的功能性需求和面向对象的思想，指出Hyoga设计的问题，画出关于借阅者的设计类图，并且写出各个类和借阅相关的属性和方法的定义(不用实现)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Borrower</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_FOR_BACHELOR</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_FOR_MASTER</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_FOR_TEACHER</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowBookForBorrower</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            borrowBookForBachelor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            borrowBookForMaster();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            borrowBookForTeacher();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowBookForBachelor</span><span class="params">()</span> &#123;</span><br><span class="line">        borrowBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowBookForMaster</span><span class="params">()</span> &#123;</span><br><span class="line">        borrowBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowBookForTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">        borrowBook();</span><br><span class="line">        notifyReturnBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">borrowBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 借书逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyReturnBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通知还书逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解答：</p><ul><li>违反OCP：添加借阅者时需要修改borrowBookForBorrower的实现。</li><li>单一职责原则</li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义借书接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Borrowable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">borrowBook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学士生借书实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowerBachelor</span> <span class="keyword">implements</span> <span class="title class_">Borrowable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BOOKS</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 学士生借书逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Borrowing books for bachelor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 硕士生借书实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowerMaster</span> <span class="keyword">implements</span> <span class="title class_">Borrowable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BOOKS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 硕士生借书逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Borrowing books for master...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教师借书实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowerTeacher</span> <span class="keyword">implements</span> <span class="title class_">Borrowable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BOOKS</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">borrowBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 教师借书逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Borrowing books for teacher...&quot;</span>);</span><br><span class="line">        notifyReturnBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyReturnBook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通知还书逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Notifying return of books...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="正方形-长方形"><a href="#正方形-长方形" class="headerlink" title="正方形-长方形"></a>正方形-长方形</h4><p>正方形是否可以直接继承长方形？（教材P235）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length*width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：违反LSP。Square会修改Rectangle的接口和实现，不能替代Rectangle。</p><p>修改：组合代替继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>&#123;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line">    <span class="type">int</span> edge;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> edge)</span>&#123;</span><br><span class="line">        rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(edge,edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEdge</span><span class="params">(<span class="type">int</span> edge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rectangle.setWidth(edge);</span><br><span class="line">        <span class="built_in">this</span>.rectangle.setWidth(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rectangle.area();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%882.22.53.png" alt=""></p><p>解答：</p><ul><li>代码格式差，没有缩进</li><li>控制耦合</li><li>违反单一职责原则</li><li>违反OCP</li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义比较策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的比较策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand == rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotEqualStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand != rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargeEqualStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand &gt;= rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargeStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand &gt; rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LessEqualStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand &lt;= rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LessStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftOperand &lt; rightOperand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoneStrategy</span> <span class="keyword">implements</span> <span class="title class_">ComparisonStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> leftOperand, <span class="type">double</span> rightOperand)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="雇员2"><a href="#雇员2" class="headerlink" title="雇员2"></a>雇员2</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%883.02.26.png" alt="截屏2019-10-28下午3.02.26"></p><p>解答：</p><ul><li>违背单一职责原则。</li><li>产生问题：<ul><li><strong>代码难以维护</strong>，一个类中包含了不同职责的代码，当其中某一部分需要修改时，可能会影响到其他部分。</li><li><strong>复用性差</strong>：由于一个类承担了过多职责，无法在其他上下文中重用这些逻辑。</li></ul></li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 员工类，负责管理员工信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> employeeNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作类，负责处理与员工相关的数据库操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入员工信息到数据库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 从数据库中根据ID查找员工信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告生成类，负责生成员工报告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeReport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateReport</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成员工的报告</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Person"><a href="#Person" class="headerlink" title="Person"></a>Person</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%883.22.16%201.png" alt="截屏2019-10-28下午3.22.16 1"></p><p>解答：数据和行为不匹配</p><h4 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%884.38.35.png" alt="截屏2019-10-28下午4.38.35"></p><p>解答：没有集中数据和行为，内聚性低</p><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDistance</span><span class="params">(Point b)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDirection</span><span class="params">(Point c)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算和显示"><a href="#计算和显示" class="headerlink" title="计算和显示"></a>计算和显示</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311548758.png" alt="image-20240618154052615"></p><p>解答：违背的单一职责原则</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549461.png" alt="image-20240618154148178"></p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549210.png" alt="image-20240618154811892"></p><p>违背接口最小化原则</p><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549809.png" alt="image-20240618154944077"></p><p>解答：违背接口最小化原则</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549256.png" alt="image-20240618155010104"></p><h4 id="银行卡"><a href="#银行卡" class="headerlink" title="银行卡"></a>银行卡</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549208.png" alt="image-20240618155506917"></p><p>解答：违反了LSP，子类前置条件要求更多了</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311549807.png" alt="image-20240618155558416"></p><h4 id="乘客和导游"><a href="#乘客和导游" class="headerlink" title="乘客和导游"></a>乘客和导游</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311550454.png" alt="image-20240618160121361"></p><p>解答：违背了LSP和用组合代替继承原则。Passenger和Agent只是Person扮演的角色，不能替代父类。</p><p>修改：组合代替继承</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311550995.png" alt="image-20240618160327403"></p><h4 id="Account"><a href="#Account" class="headerlink" title="Account"></a>Account</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311550100.png" alt="image-20240618160838665"></p><p>违背了单一职责原则</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311550272.png" alt="image-20240618160859055"></p><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311550934.png" alt="image-20240618161525903"></p><p>解答：暴露了内部结构</p><p>修改：</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311551077.png" alt="image-20240618161510809"></p><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311551301.png" alt="image-20240618161623789"></p><p>解答：暴露了内部结构—使用List存储。</p><p>修改：使用迭代器模式</p><h4 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// draw</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// draw</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawShapes</span><span class="params">(List&lt;Shape&gt; shapes)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shapes <span class="keyword">instanceof</span> Square) &#123;</span><br><span class="line">      ((Square) shapes).drawSquare();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">      ((Circle) shape).drawCircle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：RTTI（运行时类型信息）违反了LSP和OCP</p><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// draw implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// draw implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drawShapes</span><span class="params">(List&lt;Shape&gt; shapes)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">    shape.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311551318.png" alt="image-20240618162448788"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311551817.png" alt="image-20240618162512163"></p><p>使用DIP修改</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311552040.png" alt="3d7fd18a7f011523610717e43e3214c"></p><h2 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h2><h4 id="影片出租店-1"><a href="#影片出租店-1" class="headerlink" title="影片出租店"></a>影片出租店</h4><p>代码参见：<a href="#影片出租店1">影片出租店</a></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%887.10.33.png" alt="截屏2019-10-26下午7.10.33"></p><p>修改后的代码：<a href="#影片出租店2">影片出租店</a></p><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%887.11.47.png" alt="截屏2019-10-26下午7.11.47"></p><h4 id="ATM-1"><a href="#ATM-1" class="headerlink" title="ATM"></a>ATM</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%888.33.43.png" alt="截屏2019-10-26下午8.33.43"></p><h4 id="收银"><a href="#收银" class="headerlink" title="收银"></a>收银</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311553126.png" alt="image-20240618125439851"></p><h4 id="买票"><a href="#买票" class="headerlink" title="买票"></a>买票</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311553053.png" alt="image-20240618125601358"></p><h4 id="销售"><a href="#销售" class="headerlink" title="销售"></a>销售</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311602774.png" alt="image-20240618145908727"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311554289.png" alt="image-20240618151238684"></p><h4 id="大富翁-1"><a href="#大富翁-1" class="headerlink" title="大富翁"></a>大富翁</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311554880.png" alt="image-20240618151032374"></p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><h4 id="销售处理"><a href="#销售处理" class="headerlink" title="销售处理"></a>销售处理</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311554116.png" alt="image-20240618125810098"></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h4 id="ATM机需求"><a href="#ATM机需求" class="headerlink" title="ATM机需求"></a>ATM机需求</h4><ul><li>业务需求：ATM系统上线两个月，银行存取款业务效率提升20%</li><li>用户需求：允许用户存款；取款</li><li>系统需求：在用户点击退卡时，系统应将银行卡从卡槽中推出</li><li>功能需求：系统应提供存款服务</li><li>性能需求：所用用户操作在3秒内得到响应</li><li>质量需求：在发生网络故障时，系统不能故障</li><li>对外接口：系统与数据库系统的接口</li><li>约束：用java开发</li><li>数据需求：系统要存储一年的操作记录</li></ul><h4 id="判断需求"><a href="#判断需求" class="headerlink" title="判断需求"></a>判断需求</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-28%E4%B8%8B%E5%8D%882.55.37.png" alt="截屏2019-10-28下午2.55.37"></p><ol><li>业务需求</li><li>数据需求</li><li>用户需求</li><li>约束</li><li>系统级需求</li></ol><ul><li>当用户输入的补货数中含有非数字字符的时候，系统必须提示输入错误<ul><li>功能需求。描述了用户希望系统能够执行的活动</li></ul></li><li>用户输入的收入金额中不能含有非数字字符<ul><li>对外接口：描述了系统与用户交互时对用户的输入做出的限制</li></ul></li></ul><h4 id="需求描述正确性"><a href="#需求描述正确性" class="headerlink" title="需求描述正确性"></a>需求描述正确性</h4><ul><li>在支付过程完成后，相关信息应追加到日志文件中。<ul><li>该需求应该重新编写；它是模棱两可或不一致的。没有具体说明哪些相关信息应该记录</li></ul></li><li>系统的构建应该使将来易于添加新功能。<ul><li>没有说明“易于”的度量标准</li></ul></li><li>汽油购买的价格计算为所购汽油类型的每加仑价格乘以购买的加仑数（使用两位小数表示加仑的小数部分）。<ul><li>没毛病？（但这个应该是问题域信息）</li></ul></li><li>系统应每天24小时，每周7天可用。<ul><li>不现实</li></ul></li><li>用户查询界面应该友好<ul><li>不可验证，修改为：用户完成任何一个查询任务时鼠标点击数都不超过5次</li></ul></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%887.52.27.png" alt="截屏2019-10-26下午7.52.27"></p><h4 id="有理数"><a href="#有理数" class="headerlink" title="有理数"></a>有理数</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%888.37.53.png" alt="截屏2019-10-26下午8.37.53"></p><h4 id="白盒黑盒"><a href="#白盒黑盒" class="headerlink" title="白盒黑盒"></a>白盒黑盒</h4><p>白盒优点：覆盖率高；发现的缺陷较多</p><p>白盒缺点：测试开销大；不能检验需求规格</p><p>黑盒优点：测试效率高；可以检验需求规格</p><p>黑盒缺点：覆盖率低：发现的缺陷少</p><h2 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h2><h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-26%E4%B8%8B%E5%8D%887.57.09.png" alt="截屏2019-10-26下午7.57.09"></p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>分析一款常用的浏览器。请支持至少3条该软件在人机交互方面的有些优点，分析它们体现了哪些人机交互的原则?</p><p>解答：（ChatGPT辅助生成）</p><ul><li><strong>简洁设计</strong>：Chrome 的界面布局和图标设计非常简洁，没有冗余的元素。这样做减少了用户在使用过程中受到的干扰，使用户可以快速找到所需功能。</li><li><strong>一致性设计</strong>：无论是标签页的位置、设置选项的位置，还是图标的设计，Chrome 都保持了一致性，避免用户在不同平台上使用时感到困惑。这确保了用户的精神模型的一致性，减少了学习成本。</li><li><strong>低出错率设计</strong>：Chrome 在设计上通过灰色屏蔽不适用的菜单功能、禁止数值输入域出现字母字符等措施，减少了用户犯错的可能性。另外，它还通过输入提示和建议来帮助用户正确操作，进一步降低了出错率。</li><li><strong>易记性设计</strong>：Chrome 的设计减少了用户的短期记忆负担，通过设置有意义的默认值和使用直观的快捷方式，用户不需要记住大量的信息。逐层递进的方式展示信息，使用户可以一步步找到所需功能，而不必一次性记住所有内容。</li></ul><h4 id="eZip"><a href="#eZip" class="headerlink" title="eZip"></a>eZip</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311555882.png" alt="image-20240618141712199"></p><p>暴露了内部结构</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="个人所得税系统"><a href="#个人所得税系统" class="headerlink" title="个人所得税系统"></a>个人所得税系统</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    个人所得说系统</span></span><br><span class="line"><span class="comment">    用决策表来优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    题目：</span></span><br><span class="line"><span class="comment">        小于 10000 tax is 10%</span></span><br><span class="line"><span class="comment">        大于 10000 小于 20000 的部分 12%</span></span><br><span class="line"><span class="comment">        大于 20000 小于 30000 的部分 15%</span></span><br><span class="line"><span class="comment">        大于 30000 小于 40000 的部分 18%</span></span><br><span class="line"><span class="comment">        大于 40000 的部分 20%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateTax</span><span class="params">(<span class="type">int</span> taxable_income)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(taxable_income == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//goto Exit;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(taxable_income &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">            tax = tax + <span class="number">1000</span>;<span class="comment">//10000以下的那部分税</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tax = tax + taxable_income * <span class="number">0.1</span>;</span><br><span class="line">            <span class="comment">//goto Exit;</span></span><br><span class="line">            <span class="keyword">return</span> tax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(taxable_income &gt; <span class="number">20000</span>)&#123;</span><br><span class="line">            tax = tax + <span class="number">1200</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//小于20000</span></span><br><span class="line">            tax += (taxable_income-<span class="number">10000</span>)*<span class="number">0.12</span>;</span><br><span class="line">            <span class="keyword">return</span> tax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(taxable_income &gt; <span class="number">30000</span>)&#123;</span><br><span class="line">            tax = tax + <span class="number">1500</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//小于 30000</span></span><br><span class="line">            tax += (taxable_income-<span class="number">20000</span>)*<span class="number">0.15</span>;</span><br><span class="line">            <span class="keyword">return</span> tax;</span><br><span class="line">        &#125;<span class="keyword">if</span>(taxable_income &gt; <span class="number">40000</span>)&#123;</span><br><span class="line">            tax = tax + <span class="number">1800</span>;</span><br><span class="line">            tax += (taxable_income-<span class="number">40000</span>)*<span class="number">0.2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tax += (taxable_income-<span class="number">30000</span>)*<span class="number">0.18</span>;</span><br><span class="line">            <span class="keyword">return</span> tax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int[] percent = &#123;0.1, 0.12,0.15,0.18,0.20&#125;;</span><br><span class="line">int[] bracket = &#123;0,10000,20000,30000,40000&#125;;</span><br><span class="line">int[] base = &#123;0,1000,2200,3700,5500&#125;</span><br><span class="line"></span><br><span class="line">public int calculateTax(int taxable_income)&#123;</span><br><span class="line">    int level = 0;</span><br><span class="line">    for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">        if(taxable_income &gt;= bracket[i])&#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    level--;</span><br><span class="line">    int tax = base[level] +(taxable_income - bracket[level])*percent[level];</span><br><span class="line">    return tax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    参考表驱动编程  P307</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int[] prePoint = &#123;1000,2000,5000&#125;;</span><br><span class="line">int[] postPoint = &#123;1000,2000,5000&#125;;</span><br><span class="line">int[] levelArray = &#123;1,2,3&#125;;</span><br><span class="line">public int calculateLavel(int prePoint ,int postPoint)&#123;</span><br><span class="line">    for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">        if(prePoint &lt; prePoint[i] &amp;&amp; postPoint &gt;= postPoint[i])&#123;</span><br><span class="line">            return levelArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求每月天数"><a href="#求每月天数" class="headerlink" title="求每月天数"></a>求每月天数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] days = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDaysofMonth</span><span class="params">(<span class="type">int</span> month)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> days[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="员工支付方式"><a href="#员工支付方式" class="headerlink" title="员工支付方式"></a>员工支付方式</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311556597.png" alt="image-20240618163053823"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311556098.png" alt="image-20240618163113059"></p><p>用策略模式修改</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311556466.png" alt="image-20240618163419236"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311556591.png" alt="image-20240618163426335"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311556472.png" alt="image-20240618163431487"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311557049.png" alt="image-20240618163440176-17186996887547"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311557577.png" alt="image-20240618163500403"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311557581.png" alt="image-20240618163510834"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311557032.png" alt="image-20240618163731870"></p><h4 id="红绿灯"><a href="#红绿灯" class="headerlink" title="红绿灯"></a>红绿灯</h4><p>The “dumb” policy: change the green route every 5 seconds<br>Midnight policy: change to yellow always<br>Rush hour policy: double the “green time” in the busy route</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311557201.png" alt="image-20240618163926583"></p><h2 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h2><h4 id="Department"><a href="#Department" class="headerlink" title="Department"></a>Department</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/%E6%88%AA%E5%B1%8F2019-10-27%E4%B8%8B%E5%8D%889.37.06.png" alt="截屏2019-10-27下午9.37.06"></p><ul><li>易读性差，格式不佳，没有缩进</li><li>违反OCP</li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Employee</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalariedEmployee</span> <span class="keyword">implements</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HourlyEmployee</span> <span class="keyword">implements</span> <span class="title class_">Employee</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommissionedEmployee</span> <span class="keyword">implements</span> <span class="title class_">Employee</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt;emplyeeList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Emplyee <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">        employee.setDepartment(<span class="built_in">this</span>);</span><br><span class="line">        employeeList.add(employee);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Deposit"><a href="#Deposit" class="headerlink" title="Deposit"></a>Deposit</h4><p>下面是银行金融系统中账户类的取款方法 deposit 实现。它在可靠性上存在哪些问题？请应用契约式编程来改善或者防御性编程方法改写方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Double balance; <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> Double dailyBalance; <span class="comment">// 当日可用额度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * ATM 机取款方法 </span></span><br><span class="line"><span class="comment">    * 基本功能包括 100 元的整倍数人民币</span></span><br><span class="line"><span class="comment">    * 一次取款金额不超过 3000 元</span></span><br><span class="line"><span class="comment">    * 一天取款总金额不超过 20000 元</span></span><br><span class="line"><span class="comment">    * 账户余额不足，或当日额度不足不能取款 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Double num)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exportCash(num);</span><br><span class="line">            balance -= num;</span><br><span class="line">            dailyBalance -= num;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExportCashException e) &#123;</span><br><span class="line">            ExportCashExceptionHandler(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ATM 机控制的钞口出钞现金纸币</span></span><br><span class="line">    <span class="comment">// 包括 100 元的整倍数人民币</span></span><br><span class="line">    <span class="comment">// 如果失败抛出 ExportCashException 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportCash</span><span class="params">(Double num)</span> <span class="keyword">throws</span> ExportCashException &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解答：</p><ul><li>取款前未验证</li></ul><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Double balance; <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> Double dailyBalance; <span class="comment">// 当日可用额度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Double num)</span> &#123;</span><br><span class="line">        <span class="comment">// 前置条件</span></span><br><span class="line">        <span class="keyword">assert</span> num % <span class="number">100</span> == <span class="number">0</span> : <span class="string">&quot;取款金额必须是100的整倍数&quot;</span>;</span><br><span class="line">        <span class="keyword">assert</span> num &lt;= <span class="number">3000</span> : <span class="string">&quot;一次取款金额不超过3000元&quot;</span>;</span><br><span class="line">        <span class="keyword">assert</span> dailyBalance &gt;= num : <span class="string">&quot;当日可用额度不足&quot;</span>;</span><br><span class="line">        <span class="keyword">assert</span> balance &gt;= num : <span class="string">&quot;账户余额不足&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exportCash(num);</span><br><span class="line">                balance -= num;</span><br><span class="line">                dailyBalance -= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后置条件</span></span><br><span class="line">            <span class="keyword">assert</span> balance &gt;= <span class="number">0</span> : <span class="string">&quot;账户余额不能为负&quot;</span>;</span><br><span class="line">            <span class="keyword">assert</span> dailyBalance &gt;= <span class="number">0</span> : <span class="string">&quot;当日可用额度不能为负&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExportCashException e) &#123;</span><br><span class="line">            ExportCashExceptionHandler(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ATM 机控制的钞口出钞现金纸币</span></span><br><span class="line">    <span class="comment">// 包括 100 元的整倍数人民币</span></span><br><span class="line">    <span class="comment">// 如果失败抛出 ExportCashException 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportCash</span><span class="params">(Double num)</span> <span class="keyword">throws</span> ExportCashException &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311558111.png" alt="image-20240618173822152"></p><p>坏味道：太多的方法参数</p><p>修改：</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311558417.png" alt="image-20240618173726045"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311558463.png" alt="image-20240618173814367"></p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p><img src="https://sprooc.github.io/2024/06/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II-%E5%BE%80%E5%B9%B4%E8%AF%95%E9%A2%98/image-20191027140257021.jpg" alt="image-20191027140257021"></p><h4 id="超市系统MVC"><a href="#超市系统MVC" class="headerlink" title="超市系统MVC"></a>超市系统MVC</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311559505.png" alt="image-20240618133458481"></p><h4 id="KWIC"><a href="#KWIC" class="headerlink" title="KWIC"></a>KWIC</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311559627.png" alt="image-20240618133917053"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311559731.png" alt="image-20240618133924122"></p><h4 id="超市销售系统-1"><a href="#超市销售系统-1" class="headerlink" title="超市销售系统"></a>超市销售系统</h4><ul><li>逻辑包图</li></ul><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600206.png" alt="image-20240618134533096"></p><ul><li><p>物理包图</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600013.png" alt="image-20240618135448954"></p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600454.png" alt="image-20240618135459421"></p></li><li><p>进程图</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600804.png" alt="image-20240618135527737"></p></li><li><p>物理部署图</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600561.png" alt="image-20240618135543653"></p></li></ul><h4 id="审批"><a href="#审批" class="headerlink" title="审批"></a>审批</h4><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600002.png" alt="image-20240618135947771"></p><ul><li><p>写出接口</p><p><img src="https://sprooc-pic.oss-cn-hangzhou.aliyuncs.com/202407311600165.png" alt="image-20240618140010071"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑层接口</span></span><br><span class="line">ReceiptVO[ ] firstStepShowList(String UserID);<span class="comment">//UserID指的是审核⼈是谁</span></span><br><span class="line">ReceiptDetailVO <span class="title function_">firstStepShowDetail</span><span class="params">(String UserID, String receiptID)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">firstExamine</span><span class="params">(ExamineVo[ ] list)</span>;<span class="comment">//ExamineVo的内容：&#123;receiptID result&#125;</span></span><br><span class="line">ReceiptVO[ ] SecondStepShowList(String UserID);<span class="comment">//如果只有⼀个总经理，可能这个参数就不需要。</span></span><br><span class="line">ReceiptDetailVO <span class="title function_">SecondStepShowDetail</span><span class="params">(String UserID, String receiptID)</span></span><br><span class="line">ReceiptDetailVO <span class="title function_">EditDetail</span><span class="params">(String UserID, String receiptID)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">SecondExamine</span><span class="params">(ExamineVo[ ])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据层接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExamineLogicalService</span> &#123;</span><br><span class="line">  Pair&lt;Bollean, Bill&gt; <span class="title function_">examine</span><span class="params">(Bill bill)</span>;</span><br><span class="line">  List&lt;Bill&gt; <span class="title function_">showTodoBills</span><span class="params">(SecurityLevel securityLevel)</span>;</span><br><span class="line">  BillDetail <span class="title function_">showBillDetail</span><span class="params">(Bill bill)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">editBill</span><span class="params">(Bill bill, Inf inf)</span>;</span><br><span class="line">  Pair&lt;Bollean, List&lt;Bill&gt;&gt; <span class="title function_">tagBillsAndExamine</span><span class="params">(List&lt;Bill&gt; bills)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExamineDataService</span> &#123;</span><br><span class="line">  Exception <span class="title function_">setPassed</span><span class="params">(Bill bill, Bollean passed)</span>;</span><br><span class="line">  Exception <span class="title function_">setInf</span><span class="params">(Bill bill, Inf inf)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BillDataService</span>&#123;</span><br><span class="line">  List&lt;Bill&gt; <span class="title function_">getTodoBills</span><span class="params">(SecurityLevel securityLevel)</span>;</span><br><span class="line">  BillDetail <span class="title function_">getBillDetail</span><span class="params">(Bill bill)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h5 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h5><h5 id="软件演化生命周期模型"><a href="#软件演化生命周期模型" class="headerlink" title="软件演化生命周期模型"></a>软件演化生命周期模型</h5><h5 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h5><h5 id="软件验证与确认"><a href="#软件验证与确认" class="headerlink" title="软件验证与确认"></a>软件验证与确认</h5><h5 id="增量开发模型和迭代开发模型"><a href="#增量开发模型和迭代开发模型" class="headerlink" title="增量开发模型和迭代开发模型"></a>增量开发模型和迭代开发模型</h5><h5 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h5><h5 id="逆向工程与正向工程的区别，以及其关注点"><a href="#逆向工程与正向工程的区别，以及其关注点" class="headerlink" title="逆向工程与正向工程的区别，以及其关注点"></a>逆向工程与正向工程的区别，以及其关注点</h5><ul><li>软件开发阶段（正向工程）会书写清晰的文档，留下可读性较好的程序源代码</li><li>逆向工程可能没有文档，甚至没有源代码；基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求和设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解</li><li>正向工程：模型转换为代码</li><li>逆向工程：代码转换为模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与计算II </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内核独立地址空间</title>
      <link href="/2024/05/11/%E5%86%85%E6%A0%B8%E7%8B%AC%E7%AB%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/05/11/%E5%86%85%E6%A0%B8%E7%8B%AC%E7%AB%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>内核是否享有独立内核空间，取决于操作系设计，且各有优势。</p><p>内核享有独立内核空间：例如 rCore。</p><ul><li><p>优点：</p><ul><li>用户和内核都能使用完整的地址空间，在地址空间比较局限的情况下作用较大，例如只有4G地址空间的32位机器。但在64位机器上完全没有优势可言。</li><li>内核可以更加独立和安全地运行，不受用户空间的影响。</li></ul></li><li><p>缺点：</p><ul><li><p>由用户态陷入内核态需要切换页表，导致TLB失效。</p></li><li><p>在内核态处理用户态传入的指针时需要进行地址转换，即使用页表将进程虚拟地址转化为物理地址。</p></li></ul></li></ul><p>综上所述，在现代计算机上，让内核拥有独立地址空间并不占优势，故大多数操作系统都采用这样的实现：将内核空间映射到每一个进程空间的固定区域。如下图中，32位Linux内核地址空间划分0~3G为用户空间，3~4G为内核空间。这样虽然内核可用地址空间较小，但其优势更大。而且现在计算机大多是64位，地址空间足够庞大，即使不能使用完整地址空间也完全够用了。</p> <div align="center"><img src="https://sprooc.github.io/2024/05/11/内核独立地址空间/地址空间.jpg" alt="1bf804873e92d9966e394d43dadfb6e" style="zoom:55%;" /> </div>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86-64使用int 80h的问题</title>
      <link href="/2024/04/07/x86-64%E4%BD%BF%E7%94%A8int-80h%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/07/x86-64%E4%BD%BF%E7%94%A8int-80h%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>尝试在 x86-64 机器上写一个打印字符串的函数 print(char* str, size_t n)，使用 int 80h 进行系统调用输出字符串，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print:</span><br><span class="line">  mov eax, 4</span><br><span class="line">  mov ebx, 1</span><br><span class="line">  mov rcx, rdi</span><br><span class="line">  mov rdx, rsi</span><br><span class="line">  int 0x80</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>发现实际运行有问题，如果字符串在栈上，不能打印出字符串。而定义在 .data 区的字符串却可以正常输出。经过分析发现原因如下：<br>int 80h 是 x86 的 32 位系统调用指令，使用 eax, edi, esi, ecx 等寄存器传递参数。如果在 64 位机器中使用 int 80h 进行输出字符串时，将字符串地址放在 rcx 寄存器中。然而，int 80h 处理系统调用时，会以为这是一个 32 地址，因此只读取 32 位的 ecx 地址，这很有可能是一个错误地址。如果字符串在.data 区，其地址一般是 0x4xxx，能用 32 位寄存器保存，因此可以正常使用 int 80h 输出。然而，若字符串在栈区，其地址较高，一般是 0x7ffxxxxxxxx，无法用 32 位寄存器保存，int 80h 只会能读取到 ecx 中 32 位的地址，这个地址是错误的，因此无法输出。<br>解决方案是使用 64 位的系统调用 syscall 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print:</span><br><span class="line">  mov rdx, rsi</span><br><span class="line">  mov rsi, rdi  </span><br><span class="line">  mov rdi, 1</span><br><span class="line">  mov rax, 1</span><br><span class="line">  syscall</span><br><span class="line">  ret  </span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://stackoverflow.com/questions/22503944/using-interrupt-0x80-on-64-bit-linux">https://stackoverflow.com/questions/22503944/using-interrupt-0x80-on-64-bit-linux</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组及线段树总结</title>
      <link href="/2024/03/09/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/09/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8F%8A%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组及线段树总结"><a href="#树状数组及线段树总结" class="headerlink" title="树状数组及线段树总结"></a>树状数组及线段树总结</h1><ol><li><p>区间更新，单点查询</p><ul><li><p>例题：<a href="https://www.acwing.com/problem/content/248/">242. 一个简单的整数问题 - AcWing题库</a></p></li><li><p>树状数组：将原数组转化为差分数组，用树状数组维护差分数组，每次区间更新时只需要修改差分数组的首尾，单点查询时，求差分数组的前缀和就是原数组的单点值。更新和查询复杂度均为O(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> loc, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; loc &lt;= n; loc += <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    tree[loc] += val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; loc; loc -= <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    sum += tree[loc];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> l, r, t;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span> tree);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">add</span>(i, t);</span><br><span class="line">    <span class="built_in">add</span>(i + <span class="number">1</span>, -t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; t;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(t) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;</span><br><span class="line">      <span class="built_in">add</span>(l, t);</span><br><span class="line">      <span class="built_in">add</span>(r + <span class="number">1</span>, -t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线段树：区间修改操作需要使用惰性标记，否则复杂度为O(n)。查询时逐层累加。</p></li></ul></li><li><p>区间修改，区间查询</p><ul><li><p>例题：<a href="https://www.acwing.com/problem/content/244/">243. 一个简单的整数问题2 - AcWing题库</a></p></li><li><p>树状数组：只能用于求区间和。需要一些数学推导：</p><p><img src="https://sprooc.github.io//2024/03/09/树状数组及线段树总结/46cbdfc2b56b1fe4321aa713e86e03e.png" alt="46cbdfc2b56b1fe4321aa713e86e03e" style="zoom: 67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tree1[N], tree2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> loc, <span class="type">int</span> val, <span class="type">int</span> tree[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; loc &lt;= n; loc += <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    tree[loc] += val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> loc, <span class="type">int</span> tree[])</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; loc; loc -= <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    sum += tree[loc];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">presum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x + <span class="number">1</span>) * <span class="built_in">query</span>(x, tree1) - <span class="built_in">query</span>(x, tree2); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l, r, t;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(tree1, <span class="number">0</span>, <span class="keyword">sizeof</span> tree1);</span><br><span class="line">  <span class="built_in">memset</span>(tree2, <span class="number">0</span>, <span class="keyword">sizeof</span> tree2);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">add</span>(i, t, tree1);</span><br><span class="line">    <span class="built_in">add</span>(i + <span class="number">1</span>, -t, tree1);</span><br><span class="line">    <span class="built_in">add</span>(i, i * t, tree2);</span><br><span class="line">    <span class="built_in">add</span>(i + <span class="number">1</span>, -(i + <span class="number">1</span>) * t, tree2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">presum</span>(r) - <span class="built_in">presum</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;</span><br><span class="line">      <span class="built_in">add</span>(l, t, tree1);</span><br><span class="line">      <span class="built_in">add</span>(r + <span class="number">1</span>, -t, tree1);</span><br><span class="line">      <span class="built_in">add</span>(l, l * t, tree2);</span><br><span class="line">      <span class="built_in">add</span>(r + <span class="number">1</span>, -(r + <span class="number">1</span>) * t, tree2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线段树：</p><ul><li><p>使用惰性标记。</p></li><li><p>可以通过转化为差分数组，对原数组进行区间修改转化成对差分数组进行单点修改。</p></li><li><p>例题：<a href="https://www.acwing.com/problem/content/247/">246. 区间最大公约数 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll bit[N];</span><br><span class="line">ll bs[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  ll data;</span><br><span class="line">&#125; ts[N * <span class="number">4</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; <span class="number">0</span>) y = -y;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  ts[p].l = l, ts[p].r = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    ts[p].data = bs[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);</span><br><span class="line">  <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  ts[p].data = <span class="built_in">gcd</span>(ts[p * <span class="number">2</span>].data, ts[p * <span class="number">2</span> + <span class="number">1</span>].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_bit</span><span class="params">(<span class="type">int</span> loc, ll val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; loc &lt;= n; loc += <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    bit[loc] += val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query_bit</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; loc; loc -= <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">    sum += bit[loc];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> loc, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ts[p].l == ts[p].r) &#123;</span><br><span class="line">    ts[p].data += val;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (loc &lt;= mid) &#123;</span><br><span class="line">    <span class="built_in">update</span>(p * <span class="number">2</span>, loc, val);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">update</span>(p * <span class="number">2</span> + <span class="number">1</span>, loc, val);</span><br><span class="line">  &#125;</span><br><span class="line">  ts[p].data = <span class="built_in">gcd</span>(ts[p * <span class="number">2</span>].data, ts[p * <span class="number">2</span> + <span class="number">1</span>].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= ts[p].l &amp;&amp; r &gt;= ts[p].r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(ts[p].data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ll ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">    ret = <span class="built_in">gcd</span>(<span class="built_in">query</span>(p * <span class="number">2</span>, l, r), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">    ret = <span class="built_in">gcd</span>(<span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span> bit);</span><br><span class="line">  ll pre = <span class="number">0</span>, t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    bs[i] = t - pre;</span><br><span class="line">    pre = t;</span><br><span class="line">    <span class="built_in">add_bit</span>(i, bs[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  ll l, r, d;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">      <span class="built_in">add_bit</span>(l, d);</span><br><span class="line">      <span class="built_in">add_bit</span>(r + <span class="number">1</span>, -d);</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, l, d);</span><br><span class="line">      <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= n) <span class="built_in">update</span>(<span class="number">1</span>, r + <span class="number">1</span>, -d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">gcd</span>(<span class="built_in">query_bit</span>(l), <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol><li><p>单点修改，区间查询</p><ul><li><p>树状数组：树状数组最原始的应用。</p></li><li><p>线段树：</p><ul><li><p>例题：<a href="https://www.acwing.com/problem/content/246/">245. 你能回答这些问题吗 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x8000000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">int</span> maxsum, lsum, rsum, sum;</span><br><span class="line">&#125; ts[N * <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> As[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  ts[p].l = l;</span><br><span class="line">  ts[p].r = r;</span><br><span class="line">  <span class="keyword">if</span> (ts[p].l == ts[p].r) &#123;</span><br><span class="line">    ts[p].sum = ts[p].maxsum = ts[p].lsum = ts[p].rsum = As[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);</span><br><span class="line">  <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">  ts[p].sum = ts[p * <span class="number">2</span>].sum + ts[p * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">  ts[p].lsum = <span class="built_in">max</span>(ts[p * <span class="number">2</span>].lsum, ts[p * <span class="number">2</span>].sum + ts[p * <span class="number">2</span> + <span class="number">1</span>].lsum);</span><br><span class="line">  ts[p].rsum = <span class="built_in">max</span>(ts[p * <span class="number">2</span> + <span class="number">1</span>].rsum, ts[p * <span class="number">2</span> + <span class="number">1</span>].sum + ts[p * <span class="number">2</span>].rsum);</span><br><span class="line">  ts[p].maxsum =</span><br><span class="line">      <span class="built_in">max</span>(ts[p * <span class="number">2</span>].maxsum,</span><br><span class="line">          <span class="built_in">max</span>(ts[p * <span class="number">2</span> + <span class="number">1</span>].maxsum, ts[p * <span class="number">2</span>].rsum + ts[p * <span class="number">2</span> + <span class="number">1</span>].lsum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lquery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= ts[p].l &amp;&amp; r &gt;= ts[p].r) &#123;</span><br><span class="line">    <span class="keyword">return</span> ts[p].lsum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ll ret = <span class="built_in">lquery</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, ts[p * <span class="number">2</span>].sum + <span class="built_in">lquery</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">rquery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= ts[p].l &amp;&amp; r &gt;= ts[p].r) &#123;</span><br><span class="line">    <span class="keyword">return</span> ts[p].rsum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ll ret = <span class="built_in">rquery</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, ts[p * <span class="number">2</span> + <span class="number">1</span>].sum + <span class="built_in">rquery</span>(p * <span class="number">2</span>, l, r));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= ts[p].l &amp;&amp; r &gt;= ts[p].r) &#123;</span><br><span class="line">    <span class="keyword">return</span> ts[p].maxsum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ll ret = INF;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) &#123;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(p * <span class="number">2</span>, l, r));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">    ret = <span class="built_in">max</span>(ret, <span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid &amp;&amp; r &gt; mid) &#123;</span><br><span class="line">    ret = <span class="built_in">max</span>(<span class="built_in">rquery</span>(p * <span class="number">2</span>, l, r) + <span class="built_in">lquery</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ts[p].l == ts[p].r) &#123;</span><br><span class="line">    ts[p].sum = ts[p].maxsum = ts[p].lsum = ts[p].rsum = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = (ts[p].l + ts[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">    <span class="built_in">change</span>(p * <span class="number">2</span>, x, y);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  ts[p].sum = ts[p * <span class="number">2</span>].sum + ts[p * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">  ts[p].lsum = <span class="built_in">max</span>(ts[p * <span class="number">2</span>].lsum, ts[p * <span class="number">2</span>].sum + ts[p * <span class="number">2</span> + <span class="number">1</span>].lsum);</span><br><span class="line">  ts[p].rsum = <span class="built_in">max</span>(ts[p * <span class="number">2</span> + <span class="number">1</span>].rsum, ts[p * <span class="number">2</span> + <span class="number">1</span>].sum + ts[p * <span class="number">2</span>].rsum);</span><br><span class="line">  ts[p].maxsum =</span><br><span class="line">      <span class="built_in">max</span>(ts[p * <span class="number">2</span>].maxsum,</span><br><span class="line">          <span class="built_in">max</span>(ts[p * <span class="number">2</span> + <span class="number">1</span>].maxsum, ts[p * <span class="number">2</span>].rsum + ts[p * <span class="number">2</span> + <span class="number">1</span>].lsum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; As[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="type">int</span> k, x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x, y) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">change</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构， 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240204周记</title>
      <link href="/2024/01/30/20240204%E5%91%A8%E8%AE%B0/"/>
      <url>/2024/01/30/20240204%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote><p>给定一个长度为 N 的字符串 S，求它的最长回文子串。</p></blockquote><p>Manacher 算法，时间复杂度 O(n)。</p><p><a href="https://zhuanlan.zhihu.com/p/137172524">一文弄懂Manacher算法 - 知乎 (zhihu.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">new_str</span><span class="params">(string&amp; ostr)</span> </span>&#123;</span><br><span class="line">  string nstr = <span class="string">&quot;^#&quot;</span>;</span><br><span class="line">  <span class="type">int</span> n = ostr.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    nstr.<span class="built_in">push_back</span>(ostr[i]);</span><br><span class="line">    nstr.<span class="built_in">push_back</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  nstr.<span class="built_in">push_back</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> nstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;END&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">    str = <span class="built_in">new_str</span>(str);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= c + r) &#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i + r + <span class="number">1</span>] == str[i - r - <span class="number">1</span>]) r++;</span><br><span class="line">        c = i;</span><br><span class="line">        p[i] = r;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mr = <span class="number">2</span> * c - i;</span><br><span class="line">        <span class="keyword">if</span> (i + p[mr] &lt; c + r) &#123;</span><br><span class="line">          p[i] = p[mr];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">int</span> tr = c + r - i;</span><br><span class="line">          <span class="keyword">while</span> (str[i + tr + <span class="number">1</span>] == str[i - tr - <span class="number">1</span>]) tr++;</span><br><span class="line">          p[i] = tr;</span><br><span class="line">          c = i;</span><br><span class="line">          r = tr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *<span class="built_in">max_element</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    id++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>在线性时间内判定字符串 s2 是否为字符串 s1 的子串，并求出字符串 s2 在 s1 中各次出现的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1, s2;</span><br><span class="line">  cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">  <span class="type">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">  s1 = <span class="string">&quot; &quot;</span> + s1, s2 = <span class="string">&quot; &quot;</span> + s2;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n2 + <span class="number">1</span>)</span></span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n2; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[i] != s2[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (s2[i] == s2[j + <span class="number">1</span>]) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; (j == n2 || s1[i] != s2[j + <span class="number">1</span>])) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (s1[i] == s2[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span> (j == n2) cout &lt;&lt; i - n2 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; i++) &#123;</span><br><span class="line">    cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h3><p><a href="https://www.luogu.com.cn/problem/P1368">P1368 【模板】最小表示法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n &lt;&lt; <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    arr[i + n] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n &amp;&amp; arr[i + k] == arr[j + k];k++);</span><br><span class="line">    <span class="keyword">if</span>(k == n) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[i + k] &lt; arr[j + k])&#123;</span><br><span class="line">      j = j + k + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i == j) j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i = i + k + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i == j) i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> l = <span class="built_in">min</span>(i, j);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">    cout &lt;&lt; arr[i + l] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Something</title>
      <link href="/2024/01/26/Something/"/>
      <url>/2024/01/26/Something/</url>
      
        <content type="html"><![CDATA[<p>第一印象很重要：好的房屋门面能够让购房者进入房子之前被吸引；一辆车的喷漆工作将会比引擎盖下的东西吸引更多的人；文学作品中充满了一见钟情的故事。内在的东西很重要，但外在的 —— 先看到的 —— 才是重要的。</p><p align="right">-- Craig Walls《Spring实战(第6版)》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>纸牌均分问题</title>
      <link href="/2024/01/25/%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2024/01/25/%E7%BA%B8%E7%89%8C%E5%9D%87%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="纸牌均分"><a href="#纸牌均分" class="headerlink" title="纸牌均分"></a>纸牌均分</h3><blockquote><p>有 N 个人排成一排，它们的手中分别有 C[1] ~ C[N] 张纸牌，在每一步操作中，可以让某个人把自己手中的一张纸牌交给他旁边的一个人，求至少需要多少步操作才能让每个人手中持有的纸牌数相等。</p></blockquote><p>首先令 M 为这N 个人的纸牌总数，显然，问题有解，M 能被 N 整除。令avg = M / N，均分完成后每个人都有 avg 张纸牌。</p><p>首先考虑第一个人，他只能与第二个人交换纸牌。若C[1] &gt; avg，第一个人需要给第二个人 C[1] - avg 张纸牌；若C[1] &lt; avg，第一个人需要从第二个人手中拿 avg - C[1] 张纸牌。</p><p>类似地，考虑第 i 个人和第 i + 1 个人之间的交换。令 $ S[i]=\sum_{k=1}^{i}C[i]$，即数组C的前缀和。若 S[i] &lt; i * avg，那么第 i 个人必须从第 i + 1 个人手中拿走 i * avg - S[i] 张纸牌（否则前 i 个人的纸牌总数不可能为 i * avg，也不可能没人都有 avg 张牌）。同样若S[i] &gt; i * avg，第 i 个人给第 i + 1 个人S[i] - i * avg 张牌。</p><p>因此，最少交换次数就是$\sum_{i=1}^N\left|S[i]-\frac{M}{N} \right|$。</p><h3 id="环形纸牌均分（糖果传递）"><a href="#环形纸牌均分（糖果传递）" class="headerlink" title="环形纸牌均分（糖果传递）"></a>环形纸牌均分（糖果传递）</h3><blockquote><p>与上题的不同之处在于，N 个人是围成一圈而不是排成一排，因此第一个人和最后一个人之间是可以传递纸牌的。</p></blockquote><p>设第 i 个人给第 i + 1 个人 $x_i$ 张牌（若是第 i + 1 个人给第 i 个人纸牌，$x_i$为负数），特别地，第 N 个人给第1个人$x_N$张纸牌，那么，有以下等式：</p><script type="math/tex; mode=display">\begin{aligned}&c_1-x_1+x_N \\=&c_2-x_2+x_1 \\=&c_3-x_3+x_2 \\=&...   \\=&c_{N-1}-x_{N-1}+x_{N-2}\\=&c_N-x_N+x_{N-1}\\=&avg\end{aligned}</script><p>转化一下：</p><script type="math/tex; mode=display">\begin{aligned}x_1=&c_1-avg+x_N\\x_2=&c_2-avg+x_1\\=&(c_1+c_2)-2*avg+x_N\\&...\\x_i=&(c_1+c_2+...+c_i)-i*avg+x_N\end{aligned}</script><p>而$(c_1+c_2+…+c_i)-i*avg$是已知的常量，令它为$D_i$。</p><p>那么我们的问题就成了求下面式子的最小值：</p><script type="math/tex; mode=display">\sum_{i=1}^{N}\left|x_i\right|=\sum_{i=1}^{N}\left|D_i-x_N\right|</script><p>只需要考虑$x_N$取何值即可。这其实就是就是<a href="https://blog.csdn.net/TeFuirnever/article/details/113239325">货仓选址问题</a>，我们直接用结论：$x_N$取$D_i(i=1,2,…,N)$的中位数时，上式取最小值。</p><p>经过以上的理论分析之后，代码就很容易写了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  LL sum = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> avg = sum / n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] -= avg;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">  <span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">abs</span>(arr[mid] - arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七夕祭"><a href="#七夕祭" class="headerlink" title="七夕祭"></a>七夕祭</h3><p>七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。</p><p>于是 TYVJ 今年举办了一次线下七夕祭。</p><p>Vani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。</p><p>TYVJ 七夕祭和 11 区的夏祭的形式很像。</p><p>矩形的祭典会场由 N 排 M 列共计 N×M 个摊点组成。</p><p>虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。</p><p>Vani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。</p><p>不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。</p><p>两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。</p><p>由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。</p><p>现在 Vani 想知道他的两个要求最多能满足多少个。</p><p>在此前提下，至少需要交换多少次摊点。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 N 和 M 和 T，T 表示 cl 对多少个摊点感兴趣。</p><p>接下来 T 行，每行两个整数 x,y，表示 cl 对处在第 x 行第 y 列的摊点感兴趣。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>首先输出一个字符串。</p><p>如果能满足 Vani 的全部两个要求，输出 both；</p><p>如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 row；</p><p>如果只能使各列中 cl 感兴趣的摊点数一样多，输出 column；</p><p>如果均不能满足，输出 impossible。</p><p>如果输出的字符串不是 impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N,M≤100000,<br>0≤T≤min(N∗M,100000),<br>1≤x≤N,<br>1≤y≤M</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 3 4</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">row 1</span><br></pre></td></tr></table></figure><p>其实跟环形纸牌均分没啥区别，就是题干有点离谱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="function">LL <span class="title">minChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> tar = t / n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    arr[i] -= tar;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(sum.<span class="built_in">begin</span>() + <span class="number">1</span>, sum.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">int</span> ct = (<span class="number">1</span> + n) / <span class="number">2</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    ret += <span class="built_in">abs</span>(sum[i] - sum[ct]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, c, l;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; l;</span><br><span class="line">    row[c]++;</span><br><span class="line">    col[l]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t % n == <span class="number">0</span> &amp;&amp; t % m == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;both &quot;</span> &lt;&lt; (<span class="built_in">minChange</span>(row) + <span class="built_in">minChange</span>(col));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t % n == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;row &quot;</span> &lt;&lt; <span class="built_in">minChange</span>(row);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t % m == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;column &quot;</span> &lt;&lt; <span class="built_in">minChange</span>(col);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倍增算法</title>
      <link href="/2024/01/23/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/01/23/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>所谓“倍增”，就是成倍增长。在一些求解空间较大的问题中，如果使用通常的线性递推，需要线性的时间复杂度。而如果采用倍增的方式，通常能优化为对数时间复杂度。简单地解释倍增思想，就是每次都试图使结果范围扩大一定长度，如果扩大后仍满足要求，则扩大，并将下一次试图扩大的长度变为原来的两倍；若不满足，则将扩大长度减半，再次尝试，若仍不满足，则继续减半。最终，扩大长度减为0，就得到了所需的结果。下面是两个使用倍增算法的例子。</p><h3 id="求小于T的最大数组前缀和"><a href="#求小于T的最大数组前缀和" class="headerlink" title="求小于T的最大数组前缀和"></a>求小于T的最大数组前缀和</h3><blockquote><p>给定一个长度为N的数列 A，然后进行若干次询问，每次给定一个整数T,求大的 k，满足 $\sum_{i=1}^{N}{A[i]}\le T$。你的算法必须是在线的（必须即时回答每一个询问能等待收到所有询问后再统一处理），假设$0\le T\le\sum_{i=1}^{N}{A[i]}$。</p></blockquote><ol><li>最朴素的做法当然是从前往后累加数组，直到累加和大于T，时间复杂度是O(N)。</li><li>首先用O(N)的时间预处理，求出前缀和数组，再用二分查找确定小于等于T的上界。每次查找O(logN)。</li><li>如果每次查找的T都很小，使用二分查找可能还不如直接从头遍历数组，那么可以使用倍增算法：<ol><li>令p=1，k=0，sum=0。</li><li>比较“A数组中 k之后的p个数的和”与T的关系，也就是说，如果 sum+S[k+p]-S[k]≤T,则令 sum+=S[k+p]-S[k],k+=p,p*=2,即累加上这 p个数的和，然后把p的跨度增长一倍。如果sum+S[k+p]-S[k]&gt;T，则令 p/= 2。</li><li>重复上一步，直到p的值变为0，此时k就是答案。</li></ol></li></ol><p>下面给出使用二分查找和倍增算法的代码，并比较二者的求解时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pre_sum;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; xs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    pre_sum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : xs) &#123;</span><br><span class="line">      sum += x;</span><br><span class="line">      pre_sum.<span class="built_in">push_back</span>(sum);</span><br><span class="line">      nums.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用倍增算法查询</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query_double</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, l = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k + l &lt; pre_sum.<span class="built_in">size</span>() &amp;&amp; sum + pre_sum[k + l] - pre_sum[k] &lt;= t) &#123;</span><br><span class="line">        sum += (pre_sum[k + l] - pre_sum[k]);</span><br><span class="line">        l *= <span class="number">2</span>;</span><br><span class="line">        k += l;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 通过二分查找查询</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query_binary_search</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> loc = <span class="built_in">upper_bound</span>(pre_sum.<span class="built_in">begin</span>(), pre_sum.<span class="built_in">end</span>(), t);</span><br><span class="line">    <span class="keyword">return</span> loc - pre_sum.<span class="built_in">begin</span>() - <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="comment">// 设置随机数</span></span><br><span class="line">  random_device rd;</span><br><span class="line">  <span class="function">default_random_engine <span class="title">eng</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distr</span><span class="params">(<span class="number">0</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成一个随机数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="built_in">set</span>(nums);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.t随机分布</span></span><br><span class="line">  <span class="comment">// 生成测试数组</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; test_list;</span><br><span class="line">  <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">  distr = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, sum);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    test_list.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用两种方法分别测试</span></span><br><span class="line">  <span class="type">clock_t</span> start, end;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_binary_search</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using binary search: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_double</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using times increase: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. t比较小</span></span><br><span class="line">  <span class="comment">// 生成测试数组</span></span><br><span class="line">  test_list.<span class="built_in">clear</span>();</span><br><span class="line">  distr = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, sum / <span class="number">10000</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    test_list.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用两种方法分别测试</span></span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_binary_search</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using binary search: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_double</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using times increase: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// t随机分布</span><br><span class="line">time of using binary search: 0.019</span><br><span class="line">time of using times increase: 0.02</span><br><span class="line">// t值比较小</span><br><span class="line">time of using binary search: 0.011</span><br><span class="line">time of using times increase: 0.006</span><br></pre></td></tr></table></figure><p>由此可见，一般情况下，二分方法和倍增的时间复杂度接近；t比较小的情况小，倍增方法要优于二分查找。</p><h3 id="Genius-ACM"><a href="#Genius-ACM" class="headerlink" title="Genius ACM"></a>Genius ACM</h3><p><a href="https://www.acwing.com/problem/content/description/111/">原题</a></p><blockquote><p>给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:</p><p>从集合 S 中取出 M 对数（即 2*M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M对，则取到不能取为止），使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。</p><p>现在给定一个长度为 N 的数列 A 以及一个整数 T。</p><p>我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。</p><p>求最少需要分成几段。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 K，代表有 K 组测试数据。</p><p>对于每组测试数据，第一行包含三个整数 N,M,T。</p><p>第二行包含 N 个整数，表示数列A1,A2…AN。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组测试数据，输出其答案，每个答案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤12,<br>1≤N,M≤500000,<br>0≤T≤10^18,<br>0≤Ai≤2^20</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 1 49</span><br><span class="line">8 2 1 7 9</span><br><span class="line">5 1 64</span><br><span class="line">8 2 1 7 9</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></blockquote><p>首先，我们需要一个结论：求集合S的检验值，就是将S排序，每次取最大值和最小值构成一对，这样求出来的“每对数的差的平方和”最大。可以用只有四个数的情况证明：</p><script type="math/tex; mode=display">\begin{aligned}假&设A<B<C<D，\\&[(D-A)^2+(C-B)^2]-[(D-B)^2+(C-A)^2]\\=&-2AD-2BC+2BD+2AC\\=&2B(D-C)-2A(D-C)\\=&2(B-A)(D-C) >0\\故&(D-A)^2+(C-B)^2>(D-B)^2+(C-A)^2\end{aligned}</script><p>更多数也是类似的，就不证明了。因此，可以用贪心，让每一段尽量长，就能得到最少得分段数了。于是，我们要解决的问题变为，确定左端点L之后，求最大的右端点R，使得A[l]~A[r]的校验值不超过t。当然可以使用二分思想，每次取一个可能范围的中间点mid，对A[l]~A[mid]排序，然后求校验值，与t比较后缩小范围。然而，与第一个例子类似，右端点r应该在比较靠近左端点l的位置，使用倍增可能要优于二分。故可以采用与上例类似的算法：</p><ol><li>初始化 p = 1，R = L；</li><li>求出 [L, R + p] 这一段区间的“校验值”,若“校验值” ≤ T，则 R += p,p *= 2，否则 p /= 2；</li><li>重复上一步，直到 p 的值变为0，此时 R 即为所求。</li></ol><p>下面是代码，其中有一个优化：每次求校验值不需要对整个数组排序，只需要对新增部分长度排序，然后与前面已排序部分合并即可。这样数组的每一段都只经过一次排序，时间复杂度为O(N*logN)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> A[<span class="number">500000</span>];</span><br><span class="line"><span class="type">int</span> B[<span class="number">500000</span>];</span><br><span class="line"><span class="type">int</span> C[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = begin, r = mid, pt = begin;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; mid &amp;&amp; r &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (B[l] &lt; B[r]) &#123;</span><br><span class="line">      C[pt++] = B[l++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      C[pt++] = B[r++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; mid) &#123;</span><br><span class="line">    C[pt++] = B[l++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; end) &#123;</span><br><span class="line">    C[pt++] = B[r++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数组B[mid, end)排序，后将B[begin, mid)与B[mid, end)归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">single_sort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(B + mid, B + end);</span><br><span class="line">  <span class="built_in">merge</span>(begin, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算排好序后的数组C在[begin, end)范围的校验值</span></span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = begin, r = end - <span class="number">1</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r &amp;&amp; m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ret += ((LL)C[r] - C[l]) * ((LL)C[r] - C[l]);</span><br><span class="line">    m--, l++, r--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> begin, <span class="type">int</span> m, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, p = begin;</span><br><span class="line">  LL sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p + l &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt; p + l; i++) B[i] = A[i];</span><br><span class="line">      <span class="built_in">single_sort</span>(begin, p, p + l);</span><br><span class="line">      sum = <span class="built_in">cal</span>(begin, p + l, m);</span><br><span class="line">      <span class="keyword">if</span> (sum &lt;= t) &#123;</span><br><span class="line">        p += l;</span><br><span class="line">        l *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; p; i++) B[i] = C[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum == <span class="number">0</span>) p = n;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p &lt; n) &#123;</span><br><span class="line">    p = forward(n, p, m, t);</span><br><span class="line">    ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">partition</span>(n, m, t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h3><p>ST算法也是倍增思想的一个应用，参考之前的文章：<a href="http://sprooc.github.io/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/">Sparse Table(稀疏表) | Sprooc</a></p><p>参考资料：</p><ol><li>算法竞赛进阶指南.李煜东.0x06节。</li><li><a href="https://www.acwing.com/solution/content/15458/">AcWing 109. 天才ACM - AcWing</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网计算-名词解释</title>
      <link href="/2024/01/05/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2024/01/05/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网计算-名词解释"><a href="#互联网计算-名词解释" class="headerlink" title="互联网计算-名词解释"></a>互联网计算-名词解释</h2><span id="more"></span><hr><div class="table-container"><table><thead><tr><th>英文简称</th><th>英文全称</th><th>中文</th><th>解释</th></tr></thead><tbody><tr><td>ABR</td><td>area border routers</td><td>区域边界路由器</td><td>在使用OSPF的网络中，拥有连接不同区域的接口的路由器，通常是Area 0 和其他区域。</td></tr><tr><td>Access links</td><td></td><td>接入链路</td><td>交换机上的链路，只属于一个VLAN</td></tr><tr><td>ACK</td><td>acknowledgement</td><td>确认字符</td><td>在有确认的传输中，接收方发送给发送方的一种控制字符，表示发来的数据与收到</td></tr><tr><td>ACL</td><td>access control list</td><td>访问控制列表</td><td>路由器或交换机接口的指令列表，控制端口进出数据包。</td></tr><tr><td>ad-hoc Network</td><td></td><td>自组网络</td><td>属于一次对话的各帧</td></tr><tr><td>Administrative  Distance</td><td>管理距离</td><td>⼀个0-255的值，提供路由可靠性的⼀个可选参数</td><td></td></tr><tr><td>ADSL</td><td>asymmetric digital subscriber line</td><td>非对称数字用户线</td><td>上行和下行宽带不对称，利用频分服用，用电话线提供宽带服务</td></tr><tr><td>AMI</td><td>alternate mark inversion</td><td>双极性传号交替反转码</td><td>n零电平表示“0”，正负电平的跃迁表示“1”，实现对“1”电平的交替反转。</td></tr><tr><td>AP</td><td>access point</td><td>接入点</td><td>允许无线设备（如笔记本电脑、智能手机、平板电脑等）通过Wi-Fi连接到有线局域网络</td></tr><tr><td>ARP</td><td>address resolution protocol</td><td>地址解析协议</td><td>根据IP地址查询MAC地址的协议。</td></tr><tr><td>ARQ</td><td>automatic repeat request</td><td>自动重传请求</td><td>重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</td></tr><tr><td>ASP</td><td>AppleTalk session protocol</td><td>AppleTalk会话协议</td><td></td></tr><tr><td>Asymmetric Switching</td><td></td><td>非对称交换</td><td>交换机不同端口宽带不同</td></tr><tr><td>ATM</td><td>Asynchronous transfer mode</td><td>异步传输模式</td><td>ATM是以信元为基础的一种分组交换和复用技术。</td></tr><tr><td>ATU</td><td>Access Termination Unit</td><td>接入端接单元</td><td>在用户端与数字通信网络之间充当接入终端的角色。</td></tr><tr><td>ATU-C</td><td>Access Termination Unit-Central Office</td><td>端局接入端接单元</td><td>电话端局所用的ADSL调制解</td></tr><tr><td>ATU-R</td><td>Access Termination Unit-Remote</td><td>远端接入端接单元</td><td>用户端所用的ADSL调制解</td></tr><tr><td>axial</td><td></td><td></td><td></td></tr><tr><td>backbone</td><td></td><td>主干</td><td>用于vlan间通信</td></tr><tr><td>bandwidth</td><td></td><td>带宽</td><td></td></tr><tr><td>baud</td><td></td><td>波特率</td><td>信号每秒变化的次数</td></tr><tr><td>BDR</td><td>backup designated router</td><td>备份指定路由器</td><td>对DR的备份，DR失效时，BDR成为DR</td></tr><tr><td>BID</td><td>bridge ID</td><td>网桥ID</td><td>两字节的优先级加上6字节的MAC地址，用于选举root bridge 和root port</td></tr><tr><td>bit</td><td></td><td>比特率</td><td>每秒传送的二进制位数</td></tr><tr><td>BOOTP</td><td>bootrap protocol</td><td>引导程序协议</td><td>向BOOTP服务器请求分配IP</td></tr><tr><td>BPDU</td><td>bridge protocol data unit</td><td>桥接数据单元</td><td>STP帧，用于确定生成树拓扑</td></tr><tr><td>BRI</td><td>basic rate interface</td><td>基本速率接口</td><td>2B + 1D</td></tr><tr><td>bridge</td><td></td><td>网桥</td><td>对收到的帧根据其MAC 帧的目的地址进行转发和过滤</td></tr><tr><td>broadcast</td><td></td><td>广播</td><td>一个数据报从源站发送到网络上所有节点</td></tr><tr><td>BS</td><td>basic station</td><td>基站</td><td>用于提供与移动设备（如手机）之间的通信。</td></tr><tr><td>BSS</td><td>basic service set</td><td>基本服务集</td><td>一组互相有联系的无线设备</td></tr><tr><td>CDM</td><td>code division multiplexing</td><td>码分复用</td><td>靠不同编码来区分各路原始信号源的复用方式</td></tr><tr><td>CDMA</td><td>code division multiplex access</td><td>码分多址</td><td></td></tr><tr><td>CHAP</td><td>challenge handshake authentication protocol</td><td>挑战握手认证协议</td><td>链路建⽴阶段结 束之后，认证者向对端点发送“challenge”消息;对端点⽤经过单向哈希函数 计算出来的值做应答;  认证者根据它⾃⼰计算的哈希值来检查应答，如果值匹配，认证得到承认， 否则连接应该终⽌; 经过⼀定的随机间隔，认证者发送⼀个新 challenge  给端点，重复步骤 1- 3</td></tr><tr><td>CIDR</td><td>classless inter domain routing</td><td>无类域间路由</td><td>使用IP地址和子网掩码来确定网络范围，消除了ABC类地址的划分</td></tr><tr><td>collision domain</td><td></td><td>冲突域</td><td>局域网（LAN）上，当两个或多个设备同时发送数据帧（数据包）时，可能发生冲突的区域。</td></tr><tr><td>CPE</td><td>Customer Premises Equipment</td><td>用户驻地设备</td><td>位于用户驻地的设备和内部布线，用户驻地设备连接到运营商的电信信道。用户可以从服务提供商处购买 CPE 或租用 CPE。这里的用户是指从服务提供商或运营商订购  WAN 服务的公司。</td></tr><tr><td>CRC</td><td>cyclic redundancy check</td><td>循环冗余校验</td><td>选取一个合适的除数，要进行校验的数据是被除数，然后做模2除法，得到的余数就是CRC校验值。</td></tr><tr><td>crossover cable</td><td></td><td>交叉线</td><td>一端T568A一端T568B，连接同层设备（思科认为PC网卡是第三层，所以PC连路由器用交叉线）</td></tr><tr><td>CSMA/CA</td><td>carrier sense multiple access with collision avoid</td><td>带碰撞避免的载波监听多路复用</td><td>发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围 的站点监听到该帧，从⽽在⼀定时间内避免数据发送。⽤于⽆线局域⽹⽐较多</td></tr><tr><td>CSMA/CD</td><td>carrier sense multiple access with collision detection</td><td>带碰撞检测的载波监听多路复用</td><td>先监听线路，如果发现空闲，则发送数据，否则等待。 在传输过程中，仍然监听线  路，如果冲突检测到，⽴即停⽌传输，则先⼴播拥塞信号，退避算法决定哪个设备再次接⼊介 质。⽤于以太⽹⽐较多</td></tr><tr><td>CSU/DSU</td><td>channel service unit/data service unit</td><td>信道服务单元/数据服务单元</td><td></td></tr><tr><td>Cut-through</td><td></td><td>直通交换</td><td>不校验就转发</td></tr><tr><td>DBD</td><td>Database Description</td><td>数据库描述</td><td>OSPF中，描述本地LSDB中每一条LSA的摘要信息。</td></tr><tr><td>DCE</td><td>Data Circuit-Terminating Equipment</td><td>数据电路终端设备</td><td>DCE 由将数据放入本地环路的设备组成。DCE 主要提供一个接口，用于将用户连接到 WAN 网云上的通信链路。</td></tr><tr><td>default gateway</td><td></td><td>默认网关</td><td>指在一个子网内，用于转发数据包到其他网络或子网的设备。</td></tr><tr><td>DHCP</td><td>dynamic host configuration protocol</td><td>动态主机配置协议</td><td>是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</td></tr><tr><td>DIFS</td><td>distributed inter-frame space</td><td>分布协调功能帧间间隔</td><td>CSMA/CA中，如果在DIFS时间间隔内信道保持空闲，设备可以发送数据。</td></tr><tr><td>DMT</td><td>Discrete Multi-Tone</td><td>离散多音调调制技术</td><td>实现ADSL的技术，DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25  个子信道用于上行信道，而 249 个子信道用于下行信道。</td></tr><tr><td>DNS</td><td>domain name system</td><td>域名系统</td><td>域名系统（DNS）是网络上的一项服务，负责管理域名并响应来自客户端的请求，将域名翻译成相应的IP地址。</td></tr><tr><td>Domain Name</td><td></td><td>域名</td><td>由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称</td></tr><tr><td>DR</td><td>designated router</td><td>指定路由器</td><td>在使用OSPF的多路复用网络中，被选举作为代表网络内所有路由器的路由器。</td></tr><tr><td>DS</td><td>distribution system</td><td>分配系统</td><td>一组相互连接的无线局域网，它们通过一个或多个接入点（Access Point，AP）连接到有线局域网（Local Area  Network，LAN）或其他网络。</td></tr><tr><td>DSLAM</td><td>Digital Subscriber Line Access Multiplexer</td><td>数字用户线接入复用器</td><td>DSLAM是各种DSL系统的局端设备，属于最后一公里接入设备（the last  mile），其功能是接纳所有的DSL线路，汇聚流量，相当于一个二层交换机。其在ADSL系统中的位置。</td></tr><tr><td>DSSS</td><td>Direct Sequence Spread Spectrum</td><td>直接序列扩频</td><td>直接序列扩频通过利用高速率的扩频序列在发射端扩展信号的频谱，而在接收端用相同的扩频码序列进行解扩，把展开的扩频信号还原成原来的信号。</td></tr><tr><td>DTE</td><td>Data Terminal Equipment</td><td>数据终端设备</td><td>传送来自客户网络或主机计算机的数据以便在 WAN 上传输的客户设备。DTE 通过 DCE 连接到本地环路</td></tr><tr><td>DVP</td><td>distance vector protocol</td><td>距离向量协议</td><td>通过计算⽬标路由器与源路由器之间的距离 ⽮量和来选择最佳路径，有频繁和周期性的更新，每次更新都将整张路由表发给周围的路由器，</td></tr><tr><td>dynamic routes</td><td></td><td>动态路由</td><td>使用路由协议动态更新路由信息。</td></tr><tr><td>Dynamic VLAN</td><td></td><td>动态VLAN</td><td>当新的站点连接到一个端口时，交换机通过查表来动态设置端口所属的VLAN</td></tr><tr><td>EGP</td><td>exterior gateway protocol</td><td>外部网关协议</td><td>用于在不同自治系统（AS，Autonomous System）之间进行路由选择的协议。</td></tr><tr><td>EIGRP</td><td>enhance interior gateway route protocol</td><td>增强的内部网关路由协议</td><td>Cisco的LSP和DVP的混合协议</td></tr><tr><td>ESS</td><td>extended service set</td><td>扩展服务集</td><td>由多个使用相同SSID的BSS组成，目的是扩展无线网络覆盖范围。</td></tr><tr><td>Fast  Forward Switching</td><td>快速转发交换</td><td>只检查帧的目的MAC，然后立即转发此帧。</td><td></td></tr><tr><td>FCS</td><td>frame check sequence</td><td>帧校验序列</td><td>用于对帧进行校验的字段。</td></tr><tr><td>FDDI</td><td>fiber distributed data inteface</td><td>光纤分布式数据接口</td><td>一种局域网数据传输标准，以光纤为主要介质。</td></tr><tr><td>FDM</td><td>frequency division multiplexing</td><td>频分服用</td><td>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</td></tr><tr><td>Flow control</td><td></td><td>流控制</td><td>一种保证不在缓冲区已满的情况下发送端继续传输数据的机制。</td></tr><tr><td>Fragment Free</td><td></td><td>免碎片</td><td>只读取前64个字节来检测错误，然后转发</td></tr><tr><td>Frame Filtering</td><td></td><td>帧过滤</td><td></td></tr><tr><td>Frame Relay</td><td></td><td>帧中继</td><td>帧中继（Frame  Relay）是一种在计算机网络中用于在广域网（WAN）上进行数据传输的数据链路层协议。它提供了一种简单而高效的方法，允许在不同地理位置的网络设备之间进行数据通信。</td></tr><tr><td>Frame Tagging</td><td></td><td>帧标记</td><td></td></tr><tr><td>FTP</td><td>file transfer protocol</td><td>文件传输协议</td><td>用于在网络上进行文件传输的一套标准协议，它工作在  OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程，  保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。</td></tr><tr><td>FTTx</td><td>Fiber to the x</td><td>光纤到x</td><td>HTTH,光纤到家 HTTB光纤到大楼, HTTC光纤到路边</td></tr><tr><td>full-duplex  transmission</td><td></td><td>全双工</td><td>信号可以同时双向传输</td></tr><tr><td>GIF</td><td>graphic interchange format</td><td>图形交换格式</td><td>一种公用的图像文件格式标准</td></tr><tr><td>half-duplex  transmission</td><td></td><td>半双工</td><td>信号双向传输，但不能同时传输</td></tr><tr><td>HDLC</td><td>high-level data link control</td><td>高级数据链路控制</td><td>在同步⽹上传输数据、⾯向⽐特的数 据链路层协议。思科路由器上的默认WAN接⼝封装协议。</td></tr><tr><td>HDSL</td><td>High Speed DSL</td><td>高速数字用户线</td><td></td></tr><tr><td>HFC</td><td>Hybird Fiber Coax</td><td>光线同轴混合网</td><td>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</td></tr><tr><td>hold-dowm timer</td><td></td><td>挂起计时器</td><td>路由器需要将某些可能导致路由环路的网络状态的变化保留一段时间，在这段时间内，路由器将视情况对这些网络状态的变化所产生的路由信息进行更改。</td></tr><tr><td>HTML</td><td>hyper-text mark language</td><td>超文本标记语言</td><td>一种用于创建网页的标准标记语言。</td></tr><tr><td>HTTP</td><td>hyper-text transfer protocol</td><td>超文本传输协议</td><td>客户端和服务端进行数据传输的一种规则</td></tr><tr><td>HTTPD</td><td>HTTP daemon</td><td>超文本传输协议守护程序</td><td>在万维网服务器等待 HTTP 请求的进程</td></tr><tr><td>hub</td><td></td><td>集线器</td><td>对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</td></tr><tr><td>Hybird Protocol</td><td></td><td>混合协议</td><td>DVP和LSP的混合协议。</td></tr><tr><td>ICMP</td><td>Internet control message protocol</td><td>网际控制报文协议</td><td>是为了提⾼IP数据报交付成功的机会，允许主机或路由器报告差错情况和提供有关异常情况报告的协议，运⾏在IP层</td></tr><tr><td>IDSL</td><td>ISDN DSL</td><td>ISDN数字用户线</td><td></td></tr><tr><td>IEEE</td><td>institute of electrical and electronic engineers</td><td>电气和电子工程师协会</td><td></td></tr><tr><td>IGP</td><td>interior gateway protocol</td><td>内部网关协议</td><td>用于在单一自治系统（AS，Autonomous System）内部进行路由选择的协议。</td></tr><tr><td>IGRP</td><td>Interior gateway routing protocol</td><td>内部网关路由协议</td><td>思科的一种DVP</td></tr><tr><td>infrared</td><td></td><td>红外线</td><td></td></tr><tr><td>ISDN</td><td>integrated service digital network</td><td>混合业务数字网络</td><td>一种电路交换技术，能够让 PSTN 本地环路传输数字信号，从而实现更高容量的交换连接。</td></tr><tr><td>IS-IS</td><td>intermediate-system to intermediate-system</td><td>中间系统到中间系统</td><td>LSP和DVP的混合协议</td></tr><tr><td>ISL</td><td>Inter-Switch Link</td><td>交换机间链路</td><td>思科专利，封装帧，加上VLAN信息</td></tr><tr><td>ISO</td><td></td><td></td><td></td></tr><tr><td>ISP</td><td>internet service provider</td><td>互联网服务提供商</td><td>向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。</td></tr><tr><td>JPEG</td><td>joint photographic experts group</td><td>联合图像专家组</td><td>一种针对照片影像而广泛使用的有损压缩标准方法</td></tr><tr><td>LAPB</td><td>Link Access Procedure Balanced</td><td>链路接入规程，平衡式</td><td>链路访问过程平衡（LAPB）是数据链路层协议，负责管理在 X.25 中 DTE 设备与 DCE 设备之间的通信和数据包帧的组织过程。</td></tr><tr><td>LAPD</td><td>Link Access Procedure On the D-Channel</td><td>D信道链路接入规程</td><td>一种面向连接、可靠的数据链路层协议，通常用于数字通信网络，特别是在 ISDN（Integrated Services Digital  Network）和 X.25 等环境中。它负责在 D  通道上建立、维护和释放连接，并处理信令、控制信息，以及错误检测，以确保在用户设备和网络交换设备之间的数据传输的可靠性和有序性。</td></tr><tr><td>laser</td><td></td><td>激光</td><td></td></tr><tr><td>late collision</td><td></td><td>迟冲突</td><td>64byte帧发送后发生的错冲突，它将影响网络性能。在一个健康的网络中极少发生此类冲突。</td></tr><tr><td>LCP</td><td>link control protocol</td><td>链路控制协议</td><td>在PPP协议中，用于建立连接，配置连接选项，测试链路质量</td></tr><tr><td>line coding</td><td></td><td>线路编码</td><td>把二进制信息转化为可以在物理介质上传输的形式。</td></tr><tr><td>link</td><td></td><td>链路</td><td>连接两个网络设备的物理连接</td></tr><tr><td>LLC</td><td>logical link control</td><td>逻辑链路控制</td><td>与网络层交互，标识不同的协议类型并封装它们</td></tr><tr><td>LSA</td><td>link-state advertisements</td><td>链路状态通告</td><td>装载和传输链路状态信息的报文</td></tr><tr><td>LSAck</td><td>Link-State Acknowledgement</td><td>链路状态确认</td><td>OSPF中，对收到的LSA进行确认</td></tr><tr><td>LSP</td><td>link state protocol</td><td>链路状态协议</td><td>每个路由器都了解整个⽹络的拓扑结构，利⽤算法 计算两个路由之间的最短路径，更新由事件触发，每次更新都只向周围的路由器传递路由表的更  新信息，包括OSPF等</td></tr><tr><td>LSR</td><td>Link-State Request</td><td>链路状态请求</td><td>OSPF中，两个路由器交换DBD后，发送LSR请求所有LSA</td></tr><tr><td>LSU</td><td>Link-State Update</td><td>链路状态更新</td><td>OSPF中，向对方发送所需要的LSA</td></tr><tr><td>MAC</td><td>madia access control</td><td>介质访问控制</td><td>与物理层交互，定义如何在物理层上传输帧</td></tr><tr><td>MIME</td><td>Multipurpose Internet Mail Extension</td><td>通用互联网邮件扩充</td><td>MIME 在其邮件首部中说明了邮件的数据类型（如文本、声音、图像、视像等）。在MIME 邮件中可同时传送多种类型的数据。</td></tr><tr><td>Modems</td><td></td><td>调制解调器</td><td>负责模拟信号和数字信号之间的转化</td></tr><tr><td>MSL</td><td>max segment lifetime</td><td>最长报文段生存时间</td><td></td></tr><tr><td>MSS</td><td>maximun segment size</td><td>最长报文段长度</td><td>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</td></tr><tr><td>MTU</td><td>maximum transmission unit</td><td>最大传送单元</td><td>指网络能够传输的最大数据包大小，以字节为单位。一般由数据链路层规定。（以太网1500）</td></tr><tr><td>multicast</td><td></td><td>组播</td><td>一个数据报从源站发送到特定的一组目的站</td></tr><tr><td>NAT</td><td>network address translation</td><td>网络地址转换</td><td>是⼀种把内部私有⽹络地址（IP地址）翻译成外部⽹络IP地址的技术</td></tr><tr><td>native VLAN</td><td></td><td>本征VLAN</td><td>用于未标记帧的默认VLAN</td></tr><tr><td>NAV</td><td>network allocation vector</td><td>网络分配向量</td><td>CSMA/CA中，指出了信道处于忙状态的持续时间。</td></tr><tr><td>NCP</td><td>network control protocol</td><td>网络控制协议</td><td>PPP协议中，选择和配置第三层协议</td></tr><tr><td>NFS</td><td>netword file system</td><td>网络文件系统</td><td>一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样</td></tr><tr><td>NIC</td><td>netword interface card</td><td>网卡</td><td>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。由于其拥有MAC地址，因此属于OSI模型的第1层和2层之间。它使得用户可以通过电缆或无线相互连接。</td></tr><tr><td>NRZ</td><td>non return to zero</td><td>不归零制码</td><td></td></tr><tr><td>NVRAM</td><td>non-volatile RAM</td><td>非易失随机存取存储器</td><td></td></tr><tr><td>OC</td><td>Optical Carrier</td><td>光载波</td><td></td></tr><tr><td>ODN</td><td>Optical Distribution Node</td><td>光纤分配节点</td><td>HFC网中，在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</td></tr><tr><td>OSI reference model</td><td>open system interconnection reference model</td><td>开放系统互联参考模型</td><td>国际标准化组织（ISO）提出的网络模型，有助于网络构建者实现可以相互通信和协同工作的网络。描述了信息或数据如何从一个计算机通过网络传输到另一台计算机的过程，采用分层通信的方法，每个层次执行特定任务。</td></tr><tr><td>OSPF</td><td>open shortest path first</td><td>开放最短路径优先</td><td>LSP的一种实现，每个路由器维护一个描述整个自治系统链路状态的数据库， 通过最短路径算法求出最短路径树，从而决定最优路由。</td></tr><tr><td>OUI</td><td>organizational unique identifier</td><td>组织唯一标识符</td><td>生产局域网适配器的厂家都必须向IEEE 购买由这三个字节构成的这个号，用于标识其生产商</td></tr><tr><td>PAP</td><td>password authentication protocol</td><td>口令鉴别协议</td><td>远程节点不停的在链路上反复发送⽤ 户名/密码，直到验证通过或者连接终⽌。不健壮的身份认证协议，使⽤明⽂发送密码。连接建 ⽴前只有⼀次认证</td></tr><tr><td>PAT</td><td>port address translation</td><td>端口地址转换</td><td>是对⽹络地址转换（NAT）的扩展，它允许局域⽹（LAN）上的多个设备映射到⼀个单⼀的公共IP地址的不同端口。</td></tr><tr><td>PDU</td><td>protocol data unit</td><td>协议数据单元</td><td>对等层次之间传递的数据单位</td></tr><tr><td>PID</td><td>Port ID</td><td>端口ID</td><td></td></tr><tr><td>ping</td><td>packet internet groper</td><td></td><td>使用ICMP的会送请求和应答报文来测试两个主机之间的联通性的应用。</td></tr><tr><td>POP</td><td>post office protool</td><td>邮局协议</td><td>用于支持使用客户端远程管理在服务器上的电子邮件</td></tr><tr><td>POST</td><td>Power On Self Test</td><td>开机自检软件</td><td>储存在路由器的ROM，开机时运行，用于检查硬件。</td></tr><tr><td>PPP</td><td>point to point protocol</td><td>点对点协议</td><td>通过拨号或专线⽅式在两个⽹络节点之间建⽴连 接、发送数据。提供对多种⽹络层协议的⽀持。</td></tr><tr><td>preamble</td><td></td><td>前同步码</td><td>以太网帧前用于实现位同步的8个字节同步码，交替的1和0</td></tr><tr><td>PRI</td><td>primary rate interface</td><td>主速率接口</td><td>T1:: 23B + D; E1: 30B + D</td></tr><tr><td>Proxy ARP</td><td></td><td>代理ARP</td><td></td></tr><tr><td>PS</td><td>POTS Splitter</td><td>电话分离器</td><td></td></tr><tr><td>PSTN</td><td>Public Switch Telephone Network</td><td>公共交换电话网</td><td>日常生活中的电话网</td></tr><tr><td>PVC</td><td>Permanent Virtual Circuits</td><td>永久虚电路</td><td>信双方的电路在用户看来是永久连接的虚电路。</td></tr><tr><td>radio</td><td></td><td>无线电</td><td></td></tr><tr><td>RADSL</td><td>Rate Adaptive DSL</td><td>速率自适应DSL</td><td>ADSL 的一个子集，可自动调节线路速率</td></tr><tr><td>RAM</td><td>random access memory</td><td>随机存取存储器</td><td></td></tr><tr><td>RARP</td><td>reverse address resolution protocol</td><td>逆向地址解析协议</td><td>ARP为IP到MAC的转换，而RARP为MAC到IP的转换，向RARP服务器请求分配IP。</td></tr><tr><td>repeater</td><td></td><td>中继器</td><td>适用于完全相同的两个网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。  中继器是对信号进行再生和还原的网络设备：OSI模型的物理层设备。</td></tr><tr><td>RIP</td><td>router information protocol</td><td>路由信息协议</td><td>一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。</td></tr><tr><td>rollover cable</td><td></td><td>反转线</td><td>控制台电缆，全部插脚相反，用于将工作台连接到路由器或交换机进行配置。</td></tr><tr><td>route aggregation</td><td></td><td>路由聚合</td><td>路由聚合（也叫汇总）是让路由选择协议能够用一个地址通告众多网络，旨在缩小路由器中路由选择表的规模，以节省内存，并缩短IP对路由选择表进行分析以找出前往远程网络的路径所需的时间。</td></tr><tr><td>Route poisoning</td><td></td><td>路由毒害</td><td>防止路由环路的一种技术，当路由器发现一个网络不可达，不是将路由条目删除，而是将距离设为无穷大，让其它路由器直到这一网络不可达。</td></tr><tr><td>router</td><td></td><td>路由器</td><td>工作在第三层的网络设备，对不同网络之间的数据报进行路径选择、分组交换</td></tr><tr><td>routing protocol</td><td></td><td>主动路由协议</td><td>主动路由协议确定被动路由协议到达目的地的路径。</td></tr><tr><td>RPC</td><td>remote procedual call</td><td>远程过程调用</td><td>一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</td></tr><tr><td>RTS</td><td>request to send</td><td>请求传输帧</td><td>RTS  是一种用于协调无线网络中节点之间数据传输的信号。当一个节点准备发送数据时，它发送 RTS 信号以请求发送数据的权限。</td></tr><tr><td>RZ</td><td>return to zero</td><td>归零制码</td><td></td></tr><tr><td>SCP</td><td>DNA secion control protocol</td><td>会话控制协议</td><td></td></tr><tr><td>ScTP</td><td>screened twisted pair</td><td>网屏式双绞线</td><td></td></tr><tr><td>SDH</td><td>Synchronous Digital Hierarchy</td><td>同步数字系列</td><td>ITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH</td></tr><tr><td>SDSL</td><td>Single-line DSL</td><td>一对线的数字用户线</td><td></td></tr><tr><td>SIFS</td><td>short inter-frame space</td><td>短(Short)帧间间隔</td><td>分隔开属于一次对话的各帧</td></tr><tr><td>simplex transmission</td><td></td><td>单工</td><td>信号单向传输</td></tr><tr><td>SLIP</td><td>serial line internet protocol</td><td>串线网际协议</td><td>广域网第二层协议，一种在串行线路上对IP数据报进行封装的简单形式</td></tr><tr><td>SMTP</td><td>simple mail transfer protocol</td><td>简单邮件传输协议</td><td>可用在发送和接收电子邮件的信息</td></tr><tr><td>SNMP</td><td>simple network management protocol</td><td>简单网络管理协议</td><td>一种应用层协议，用于在不同网络设备之间交换管理信息。</td></tr><tr><td>socket</td><td></td><td>套接字</td><td>对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。包括IP地址和端口号</td></tr><tr><td>SONET</td><td>Synchronous Optical Network</td><td>同步光纤网</td><td>美国定义的数字传输标准，各级时钟都来自一个非常精确的主时钟</td></tr><tr><td>Source routing Bridge</td><td></td><td>源路由网桥</td><td>在发送帧时将详细的路由信息放在帧的首部中</td></tr><tr><td>SPF</td><td>shortest path first</td><td>最短路径优先</td><td></td></tr><tr><td>split horizen</td><td></td><td>水平分割</td><td>解决路由环路的方法之一，路由器从某个端口接收到的更新信息不再从这个端口发出去。</td></tr><tr><td>SQL</td><td>structrued query language</td><td>结构化查询语言</td><td>一种特定目的编程语言，用于管理关系数据库管理系统</td></tr><tr><td>SRA</td><td>Seamless Rate Adaption</td><td>无缝速率自适应技术</td><td>ADSL2使用的技术。在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</td></tr><tr><td>SSID</td><td>service set identifier</td><td>服务集标识符</td><td>对BSS的标识</td></tr><tr><td>static routes</td><td></td><td>静态路由</td><td>网络管理员手工输入路由信息。</td></tr><tr><td>Static VLAN</td><td></td><td>静态VLAN</td><td>直接指派端口所属的VLAN</td></tr><tr><td>STDM</td><td>static time division mulplexing</td><td>统计时分复用</td><td>但每一个STDM 帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM 帧中。对没有数据的缓存就跳过去。当一个帧的数据放满了，就发送出去。因此，  STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</td></tr><tr><td>STM-1</td><td>Synchronous Transfer Mudule</td><td>同步传递模块</td><td>SDH 的基本速率为 155.52 Mb/s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即  STM-1，相当于 SONET 体系中的 OC-3 速率。</td></tr><tr><td>Store-and-forward</td><td></td><td>存储转发</td><td>交换机存下整个帧，校验CRC，然后再转发该帧</td></tr><tr><td>STP</td><td>shielded twisted pair</td><td>屏蔽双绞线</td><td></td></tr><tr><td>STP</td><td>spanning tree protocol</td><td>生成树协议</td><td>通过计算稳定的生成树网络拓扑来防止环路</td></tr><tr><td>straight cable</td><td></td><td>直通线</td><td>两端均是T568A或均是T568B，用于连接跨层设备。</td></tr><tr><td>STS-1</td><td>Synchronous Transport Signal</td><td>第一级同步传送信号</td><td>SONET 为光纤传输系统定义了同步传输的线路速率等级结构，其传输速率51.84Mbit/s 为基础，大约对应于T3/E3 的传输速率</td></tr><tr><td>stub network</td><td></td><td>末节网络</td><td>仅有一单个通路通过路由器连接到其他子网，或者仅有一个通路连接到其他网络。</td></tr><tr><td>SVCs</td><td>Switched Virtual Circuits</td><td>交换虚电路</td><td>按需建立和终止的WAN路径</td></tr><tr><td>switch</td><td></td><td>交换机</td><td></td></tr><tr><td>Symmetric Switching</td><td></td><td>对称交换</td><td></td></tr><tr><td>TCP</td><td>transmission control protocol</td><td>传输控制协议</td><td>是⼀种⾯向连接的、可靠的、基于字节 流的传输层通信协议</td></tr><tr><td>TDM</td><td>time division multiplexing</td><td>时分复用</td><td>将时间划分为一段段等长的时分复用（TDM ）帧，每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。</td></tr><tr><td>Telnet</td><td></td><td>远程登录服务</td><td></td></tr><tr><td>TFTP</td><td>trivial file transfer protocol</td><td>一般文件传输协议</td><td></td></tr><tr><td>throuput</td><td></td><td>吞吐量</td><td></td></tr><tr><td>TLD</td><td>top level domain</td><td>顶级域名</td><td>一级域名，最高层</td></tr><tr><td>Transparent Bridge</td><td></td><td>透明网桥</td><td></td></tr><tr><td>Trunk links</td><td></td><td>主干链路</td><td>支持多个VLAN通信，用于连接交换机或路由器</td></tr><tr><td>UDP</td><td>user datagram protocol</td><td>用户数据报协议</td><td>OSI参考模型中⼀种⽆连接的传输层协 议，提供⾯向事务的简单不可靠信息传送服务。</td></tr><tr><td>UIB</td><td>User Interface Box</td><td>用户接口盒</td><td>HFC网中，每个家庭要安装一个用户接口盒用户接口盒 要提供三种连接，即：使用同轴电缆连接到机顶盒(set-top  box)，然后再连接到用户的电视机；使用双绞线连接到用户的电话机；使用电缆调制解调器连接到用户的计算机。</td></tr><tr><td>unicast</td><td></td><td>单播</td><td>一个数据报从源站发送到单一目的站</td></tr><tr><td>URL</td><td>uniform resource locator</td><td>统一资源定位符</td><td>对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</td></tr><tr><td>UTP</td><td>unshielded twisted pair</td><td>无屏蔽双绞线</td><td></td></tr><tr><td>VDSL</td><td>Very high speed DSL</td><td>甚高速用户数字线</td><td></td></tr><tr><td>VLAN</td><td>virtual local area network</td><td>虚拟局域网</td><td>是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。用于划分逻辑子网。工作在第二层和第三层。可以分割广播域</td></tr><tr><td>VLSM</td><td>variable length subnet mask</td><td>可变长子网掩码</td><td>允许一个自治系统内有不同子网掩码的网络。</td></tr><tr><td>WAN</td><td>Wide Area Network</td><td>广域网</td><td>通过WAN服务提供商连接LAN的通信网络。</td></tr><tr><td>WDM</td><td>wavelength division mulplexing</td><td>波分复用</td><td>波分复用就是光的频分复用。</td></tr><tr><td>Wi-Fi</td><td>Wireless-Fidelity</td><td>无线保真度</td><td></td></tr><tr><td>xDSL</td><td>x Digital Subscriber Line</td><td></td><td>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20240104小记</title>
      <link href="/2024/01/04/20240104%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/01/04/20240104%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>现在是2024年1月4日，期末周第三天的晚上，下午考完了第一门必修课毛概，后天将要考计网。目前的精神状态一言难尽。</p><span id="more"></span><p>下午考完毛概走出考场，考的题目基本都会做，心情本应该是不错的，但莫名有种怅然若失的感觉。我一时间竟然不知道接下来应该干什么。回到宿舍，随意刷了一个小时的B站，然后下楼吃饭，又在学校里漫无目的地逛了半个钟。又回到宿舍，听了一个小时的歌，然后为了打发时间刷了两道力扣。然而，干什么都提不起劲，陷入了一种百无聊赖的状态，只想早点上床睡觉。按理说吧，现在应该抓紧时间复习，但感觉意义不大，该复习的基本都复习好了，完全找不到前几天拼了老命地复习那种感觉。回想起来，去年期末周我也差不多是这种状态。或许是我想太多？可能只是把自己逼太紧了。想一想这一个学期，尤其是学期末，基本没有出过校门，一直憋在宿舍学习。可能确实是我给自己太大压力了，以后还是多点放松，这种精神状态属实很糟糕。</p><hr><p>最近偶然染上了陶喆。最开始是因为他的抽象了解到的，但听了几首歌之后完全被他的才华所折服。听97年的《David Tao》，让我重新感受到当初第一次听《Jay》时所受到的震撼。看来我还是喜欢哪个年代的R&amp;B啊。</p><div align="center"><iframe src="//player.bilibili.com/player.html?aid=843880220&bvid=BV1654y1p7TN&cid=290595174&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="500" height="300"> </iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231224周记</title>
      <link href="/2023/12/24/20231224%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/24/20231224%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>期末复习的一周，时间真的很紧，所以这周的周记也会写得比较仓促。。。这周把计组和计网复习了一遍，接下来就剩数据结构与算法了。</p><span id="more"></span><p>刚刚复习的时候看到一个不错的算法，简单记录一下</p><blockquote><p>2010年全国考研统考题（13 分）设将 n(n&gt;1) 个整数存放到一维数组 R 中，试设计一个在时间和空间两<br>方面尽可能有效的算法，将 R 中保有的序列循环左移 P (0&lt; P&lt; n )个位置，即<br>将 R 中的数据由（ X0 X1 ……Xn-1 ）变换为( Xp Xp+1 ……Xn-1 X0 X1…Xp-1)。</p></blockquote><p>算法的思想是做两次翻转，先将（ X0 X1 ……Xp-1 ）翻转，把( Xp Xp+1 ……Xn-1)，最后把整个数组翻转。时间复杂度O(n)，无需额外空间。</p><h4 id="Leetcode第-377-场周赛"><a href="#Leetcode第-377-场周赛" class="headerlink" title="Leetcode第 377 场周赛"></a>Leetcode第 377 场周赛</h4><p>时隔两个星期终于有空打一次周赛了。还是ac三题，最后一题没时间做了，而且也不会。简单总结一下：</p><ul><li>第一题送分题</li><li>第二题超时了3次才ac。关键是没想起学过的一个点：先建堆后排序要比动态建堆快。</li><li>第三题Floyd算法，秒了，一次错误提交是因为有重边。</li><li>第四题，跳了。</li></ul><div align="center"><img src="92ec2449ac56d1c0d613070dec3c076.png" alt="92ec2449ac56d1c0d613070dec3c076" style="zoom:80%;" /><img src="bdc545fe0baafc30f6f58c013cef8b9.png" alt="bdc545fe0baafc30f6f58c013cef8b9" style="zoom:80%;" /></div>下一周是这个学期最后一周，也是今年的最后一周了，继续加油吧！最后，在人生中经历的最冷冬天里，放一首歌。<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=186331&auto=0&height=66"> </iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第17讲-输入输出</title>
      <link href="/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第17讲-输入输出"><a href="#第17讲-输入输出" class="headerlink" title="第17讲-输入输出"></a>第17讲-输入输出</h2><span id="more"></span><h3 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h3><ol><li>输入输出操作通过连接到输入输出模块的各种外部设备完成，这些外部设备提供了在外部环境和计算机系统之间的数据交换，通常被称为外围设备（peripheral device），简称为外设（peripheral）</li><li>类型<ul><li>人可读设备：适用于与计算机用户通信<ul><li>显示器，打印机</li></ul></li><li>机器可读设备：适用于与设备通信<ul><li>磁盘，磁带</li></ul></li><li>通信设备：适用于与远程设备通信</li></ul></li><li>不能把外设直接连接到系统总线上<ul><li>外设种类繁多，操作方法多种多样</li><li>外设的数据传送速度一般比存储器或处理器的慢得多</li><li>某些外设的数据传送速度比存储器或处理器要快</li><li>外设使用的数据格式和字长度通常与处理器不同</li></ul></li></ol><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I/O模块"></a>I/O模块</h3><ol><li><p>通过系统总线或中央交换器和存储器连接；通过专用数据线与一个或多个外设连接。<br>I/O模块是计算机内部系统和外设之间的桥梁</p> <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220222712734.png" alt="image-20231220222712734" style="zoom:80%;" /> </div></li><li><p>外围设备的接口</p><ul><li>输入输出模块的接口以控制、状态和数据信号的形式出现</li><li>与设备相关的控制逻辑控制外设的操作，以响应来自输入输出模块的命令</li><li>缓冲器用于缓存输入输出模块和外设之间传送的数据<ul><li>缓冲器的大小一般为8 位或16 位<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220223343684.png" alt="image-20231220223343684" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>I/O模块的功能</p><ul><li>处理器通信<ul><li>命令译码：输入输出模块接收来自处理器的命令，这些命令一般作为信号发送到控制总线</li><li>状态报告：由于外设速度很慢, 所以知道输入 输出模块的状态很重要</li><li>数据：数据是在处理器和输入输出模块之间经由数据总线来交换的</li><li>地址识别：输入输出模块必须能识别它所控制的每个外设的唯一地址</li></ul></li><li>设备通信<ul><li>通信内容包含命令、状态信息和数据</li></ul></li><li>数据缓冲<ul><li>外设的数据传送速度一般比存储器或处理器的慢得多</li><li>某些外设的数据传送速度比存储器或处理器要快</li></ul></li><li>控制和定时<ul><li>处理器会非预期的与一个或几个外设进行通信</li><li>一些内部资源，如主存和系统总线，是被共享的</li><li>例如：控制从外设到处理器的数据传送包括以下几个步骤<ul><li>处理器查询输入 输出模块以检验所连接设备的状态</li><li>输入输出模块返回设备状态</li><li>如果设备运转并准备就绪，则处理器通过向输入 输出模块发出一条命令 请求数据传送</li><li>经输入输出模块传送数据到处理器</li></ul></li></ul></li><li>检错<ul><li>检错并把差错信息报告给处理器</li><li>差错类型<ul><li>设备报告的机械和电路故障</li><li>传输过程中数据位的变化</li></ul></li></ul></li></ul></li><li><p>I/O模块的结构</p><div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220224938555.png" alt="image-20231220224938555" style="zoom:80%;" /></div></li><li><p>外部接口</p><ul><li>接口类型<ul><li>并行接口：多根线连接输入 输出模块和外设，同时传送多位数据</li><li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li></ul></li><li>由于并行接口要求每次同时传送，当传输速度和总线长度增加时，总线的时钟频率会受到限制</li></ul></li></ol><h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I/O操作技术"></a>I/O操作技术</h3><ol><li>分类<ul><li>编程式I/O：处理器通过执行程序来直接控制I/O 操作，当处理器发送一条命令到I/O 模块时，它必须等待，直到I/O 操作完成</li><li>中断驱动式I/O：处理器发送一条I/O 命令后，继续执行其他指令；并且当I/O 模块完成其工作后，才去中断处理器工作</li><li>直接存储器读取（Direct Memory Access，DMA）：I/O 模块与主存直接交换数据，而不需要处理器的干涉<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220225832049.png" alt="image-20231220225832049"  /></div></li></ul></li><li>编程式I/O<ul><li>当处理器在执行过程中遇到一条与I/O 操作有关的指令时，它通过发送指令到适当的I/O 模块来执行这条指令</li><li>I/O模块将执行所要求的动作，然后在I/O 状态寄存器中设置一些适当的位</li><li>I/O不会中断处理器，因此处理器需要周期性地检查I/O模块的状态，直到发现该操作完成<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220230340632.png"  /></div></li><li>I/O 命令：为了执行I/O 操作，处理器发送一个指定具体I/O 模块和外设的地址，并发送一条I/O 命令<ul><li>类型<ul><li>控制命令：激活外设并告诉它要做什么</li><li>测试命令：测试I/O 模块及其外设相关的各种状态条件</li><li>读命令：使I/O 模块从外设获得一个数据，把它存入内部缓冲区</li><li>写命令：使I/O 模块从数据总线获得一个数据，把它传入外设</li></ul></li></ul></li><li>I/O 指令<ul><li>I/O指令很容易映射为I/O 命令, 并且两者之间通常是简单的一一对应关系<ul><li>指令的形式取决于外设寻址的方式</li></ul></li><li>编址方式<ul><li>存储器映射式I/O：存储单元和I/O 设备有统一的地址空间，即每一个地址对应一个内存地址或一个IO地址。能使用大的指令系统，可进行更有效的编程。但是I/O设备会占用地址空间。</li><li>分离式I/O：让总线既有存储器的读线和写线，同时也有输入和输出命令线。命令线指定地址指向内存地址还是IO设备。IO和内存都可以使用全部地址空间。</li></ul></li></ul></li></ul></li><li>中断驱动式I/O<ul><li>处理器发送一个I/O 命令到模块，然后去处理其它有用的工作</li><li>当I/O 模块准备和处理器交换数据时，它中断处理器以请求服务</li><li>处理器执行数据传送，最后恢复它原先的处理工作 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220231826050.png" alt="image-20231220231826050"  /> </div></li><li>从I/O 模块的角度来看<ul><li>I/O模块接收来自处理器的读命令</li><li>I/O模块从相关的外设中读入数据</li><li>一旦数据进入I/O 模块的数据寄存器后，该模块通过控制总线给处理器发送中断信号</li><li>I/O模块等待直到处理器请求该数据时为止</li><li>当处理器有数据请求时，I/O 模块把数据传送到数据总线上，并准备另一个I/O 操作</li></ul></li><li>从处理器的角度来看<ul><li>处理器发送一个读命令</li><li>处理器离开去做其它的事情，并在每个指令周期结束时检查中断</li><li>当来自I/O 模块的中断出现时，处理器保存当前程序的现场</li><li>处理器从I/O 模块读取数据字并保存到主存中</li><li>处理器恢复刚才正在运行的程序的现场，并继续运行原来的程序</li></ul></li><li>中断允许和中断禁止 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/18187e1805ee18e290626e3093abf5f.png" alt="18187e1805ee18e290626e3093abf5f" style="zoom:75%;" /> </div></li><li>响应优先级和处理优先级<ul><li>例子：假设中断系统中有4 个中断源，其响应优先级为L 1 &gt;L 2 &gt;L 3 &gt;L 44，处理优先级为L 1 &gt;L 4 &gt;L 3 &gt;L 2 。如果在主程序执行时同时发生L 1 、L 3 和L 4 中断，并且在处理L 3 中断的过程中发生L 2 中断，写出掩码字和所有中断服务程序的过程。 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/2e7130b7a0fa6de0477e56fcf4b3e74.png" alt="2e7130b7a0fa6de0477e56fcf4b3e74" style="zoom:75%;" /></div></li></ul></li><li>设备识别<ul><li>多条中断线：处理器仅仅挑选具有最高优先级的中断线<ul><li>即使有多条中断线可用，每条线上也需要采用其它三种技术中的一种</li></ul></li><li>软件轮询：模块的轮询次序就决定了模块的优先级<ul><li>轮询每一个I/O 模块来确定是哪个模块发生的中断</li></ul></li><li>菊花链：链接模块次序就决定了模块的优先级<ul><li>所有的I/O 模块共享一条中断请求线，中断应答线采用菊花链穿过这些中断模块</li></ul></li><li>独立请求：中断控制器决定<ul><li>特定的中断控制器用于解码和分析优先级</li></ul></li></ul></li></ul></li><li><p>直接存储器存取（DMA）</p><ul><li>前两种技术的不足<ul><li>I/O传送速度受处理器测试和服务设备速度的限制•</li><li>处理器负责管理I/O 传送，对于每一次I/O 传送，处理器必须执行很多指令</li></ul></li><li>直接存储器存取<ul><li>无需经过处理器即可直接访问内存的模块</li></ul></li><li>工作流程<ul><li>处理器通过发送以下信息向DMA 模块发出命令：读写、I/O 设备地址、内存中的起始位置、字数</li><li>处理器继续进行其他工作</li><li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出，而无需经过处理器</li><li>当传输完成时，DMA 模块向处理器发送一个中断信号<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221100741641.png" alt="image-20231221100741641"  /></div></li></ul></li><li>三种DMA内存访问方式<ol><li>CPU 停止法。DMA传输时，由DMA控制器发一个停止信号给CPU，使CPU脱离总线，停止访问主存，直到DMA传送一块数据结束。<ul><li>优点：控制简单 </li><li>缺点：影响CPU，没有充分利用内存</li><li>适用：高速I/O 设备的块传输  <div align="center"> <img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/a84370ae45e6e88013ce7b4d8624272.png" alt="a84370ae45e6e88013ce7b4d8624272" style="zoom:70%;" />  </div></li></ul></li><li>周期窃取。DMA传输时，CPU让出一个总线事务周期，让DMA控制器挪用一个主存周期来访问主存，传送完一个数据后立即释放总线。<ul><li>I/O设备要求DMA传送时可能遇到两种情况：<br>(1)此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时I/O访内与CPU访内没有冲突，即I/O设备挪用一二个内存周期对CPU执行程序没有任何影响。<br>(2)I/O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下I/O设备访内优先，因为I/O访内有时间要求，前一个I/O数据必须在下一个访问请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。 与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I/O设备每一次周期挪用都有申请总线控制权、建立线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个内存周期(视逻辑线路的延迟而定)。因此，周期挪用的方法适用于I/O设备读写周期大于内存存储周期的情况。</li><li>优点：充分利用CPU 和内存，及时响应I/O 请求</li><li>缺点：DMA 每次都请求总线</li><li>适用：I/O 周期大于存储周期<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/8fb767730efd92b2472c33b63b133c6.png" alt="8fb767730efd92b2472c33b63b133c6" style="zoom:70%;" /></div></li></ul></li><li>交替分时访问。每个存储周期分成两个时间片，一个给CPU，另一个给DMA控制器，止痒子啊每个存储周期内，CPU和DMA控制器都可以访问存储器。<ul><li>假设CPU工作周期为1.2us，内存存取周期小于0.6us，那么一个CPU周期可分为C1和C2两个分周期，其中C1专供DMA控制器访内，C2专供CPU访内。<br>这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时制的。CPU和DMA控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控制寄存器。在C1周期中，如果DMA控制器有访内请求，可将地址、数据等信号送到总线上。在C2周期中，如CPU有访内请求，同样传送地址、数据等信号。事实上，对于总线，这是用C1，C2控制的一个多路<a href="https://baike.baidu.com/item/转换器">转换器</a>，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。<br>这种传送方式又称为“透明的DMA”方式，其来由是这种DMA传送对CPU来说，如同透明的玻璃一般，没有任何感觉或影响。在透明的DMA方式下工作，CPU既不停止主程序的运行，也不进入等待状态，是一种高效率的工作方式。当然，相应的硬件逻辑也就更加复杂。</li><li>优点：CPU 未停止或等待，DMA 不请求总线</li><li>缺点：CPU 周期大于存储周期</li><li>参考文章： <a href="https://baike.baidu.com/item/DMA方式/8666476#:~:text=DMA传送方式有,fly传送方式。">DMA方式_百度百科 (baidu.com)</a><div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/298786ce446f461744b3f5093827592.png" alt="298786ce446f461744b3f5093827592" style="zoom:80%;" /></div></li></ul></li></ol></li><li><p>DMA配置机制</p><ol><li>单总线分离DMA<ul><li>所有模块共享相同的系统总线</li><li>DMA模块使用编程式I/O，通过DMA 模块在存储器和I/O 模块之间交换数据</li><li>便宜但低效 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104048369.png" alt="image-20231221104048369" style="zoom:100%;" /> </div></li></ul></li><li><p>单总线集合的DMA I/O</p><ul><li>DMA逻辑实际上可能是I/O 模块的一部分，也可能是控制一个或多个I/O 模块的单独模块</li><li>减少总线周期数 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104155508.png" alt="image-20231221104155508" style="zoom:100%;" /> </div></li></ul></li><li>I/O 总线<ul><li>使用I/O 总线将I/O 模块连接到DMA 模块</li><li>多个I/O 模块共享DMADMA，且易于扩展<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104241900.png" alt="image-20231221104241900" style="zoom:100%;" /></div></li></ul></li></ol></li></ul></li></ol><h3 id="I-O模块的演变"><a href="#I-O模块的演变" class="headerlink" title="I/O模块的演变"></a>I/O模块的演变</h3><ol><li>CPU直接控制外设</li><li>增加控制器或I/O 模块，CPU 使用编程式I/O，将CPU 与外围设备的细节分离</li><li>采用中断，CPU 无需花费时间等待外围设备就绪</li><li>I/O模块可通过DMA 直接存取存储器，无需CPU 负责存储器和I/O 模块之间的数据传递</li><li>I/O通道（I/O channel）：I/O 模块有自己的处理器，带有专门为I/O 操作定制的指令集<ul><li>CPU指示I/O 通道执行存储器中的I/O 指令，只有在执行完成后才会中断CPU</li></ul></li><li>I/O处理器（I/O processor）：I/O 模块有一个局部存储器，I/O 模块成为一个自治的计算机，常用于与交互式终端进行通信<ul><li>只需最少的CPU 参与即可控制大量I/O 设备</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第16讲-控制器</title>
      <link href="/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第16讲-控制器"><a href="#第16讲-控制器" class="headerlink" title="第16讲-控制器"></a>第16讲-控制器</h2><span id="more"></span><h3 id="处理器的结构"><a href="#处理器的结构" class="headerlink" title="处理器的结构"></a>处理器的结构</h3> <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/159d2db376dcaf898b1ffee596422de.png" alt="159d2db376dcaf898b1ffee596422de" style="zoom:80%;" /> </div><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ol><li>寄存器分类<ul><li>用户可见寄存器（user visible register）<ul><li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li></ul></li><li>控制和状态寄存器（control and status register）<ul><li>由控制器来控制CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li><li>大多数控制和状态寄存器在大多数机器上是用户不可见的<ul><li>某些在控制或操作系统模式下执行的机器指令是用户可见的（如程序计数器，在x86上是用户可见的）</li></ul></li></ul></li><li>两者的区分并不严格</li></ul></li><li>用户可见寄存器<ul><li>通用寄存器（general purpose register，简称GPR）<ul><li>可被程序员指派各种用途</li></ul></li><li>数据寄存器（data register）<ul><li>仅可用于保持数据而不能用于操作数地址的计算</li></ul></li><li>地址寄存器（address register）<ul><li>可以是自身有某些通用性，或是专用于某种具体的寻址方式</li><li>例如：段指针、变址寄存器、栈指针</li></ul></li><li>条件码寄存器（condition codes register）/ 标志（flag）寄存器<ul><li>CPU硬件设置这些条件位作为操作的结果</li><li>至少是部分用户可见的，但程序员不可修改 </li></ul></li><li>设计出发点<ul><li>使用完全通用的寄存器还是规定各寄存器的用途<ul><li>影响指令集的设计</li></ul></li><li>寄存器数量<ul><li>太少的寄存器会导致更多的存储器访问</li><li>太多的寄存器又不能进一步减少存储器访问</li></ul></li><li>寄存器长度<ul><li>应能保存大多数数据类型的值</li><li>某些机器允许两个相邻的寄存器作为一个寄存器来保持两倍长度的值<br>保存和恢复</li></ul></li></ul></li><li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回<ul><li>这些保存和恢复是作为调用和返回指令执行功能的一部分，由CPU 完成</li><li>这允许各个子程序独立地使用用户可见寄存器</li></ul></li><li>子程序调用之外保存用户可见寄存器的相关内容是程序员的责任，需要在程序中为此编写专门的指令</li></ul></li><li>控制和状态寄存器<ul><li>程序计数器（Program counter，PC）<ul><li>存有待取指令的地址</li><li>通常在每次取指令之后，PC 的内容即被CPU 更改，转移或跳步指令也会修改PC 的内容，因此总指向将被执行的下一条指令</li></ul></li><li>指令寄存器（Instruction register，IR）<ul><li>存有最近取来的指令，在其中分析操作码和操作数</li></ul></li><li>存储器地址寄存器（Memory address register，MAR）<ul><li>直接与地址总线相连，存有存储器位置的地址</li></ul></li><li>存储器缓冲寄存器（Memory buffer register，MBR）<ul><li>直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR 交换数据</li><li>ALU可对MBR 和用户可见寄存器直接存取</li></ul></li><li>程序状态字（Program status word，PSW）<ul><li>一个或一组包含状态信息的寄存器，包含条件码加上其他状态信息</li><li>包含的字段或标志<ul><li>符号（Sign）：容纳算术运算结果的符号位</li><li>零（Zero）：当结果是0 时被置位</li><li>进位（Carry）：若操作导致最高位有向上的进位（加法）或借位（减法）时被置位，用于多字算数运算</li><li>等于（Equal）：若逻辑比较的结果相等，则置位</li><li>溢出（Overflow）：用于表示算术溢出</li><li>中断允许、禁止：用于允许或禁止中断</li><li>监管（Supervisor）：指出CPU 是执行在监管模式中还是在用户模式中</li></ul></li></ul></li><li>一个指向含有附加状态信息的<strong>存储器块的指针寄存器</strong></li><li>在使用向量式中断的机器中，可能提供有一个<strong>中断向量寄存</strong>器</li><li>若栈用于实现某些功能，需要有一个<strong>系统栈指针</strong></li><li>对于虚拟存储器系统，会有一个<strong>页表指针寄存器</strong></li><li>设计出发点<ul><li>对操作系统的支持<ul><li>某些类型的控制信息是专门为操作系统使用的</li><li>若CPU 设计者对将要使用的操作系统有基本的了解，则寄存器的组织可能在一定程度上为该操作系统定制</li></ul></li><li>控制信息在寄存器和存储器之间的分配<ul><li>一种普遍的做法是将存储器最前面（最低地址）的几百或几千个字用于控制目的</li><li>在成本和速度之间进行权衡</li></ul></li></ul></li></ul></li><li><p>X86体系结构：8086 的寄存器<br><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132120995.png" alt="image-20231220132120995" style="zoom:80%;" /></div></p><ul><li>数据寄存器<ul><li>均为16 位寄存器</li><li>均可分为2 个8 位寄存器使用</li><li>AX：存放乘除等指令的操作数</li><li>BX：存放存储单元的偏移地址</li><li>CX：存放计数值</li><li>DX：乘法运算产生的部分积、除法运算的部分被除数</li></ul></li><li>地址寄存器<ul><li>均为16 位寄存器</li><li>SP和BP：用于堆栈操作</li><li>SI和DI：用于串操作</li><li>均可以作为数据寄存器使用</li></ul></li></ul><p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132333535.png" alt="image-20231220132333535" style="zoom:80%;" /> </div></p><ul><li>段寄存器<ul><li>与其他寄存器联合生成物理地址</li><li>CS：代码段寄存器</li><li>DS：数据段寄存器</li><li>SS：堆栈段寄存器</li><li>ES：附加段寄存器</li></ul></li></ul><p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132529694.png" alt="image-20231220132529694" style="zoom:80%;" /></div><br><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/a98267b33b6de82524a46699609271c.png" alt="a98267b33b6de82524a46699609271c" style="zoom:75%;" /> </div></p><ul><li>标志寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/879813df371ed8f7a172acb422b3377.png" alt="879813df371ed8f7a172acb422b3377" style="zoom:60%;" /></div></li><li>指令寄存器<ul><li>保存一个内存地址，指向当前需要取出的指令</li><li>当CPU 从内存中取出一个指令后，IP 会自增，指向下一个地址</li><li>程序员不能直接对IP 进行存取操作</li><li>转移指令、过程调用指令等会改变IP 中的内容</li><li>IP寄存器有16 位，但8086 的寻址范围是2<sup>20</sup></li></ul></li></ul></li><li>X86体系结构：IA-32 的寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/84cbee4bf7fca2f59ecf2c290687b9b.png" alt="84cbee4bf7fca2f59ecf2c290687b9b" style="zoom:75%;" /></div></li><li>X86体系结构：X86-64 的寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/1bf804873e92d9966e394d43dadfb6e.png" alt="1bf804873e92d9966e394d43dadfb6e" style="zoom:55%;" /></div></li></ol><h3 id="微操作（micro-operation）"><a href="#微操作（micro-operation）" class="headerlink" title="微操作（micro operation）"></a>微操作（micro operation）</h3><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令。<br>每个指令周期又可以看作是由几个更小的子周期组成，包括：取指、间址、执行、中断。<br>每个子周期由一系列涉及CPU 寄存器操作的更小步骤组成，这些步骤称为微操作。<br> <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220133317380.png" alt="image-20231220133317380" style="zoom:80%;" /> </div></p><ol><li>微操作分组的原则<ul><li>事件的流动顺序必须是恰当的<ul><li>例：MAR &lt;- (PC） 必须先于MBR &lt;- 内存，因为内存读操作要使用MAR 中的地址</li></ul></li><li>必须避免冲突<ul><li>例：MBR &lt;- 内存 和 IR &lt;- MBR 这两个微操作不应出现在同一时间单位里</li></ul></li><li>满足上述条件下，所用的时间单位尽可能少<ul><li>例：PC &lt;- (PC）+ I 不能放在一个单独的时间单位里</li></ul></li></ul></li><li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/8170971f8956fa2ab32ed61f66e85f1.png" alt="8170971f8956fa2ab32ed61f66e85f1" style="zoom:75%;" /></div></li><li><p>间址周期</p><ul><li>如果指令采用间接寻址，则在指令执行前有一个间址周期</li><li>完成间址周期后，IR 的状态与不使用间接寻址方式的状态是相同的，已经为执行周期准备就绪<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134053680.png" alt="image-20231220134053680" style="zoom:80%;" /></div></li></ul></li><li><p>执行周期</p><ul><li>对于不同的操作码，会出现不同的微操作序列<ul><li>例：加法指令 ADD R1， X<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134400626.png" alt="image-20231220134400626" style="zoom:50%;" /></div></li><li>例：“转移并保存地址”指令 BSA X<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134431005.png" alt="image-20231220134431005" style="zoom:50%;" /></div></li></ul></li></ul></li><li><p>中断周期</p><ul><li>在完成执行周期时，要确定是否有允许的中断产生。如果有，则出现一个中断周期。<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/c41b7b0c19abbce5b6ec9238e867795.png" alt="c41b7b0c19abbce5b6ec9238e867795" style="zoom:75%;" /></div></li></ul></li></ol><h3 id="指令周期代码（Instruction-Cycle-Code，ICC）"><a href="#指令周期代码（Instruction-Cycle-Code，ICC）" class="headerlink" title="指令周期代码（Instruction Cycle Code，ICC）"></a>指令周期代码（Instruction Cycle Code，ICC）</h3><p>取指、间址、中断周期各有一个微操作序列，执行周期则对于每个操作码有一个微操作序列<br>指令周期代码：假设一个2 位的ICC 寄存器，明确CPU 处于指令周期哪个阶段</p><ul><li>00：取指</li><li>01：间址</li><li>10：执行</li><li>11：中断<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134822899.png" alt="image-20231220134822899" style="zoom:67%;" /></div></li></ul><h3 id="处理器的控制"><a href="#处理器的控制" class="headerlink" title="处理器的控制"></a>处理器的控制</h3><ol><li>控制CPU 的功能需求<ul><li>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</li><li>CPU需要完成的四类微操作<ul><li>在寄存器之间传送数据</li><li>将数据由寄存器传送到外部接口（如系统总线）</li><li>将数据由外部接口传送到寄存器</li><li>将寄存器作为输入和输出，完成算术和逻辑运算</li></ul></li><li>控制器的两个基本任务<ul><li>定序（sequencing）：根据正被执行的程序，控制器使CPU 以正确的顺序通过一系列微操作</li><li>执行（execution）：控制器使每个微操作得以完成</li></ul></li></ul></li><li>控制器的输入<ul><li>指令寄存器：当前指令的寻址方式和操作码</li><li>标志：确定CPU 的状态和前一个ALU 操作的结果</li><li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li><li>来自控制总线的控制信号：向控制器提供控制信号<ul><li>例：中断请求</li></ul></li></ul></li><li><p>控制器的输出(所有的控制信号最终作为二进制输入量直接输入到各个逻辑门上)</p><ul><li>CPU内的控制信号：<ul><li>用于寄存器之间传送数据</li><li>用于启动特定的ALU 功能</li></ul></li><li>到控制总线的控制信号：<ul><li>到存储器的控制信号</li><li>到I/O 模块的控制信号<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220135810119.png" alt="image-20231220135810119" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>控制信号示例：取指周期</p><ul><li>传送PC 的内容到MAR<ul><li>打开C<sub>2</sub>：PC 传到MAR</li></ul></li><li>由存储器读一条指令装入MBR，并且递增PC<ul><li>打开C<sub>0</sub>：MAR 的内容送到地址总线上</li><li>存储器读控制信号C<sub>R</sub> 送到控制总线上</li><li>打开C<sub>5</sub>：数据总线上的内容存入MBR</li><li>控制信号对PC 内容加1（指令长度）并把结果存回PC</li></ul></li><li>传送MBR 的内容到IR<ul><li>打开C<sub>4</sub>：MBR 的内容送到IR<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140501106.png" alt="image-20231220140501106" style="zoom:80%;" /></div><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140046430.png" alt="image-20231220140046430" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>控制器的最小特性</p><ul><li>它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出等），而不需要知道正被处理的数据或得到的实际结果具体是什么</li><li>它只是以少量的送到CPU 内的和送到系统总线上的控制信号来实现控制</li></ul></li><li>CPU内部总线<ul><li>ALU和寄存器都连接到CPU 内部总线上</li><li>为了数据在该内部总线和各寄存器之间传递，内部总线和寄存器之间有门和控制信号</li><li>控制线控制着数据和系统总线（外部）的交换以及ALU 的操作<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140649190.png" alt="image-20231220140649190" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="控制器实现"><a href="#控制器实现" class="headerlink" title="控制器实现"></a>控制器实现</h3><ol><li>硬布线实现（hardwired implementation）：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号。<ol><li>控制器输入<ul><li>标志和控制总线信号<ul><li>每位都有特定的意义</li></ul></li><li>指令寄存器<ul><li>通过译码，使每一操作码有一个唯一的逻辑输入</li><li>译码器有n 个输入和2<sup>n</sup> 个输出<ul><li>控制器要考虑变长的操作码，译码器会更复杂些<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/c9fb6a931cd3ffe6bbc2b4378740242.png" alt="c9fb6a931cd3ffe6bbc2b4378740242" style="zoom:75%;" /></div></li></ul></li></ul></li><li>时钟<ul><li>在一个指令周期内，控制器要在不同时间单位发送不同的控制信号</li><li>使用一个定时器作为控制器的输入，并且控制器在指令周期（或子周期）结束时必须通知定时器以使其重新开始计数  <div align="center"> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220141820407.png" alt="image-20231220141820407" style="zoom:80%;" />  </div></li></ul></li></ul></li><li>控制器逻辑<ul><li>为每个输出的控制信号设计一个关于控制器输入的布尔表达式</li><li>定义两个新的控制信号P 和Q<ul><li>PQ=00：取指周期，</li><li>PQ=01：间址周期，</li><li>PQ=10：执行周期，</li><li>PQ=11：中断周期</li><li>示例：控制信号C5：使外部数据总线上的数据读入MBRC5<ul><li>在取指和间址周期的第二个时间单位（T<sub>2</sub>）有效<script type="math/tex; mode=display">C_{5} = \overline{P} \cdot \overline{Q} \cdot T_2 +  \overline{P} \cdot Q \cdot T_2</script></li><li>C5在执行周期也需要<script type="math/tex; mode=display">C_{5} = \overline{P} \cdot \overline{Q} \cdot T_2 +  \overline{P} \cdot Q \cdot T_2+P \cdot \overline{Q} \cdot (LDA + ADD+AND) \cdot T_2</script></li></ul></li></ul></li></ul></li></ol></li><li>微程序实现（microprogrammed implementation）：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号<ol><li>基本概念和思路<ul><li>微程序（固件）介于硬件与软件之间<ul><li>设计固件比设计硬件容易，但写固件程序比软件程序困难</li><li>微指令序列</li></ul></li><li>微指令：每行描述同一个时间内出现的一组微操作</li><li>基本思路<ul><li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li><li>构造一个控制字，每位代表一根控制线，这样每个微操作能用控制字中的不同的0 和1 的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li><li>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址<ul><li>添加少数几位用于指示条件的真假<ul><li>若条件位指示的条件为假，则顺序执行下一条指令</li><li>若条件位指示的条件为真，则地址字段指向的微指令是将被执行的下一条微指令</li></ul></li><li>给每个控制字添加一个地址字段，以指示某种条件为真时，将要执行的下一控制字的位置<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220143136049.png" alt="image-20231220143136049" style="zoom:80%;" /></div></li></ul></li></ul></li></ul></li><li>微程序执行<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220144027678.png" alt="image-20231220144027678" style="zoom:80%;" /></div></li><li>微程序控制器：任务<ul><li>微指令定序（microinstruction sequencing）<ul><li>根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器地址</li><li>设计考虑<ul><li>微指令的大小：减小微指令的大小就能节省控制存储器的成本</li><li>地址生成时间：尽可能快地执行微指令</li></ul></li></ul></li><li>微指令执行（microinstruction execution）<ul><li>产生控制信号：发往CPU 内部，送往外部控制总线或其他外部接口<ul><li>根据微指令中的二进制序列，设置控制线</li></ul></li></ul></li></ul></li><li>微程序控制器：构成<ul><li>定序逻辑：向控制地址寄存器装入地址，并发出读命令</li><li>控制地址寄存器：含有下面即将被读取的微指令地址</li><li>控制存储器：存有一组微指令</li><li>控制缓冲寄存器：存放被读出的微指令<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220144608050.png" alt="image-20231220144608050" style="zoom:67%;" /></div></li></ul></li><li>微程序控制器：定序<ul><li>双地址字段：在每条微指令中提供两个地址字段，选择并发送其中某一个地址或操作码到控制地址寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150149393.png" alt="image-20231220150149393" style="zoom:80%;" /></div></li><li>单地址字段：下一个地址的选择可以是地址字段或下一个顺序地址<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150218707.png" alt="image-20231220150218707" style="zoom:80%;" /></div></li><li>可变格式：提供两种完全不同的指令格式，一位字段用于指定哪种格式被使用 <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150243984.png" alt="image-20231220150243984" style="zoom:80%;" /> </div></li></ul></li><li>微程序控制器：工作流程<ul><li>执行一条指令，定序逻辑发出一个读命令给控制存储器</li><li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li><li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息<ul><li>控制缓冲寄存器的左半部分与控制器发出的控制线相连</li><li>由控制存储器读一条微指令等同于执行这条微指令</li></ul></li><li>定序逻辑根据这个地址信息和ALU 标志，将新的地址装入到控制地址寄存器</li><li>生成新地址的三个选择<ul><li>取顺序下一条微指令：加1 到控制地址寄存器</li><li>基于跳转微指令转移到一个新的例程：将控制缓冲寄存器的地址字段装入控制地址寄存器</li><li>转移到一个机器指令例程：根据IR 中的操作码向控制地址寄存器装入机器指令例程的第一条微指令<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220145030079.png" alt="image-20231220145030079" style="zoom:80%;" /></div></li></ul></li></ul></li><li>优点<ul><li>简化了控制器的设计任务</li><li>实现起来既成本较低，也能减少出错机会</li><li>便于更新</li></ul></li><li>缺点<ul><li>要比采用相同或相近半导体工艺的硬布线控制器慢一些</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第15讲-指令周期和指令流水线</title>
      <link href="/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第15讲-指令周期和指令流水线"><a href="#第15讲-指令周期和指令流水线" class="headerlink" title="第15讲-指令周期和指令流水线"></a>第15讲-指令周期和指令流水线</h2><span id="more"></span><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ol><li>指令周期：处理单个指令的过程（时间）<ul><li>取指周期：从内存中提取一条指令</li><li>执行周期：执行所提取的指令</li></ul></li><li>只有当机器关闭、发生某种不可恢复的错误或遇到停止计算机的程序指令时，程序执行才会停止 <div align="center"> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/48592052bac3099b3b2b6a6bc730825.png" alt="48592052bac3099b3b2b6a6bc730825" style="zoom:80%;" /> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219140509286.png" alt="image-20231219140509286" style="zoom:80%;" /> </div></li><li>间址周期<ul><li>指令的执行可能涉及一个或多个存储器中的操作数，它们每个都要求一次存储器访问</li><li>使用间接寻址，还需要额外的存储器访问</li><li>间址周期：把间接地址的读取看成是一个额外的指令子周期<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/80fffef1906b6d92b4b7840982879dc.png" alt="80fffef1906b6d92b4b7840982879dc" style="zoom:80%;" />     </div></li><li>取操作数发生了2次</li></ul></li><li>CPU的任务<ul><li>取指令：CPU 必须从存储器（寄存器、cache 、主存）读取指令</li><li>解释指令：必须对指令进行译码，以确定所要求的动作</li><li>取数据：指令的执行可能要求从存储器或输入/输出（I/O）模块中读取数据</li><li>处理数据：指令的执行可能要求对数据完成某些算术或逻辑运算</li><li>写数据：执行的结果可能要求写数据到存储器或I/O 模块</li></ul></li><li>CPU需求：寄存器<ul><li>CPU需要在指令周期中临时保存指令和数据</li><li>CPU需要记录当前所执行指令的位置，以便知道从何处得到下一条指令</li><li>CPU需要一些小容量的内部存储器<ul><li>假定CPU 有：<ul><li>1个存储地址寄存器（MAR）</li><li>1个存储缓冲寄存器（MBR）/ 存储数据寄存器（MDR）</li><li>1个程序计数器（PC）</li><li>1个指令寄存器（IR）</li></ul></li></ul></li></ul></li></ol><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ol><li>流水处理（pipelining）：如果一个产品要经过几个制作步骤，通过把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</li><li>指令流水线：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/715d9b03a17c0ee53abc1a1de3ef71b.png" alt="715d9b03a17c0ee53abc1a1de3ef71b" style="zoom: 80%;" /></div></li><li>两阶段方法<ul><li>将指令处理分成两个阶段：取指令和执行指令</li><li>在当前指令的执行期间取下一条指令</li><li>问题：执行时间一般要长于取指时间</li><li>更多问题<ul><li>主存访问冲突</li><li>条件分支指令使得待取的下一条指令的地址是未知的<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219142441603.png" alt="image-20231219142441603" style="zoom:80%;" /></div></li></ul></li></ul><ol><li>六阶段方法<ul><li>为了进一步的加速，流水线必须有更多的阶段<ul><li>取指令（Fetch instruction，FI）：读下一条预期的指令到缓冲器</li><li>译码指令（Decode instruction，DI）：确定操作码和操作数指定符</li><li>计算操作数（Calculate operands，CO）：计算每个源操作数的有效地址</li><li>取操作数（Fetch operands，FO）：从存储器取出每个操作数，寄存器中的操作数不需要取</li><li>执行指令（Execute instruction，EI）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li><li>写操作数（Write operand，WO）：将结果存入存储器</li></ul></li><li>各个阶段所需要的时间几乎是相等的 </li><li>例：将9 条指令的执行时间由54 个时间单位减少到14 个时间单位 <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219142859800.png" alt="image-20231219142859800" style="zoom:80%;" />   </div></li><li>问题：   <ul><li>不是所有指令都包含6 个阶段<ul><li>例：一条LOAD 指令不需要WO 阶段</li><li>为了简化流水线硬件设计，在假定每条指令都要求这6 个阶段的基础上来建立时序</li></ul></li><li>不是所有的阶段都能并行完成<ul><li>例：FI 、FO 和WO 都涉及存储器访问</li></ul></li><li>若6 个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待   </li></ul></li><li>限制：条件转移指令能使若干指令的读取变为无效   </li><li>限制：中断，提前处理到一半的过程都需要被清除   <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219143134538.png" alt="image-20231219143134538" style="zoom:80%;" /></div></li></ul></li></ol></li><li>超流水线（Super pipelining）<ul><li>将六级流水线细分为更多的阶段，增加流水线的深度</li><li>提升时钟频率，从而提高指令吞吐率</li></ul></li></ol><div align="center">   <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219143425956.png" alt="image-20231219143425956" style="zoom:50%; align:center" /></div>5. 流水线性能   - 假设     - 𝑡<sub>𝑖</sub> : 流水线第𝑖 段的电路延迟时间     - 𝑡<sub>𝑚</sub> : 最大段延迟（通过耗时最长段的延迟）     - 𝑘: 指令流水线段数     - 𝑑: 锁存延时（数据和信号从上一段送到下一段所需的段间锁存接收时间）   - 周期时间𝑡 = max[𝑡<sub> 𝑖</sub>] + 𝑑 = 𝑡<sub>𝑚</sub> + 𝑑   - 令𝑇<sub>𝑘,𝑛</sub> 为k 阶段流水线执行所有n 条指令所需的总时间       𝑇<sub>𝑘,n</sub> = [𝑘 + (𝑛 - 1)] 𝑡   - 加速比       $$       S_{k}=\frac{T_{1,n}}{T_{k,n}}=\frac{nkt}{[k+(n-1)]t}=\frac{nk}{k+(n-1)}=\frac{n}{1 + \frac{n-1}{k}}>1       $$   - 超标量流水线（Superscalar）   - 超标量结构：具有两条或两条以上并行工作的流水线结构   - 单周期→标量流水线： 时间并行性的优化， 主要是对现有硬件的分段   - 标量流水线→超标量流水线： 空间并行性的优化， 需成倍增加硬件资源   - 多核CPU：一个CPU 芯片中集成多个超标量处理器核<div align="center">   <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219151828703.png" alt="image-20231219151828703" style="zoom:80%;" /></div><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ol><li>在某些情况下，指令流水线会阻塞或停顿（stall），导致后续指令无法正确执行</li><li><p>类型</p><ul><li>结构冒险（Structure hazard）/ 硬件资源冲突<ul><li>不同指令同时使用相同的硬件资源，比如访存</li></ul></li><li>数据冒险（Data hazard）/ 数据依赖性<ul><li>有些数据要等前序计算完成</li></ul></li><li>控制冒险（Control hazard）<ul><li>比如条件转移</li></ul></li></ul></li><li><p>结构冒险</p><ul><li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152258334.png" alt="image-20231219152258334" style="zoom:80%;" /></div>- 解决方案1：流水线停顿（stall），插入空泡（bubble）<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152427936.png" alt="image-20231219152427936" style="zoom:67%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152432931.png" alt="image-20231219152432931" style="zoom:67%;" /></div>- 解决方案2：使用不同用途的多个存储器  - 例如：指令和数据放在不同的Cache 中- 解决方案3：同一个存储器提供分时处理  - 例如：寄存器时钟上升沿写，时钟下降沿读<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/fc45d97588adcaeda9c26bafb53be84.png" alt="fc45d97588adcaeda9c26bafb53be84" style="zoom:67%;" /></div></li></ul></li><li><p>数据冒险</p><ul><li>原因：未生成指令所需要的数据</li><li>例如：一条指令需要使用之前指令的运算结果，但是结果还没有写回   <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153222041.png" alt="image-20231219153222041" style="zoom:67%;" /></div>   </li><li>解决方案1：插入nop 指令（软件）<ul><li>问题：如果计算机的结构发生了变化，需要更新软件<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153644429.png" alt="image-20231219153644429" style="zoom:67%;" /></div></li></ul></li><li>解决方案2：插入bubble（硬件）   <ul><li>问题：效率低下，流水线失去意义<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153957794.png" alt="image-20231219153957794" style="zoom:67%;" /></div></li></ul></li><li>解决方案3：前递（forwarding）/ 旁路（bypassing）   <ul><li>无法解决：一条指令需要使用之前指令的访存结果 Load Use Harzard )（下面第二张图）<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154410789.png" alt="image-20231219154410789" style="zoom:67%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154654582.png" alt="image-20231219154654582" style="zoom:67%;" /></div>   </li></ul></li><li>解决方案4：交换指令顺序<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154940755.png" alt="image-20231219154940755" style="zoom:80%;" /></div></li></ul></li><li>控制冒险<ul><li>原因：指令的执行顺序被更改<ul><li>转移（Transfer）: 分支（branch）, 循环（loop）,</li><li>中断（Interrupt）</li><li>异常（Exception）</li><li>调用/ 返回（Call / return）</li></ul></li><li>影响：<ul><li>转移指令占比15%～25%（平均每隔4～7 条指令）</li><li>转移平均损失10 个周期</li><li>流水线越深，超标量数越多，转移指令的影响越大</li></ul></li><li>解决方案1：取多条指令<ul><li>多个指令流：复制流水线的开始部分，并允许流水线同时取这两条指令，使用两个指令流</li><li>预取分支目标：识别出一个条件分支指令时，除了取此分支指令之后的指令外，分支目标处的指令也被取来</li><li>循环缓冲器：由流水线指令取指阶段维护的一个小的但极高速的存储器，含有n 条最近顺序取来的指令</li></ul></li><li>解决方案2：分支预测<ul><li>静态预测（规则不变）<ul><li>预测绝不发生跳转</li><li>预测总是发生跳转</li><li>依操作码预测</li></ul></li><li>动态预测（规则变化）<ul><li>发生/ 不发生切换</li><li>转移历史表</li><li>仅在连续发生两次错误时改变状态<ul><li>例如：有一个双层循环，当内循环进行时，总是预测不跳转，最后一次预测错误。如果一次预测错误就切换，那么下一次进入内循环时会预测跳转，然而实际发生跳转，导致两次预测错误。如果一次错误不切换，只有两次错误才切换，那么内循环结束时仍是预测不跳转，下一次进入内循环将会预测正确，总共只有一个错误预测。<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219161159576.png" alt="image-20231219161159576" style="zoom:50%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219161210117.png" alt="image-20231219161210117" style="zoom:50%;" /></div></li></ul></li><li>转移历史表<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219162033073.png" alt="image-20231219162033073" style="zoom:80%;" /></div></li></ul></li></ul></li><li>解决方案3：提前判断<ul><li>直接无条件转移：例如j Target<ul><li>在取指阶段即可获得转移目标地址（流水线不停顿）</li></ul></li><li>间接无条件转移：例如 jr \$r1<ul><li>在译码阶段才能获得转移目标地址（流水线停顿1 周期）</li></ul></li><li>直接有条件转移：例如 beq \$r1, \$r2, Target<ul><li>在执行阶段才能获得转移目标地址（流水线停顿2 周期）</li><li>在寄存器堆输出端增加额外的比较电路（流水线停顿1 周期）</li></ul></li></ul></li><li>解决方案4：交换指令顺序<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219163122385.png" alt="image-20231219163122385" style="zoom:50%;" /></div></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20231217周记</title>
      <link href="/2023/12/17/20231217%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/17/20231217%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>期末周临近，最近也开始复习了。而且越复习越发现不懂的东西还有很多。。。所以期末考试之前算法的学习应该会暂时放一放啦。但是每天刷三道题还要继续保持。</p><span id="more"></span><p>本来想着为了计组机考，这周复习一下Java的，结果发现用Java刷力扣还是有点难受，主要是自己不熟悉库。以后再花点时间深入学习一下Java吧。虽然没有复习Java，但应付计组机考还是挺轻松的。</p><p>CSP的成绩出来了。作为第一次考的成绩，虽然没到预期，也算还行吧。</p><p><img src="03280f37bdedeefd8c2c6f91b864a95.png" alt="03280f37bdedeefd8c2c6f91b864a95"></p><p>这周没什么好记录的了，下周也要努力复习啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第14讲-指令系统</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="第14讲-指令系统"><a href="#第14讲-指令系统" class="headerlink" title="第14讲-指令系统"></a>第14讲-指令系统</h2><span id="more"></span><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li>指令的要素<ul><li>操作码：指定将要完成的操作</li><li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li><li>结果操作数引用：操作可能会产生一个结果</li><li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li></ul></li><li>指令表示<ul><li>在计算机内部，指令由一个位串来表示</li><li>指令格式：对应于指令的各要素，这个位串划分成几个字段<ul><li>大多数指令集使用不止一种指令格式</li></ul></li><li>机器指令符号表示法：<ul><li>操作码被缩写成助记符来表示<ul><li>MUL：乘，DIVDIV：除，LOAD：由存储器装入，STOR：保存到存储器</li></ul></li><li>操作数也可以用符号表示<ul><li>用寄存器编号或内存地址替换操作数<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215224433079.png" /></div></li></ul></li></ul></li></ul></li><li>指令格式<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/651034a6bb34e059875eb0098f8a0bd.png" alt="651034a6bb34e059875eb0098f8a0bd" style="zoom:70%;" /></div><ul><li>定长操作码：𝒏位操作码字段的指令系统最大能够表示𝟐 <sup>𝒏</sup> 条指令</li><li>可变长操作码<ul><li>扩展操作码：不同地址数的指令具有不同长度的操作码<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/31163908f89f4a44c5f0ff6053d7b3d.png" /></div><br>15条三地址指令操作码：0 0 0 0 ~ 1 1 1 0<br>15条二地址指令操作码：1 1 1 1 0 0 0 0 ~ 1 1 1 1 1 1 1 0<br>15条一地址指令操作码：1 1 1 1 1 1 1 1 0 0 0 0 ~ 1 1 1 1 1 1 1 1 1 1 1 0</li></ul></li><li>指令格式通过它的各个构成部分来定义指令的位安排</li><li>一个指令格式必须包含一个操作码，以及隐式或显式的、零个或多个操作数</li><li>指令格式必须显式或隐式地为每个操作数指定其寻址方式</li><li>大多数指令集使用不止一种指令格式 </li><li>例题：假设指令字长为16 位，操作数的地址码为6 位，指令有零地址、一地址、二地址3 种格式。<ul><li>设操作码固定，若零地址指令有M 种，一地址指令有N 种，则二地址指令最多有几种？<br>操作码位数：16 - 6 - 6 = 4<br>总指令条数：2^4 = 16<br>二地址指令最多：16 - M - N</li><li>采用扩展操作码技术，二地址指令最多有几种？<br>0000 ~ 1110</li><li>采用扩展操作码技术，若二地址指令有P 条，零地址指令有Q 条，则一地址指令最多有几种？<br>$𝑄=[(2^4-𝑃) × 2^6-𝑅] × 2^6$</li></ul></li></ul></li><li>操作码<ul><li>差异：不同的计算机上操作码的数目变动是很大的</li><li>共性：所有计算机上都会存在相同的常用操作类型</li><li>数据传送<ul><li>指明源和目标操作数的位置</li><li>指明将要传送数据的长度</li><li>指明每个操作数的寻址方式<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225455850.png" alt="image-20231215225455850" style="zoom:80%;" /></div></li></ul></li><li>算术运算<ul><li>一条算术指令的执行会涉及数据传送操作，来为算术和逻辑单元准备输入，并传送逻辑单元的输出<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225551293.png" alt="image-20231215225551293" style="zoom:80%;" /></div></li></ul></li><li>逻辑运算</li><li>位操作：操作一个字或其它可寻址单元的中的个别位</li><li>移位和旋转<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225656478.png" alt="image-20231215225656478" style="zoom:80%;" /></div></li><li>输入/输出<ul><li>各种输入/输出方法仅有少数输入/输出指令实现，具体操作由参数、代码或命令字指定<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225740670.png" alt="image-20231215225740670" style="zoom:80%;" /></div></li></ul></li><li>控制转移<ul><li>分支指令（亦称为跳转指令）：把将要执行的下一条指令的地址作为它的操作数之一</li><li>跳步指令：包含一个隐含地址，该隐含地址等于下一指令地址加上该指令长度之和</li><li>过程调用指令：涉及由目前位置转移到过程的调用指令和由过程返回到调用发生位置的返回指令<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225810362.png" alt="image-20231215225810362" style="zoom:70%;" /></div></li></ul></li></ul></li><li>操作数<ul><li>常见类型：地址、数值、字符、逻辑数据</li><li>地址<ul><li>一个指令需要有4 个地址引用：2 个源操作数，1 个目的操作数，以及下一指令地址<ul><li>下一指令地址可以是隐含的</li><li>源操作数可以和目的操作数是相同的</li></ul></li><li>地址数量<ul><li>每条指令中的地址数目越少<ul><li>指令的长度越短，不需要复杂的CPU</li><li>使程序总的指令条数更多，导致执行时间更长，程序也更长更复杂 </li></ul></li><li>对于多地址指令，普遍具有多个通用寄存器可用，允许某些运算只使用寄存器即可完成，从而使执行加快 </li></ul></li></ul></li><li>数值<ul><li>计算机存储的数值是受限的<ul><li>机器可表示数值的幅值是有限的</li><li>浮点数情况下数值精度是有限的</li></ul></li><li>数值数据的类型<ul><li>二进制整数或定点数</li><li>二进制浮点数</li><li>十进制数</li></ul></li></ul></li><li>字符<ul><li>国际参考字母表（IRA）/ 美国信息交换标准码（ASCII）：每个字符被表示成唯一的7 位二进制串</li><li>扩展的二进制编码的十进制交换码（EBCDIC）：8 位编码</li><li>统一码（Unicode）：16 位/ 32 位</li></ul></li><li>逻辑数据<ul><li>将一个n 位单元看成是由n 个1 位项组成，每项有值0 或1<ul><li>存储一个布尔或者二进制数据项序列，序列中的每个值只能取值1（真）或0（假）</li><li>有利于实现对数据项的具体位进行操纵</li></ul></li></ul></li><li>大端序和小端序<ul><li>假设有32 位的十六进制值1234567812345678，将它存储在可字节寻址的存储器地址184 处<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/521f09061e51fd9fb6ac72c325b2545.png" alt="521f09061e51fd9fb6ac72c325b2545" style="zoom:75%;" /></div></li><li>在两种策略中每个数据项有同样地址（范围）</li><li>在任何一个给定的多字节值中，小端的字节排序是大端的反序，反之亦然</li><li>端序不影响结构中数据项的次序</li></ul></li></ul></li><li>寻址方式<ul><li>立即寻址<ul><li>方式：操作数实际值出现在指令中</li><li>用法：定义和使用常数或设置变量的初始值</li><li>算法：操作数= A</li><li>优点：快，除了取指令之外，获得操作数不要求另外的存储器访问</li><li>缺点：数的大小受限于地址字段的长度</li></ul></li><li>直接寻址<ul><li>方式：地址字段含有操作数的有效地址</li><li>用法：早期计算机常用，在当代计算机体系结构中不多见</li><li>算法：EA = A</li><li>优点：只要求1 次存储器访问，且无需为生成地址而专门计算</li><li>缺点：有限的地址空间<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/bd7ded68154fce663598c44ebafe185.png" alt="bd7ded68154fce663598c44ebafe185" style="zoom:75%;" /></div></li></ul></li><li>间接寻址<ul><li>方式：地址字段指示一个存储器字地址, 而此地址出保存有操作数的全长度地址</li><li>算法：EA = (A)</li><li>优点：扩大了地址空间</li><li>缺点：取操作数需要2 次访问存储器</li><li>解释：地址引用的数量限制可能是有益的<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/eeda2a141f785936e4bb0bcb8d753a3.png" alt="eeda2a141f785936e4bb0bcb8d753a3" style="zoom:75%;" /></div></li></ul></li><li>寄存器寻址<ul><li>方式：地址字段指示的是寄存器</li><li>算法：EA = R</li><li>优点：指令中仅需要一个较小的地址字段, 且不需要存储器访问</li><li>缺点：地址空间十分有限</li><li>解释：寄存器寻址只有在被有效使用的时候才有意义<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/7ba579c2a8dcf17e84bb69ea3c44ef4.png" alt="7ba579c2a8dcf17e84bb69ea3c44ef4" style="zoom:75%;" /></div></li></ul></li><li>寄存器间接寻址<ul><li>方式：地址字段指示寄存器</li><li>算法：EA = (R)</li><li>优点：扩大了地址空间，比间接寻址少1 次存储器访问</li><li>缺点：相对于寄存器寻址，需要多1 次存储器访问<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/b4e7fe96b05afc5716beeebe605ea5d.png" alt="b4e7fe96b05afc5716beeebe605ea5d" style="zoom:75%;" /> </div></li></ul></li><li>偏移寻址<ul><li>方式：结合直接寻址和寄存器间接寻址能力</li><li>算法：EA = (R) + A</li><li>类型<ul><li>相对寻址<ul><li>方式：隐含引用的寄存器是程序计数器（PC）</li><li>此指令后续的下一条指令的地址加上地址字段的值产生有效地址</li><li>用法：大多数存储器访问都相对靠近正在执行的指令，相对寻址可节省指令中的地址位数；可用于转移控制指令。</li><li>算法：EA = (PC) + A</li><li>优点：利用程序局部性原理，节省指令中地址的位数<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/5631d9890ccaab93238948c8af96873.png" alt="5631d9890ccaab93238948c8af96873" style="zoom:75%;" /></div></li></ul></li><li>基址寄存器寻址<ul><li>方式：被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地址的偏移量（通常是无符号整数表示）</li><li>寄存器引用可以是显式的，也可以是隐式的</li><li>算法：EA = (B) + A</li><li>用法：虚拟内存空间中的程序重定位<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/c8d29de812d20e07ed79cab5deca558.png" alt="c8d29de812d20e07ed79cab5deca558" style="zoom:75%;" /></div></li></ul></li><li>变址寻址<ul><li>方式：指令地址字段引用一个主存地址，被引用的寄存器含有对于该地址的一个正的偏移量</li><li>算法：EA = A + (IX)</li><li>用法：为完成重复操作提供一种高效机制</li><li>扩展：结合间接寻址和变址寻址<ul><li>前变址：EA = (A + IX ))；后变址：EA = (A) + IX<div align="center"> <img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/58df44c9b28ef764dbaf9d242d94406.png" alt="58df44c9b28ef764dbaf9d242d94406" style="zoom:75%;" /></div></li></ul></li></ul></li><li>栈寻址<ul><li>方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li><li>解释：与栈相关的是一个指针，它的值是栈顶地址，或者当栈顶的两个元素已在CPU 寄存器内，此时栈顶指针指向栈顶的第三个元素<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/ad44b934e146b4ccb0694ef4faec0b0.png" alt="ad44b934e146b4ccb0694ef4faec0b0" style="zoom:75%;" /></div><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3></li></ul></li></ul></li></ul></li></ul></li><li>指令格式的设计原则<ul><li>指令尽量短<ul><li>程序占用存储空间小</li></ul></li><li>有足够的操作码位数<ul><li>要为操作类型不断增加预留</li></ul></li><li>操作码的编码必须有唯一的解释<ul><li>操作码译码时要么是唯一的合法编码，要么是不合法的</li></ul></li><li>指令长度是字节的整数倍<ul><li>与内存按照字节寻址相对应，便于指令的读取和地址计算</li></ul></li><li>合理选择地址字段的个数<ul><li>涉及到指令长度和规整性，是空间和时间开销权衡的结果</li></ul></li><li>指令尽量规整<ul><li>简化硬件的实现</li></ul></li></ul></li><li>指令长度<ul><li>最明显的权衡考虑是在强有力的指令清单和节省空间之间进行</li><li>编程人员希望更多的操作码、更多的操作数、更多的寻址方式和更大的地址范围</li><li>指令长度变短可以节省存储空间和减少数据传送时间</li><li>指令长度应该是字符长度或定点数长度的整数倍（比如n 个字节）</li><li>指令长度应该等于存储器的传送长度（即数据总线宽度），或者这两个值其中之一是另一个的整数倍</li></ul></li><li>位的分配<ul><li>对于给定的指令长度，在操作码数目和寻址能力之间存在着权衡考虑</li><li>使用变长的操作码<ul><li>使用一个最小操作码长度，但是对于某些操作码，可通过使用指令附加位的方法来指定附加的操作</li></ul></li><li>使用寻址位的考虑因素<ul><li>支持的寻址方式的种数</li><li>操作数的数量：数量多，则操作数的位数短</li><li>寄存器与存储器比较：能用于操作数引用的寄存器越多，指令需要的位数越少</li><li>寄存器组的数目：对于固定数目的寄存器 功能上的分开将使指令只需较少的位数</li><li>地址范围：比如间接寻址可以增大范围</li><li>寻址粒度：同样大的寻址空间，使用较大的字时，需要的地址位更少</li></ul></li></ul></li><li>变长指令<ul><li>提供不同长度的各种指令格式</li><li>优点<ul><li>易于提供大的操作码清单，而操作码具有不同的长度</li><li>寻址方式能更灵活，指令格式能将各种寄存器和存储器引用加上寻址方式予以组合</li></ul></li><li>缺点<ul><li>增加了CPU 的复杂程度（效率也会降低）</li></ul></li><li>取至少等于最长指令长度的几个字节或几个字</li></ul></li></ol><h3 id="指令集设计"><a href="#指令集设计" class="headerlink" title="指令集设计"></a>指令集设计</h3><ol><li>指令集的设计是件很复杂的事情，影响计算机系统的诸多方面<ul><li>指令集定义了处理器应完成的多数功能，对处理器的实现有着显著的影响</li><li>指令集是程序员控制处理器的方式，设计时必须考虑程序员的要求</li></ul></li><li>设计的基本原则<ul><li>完备性/完整性：操作类型应当尽可能完备，但太复杂了也会给硬件实现增加困难</li><li>兼容性：应当兼容以前的指令系统，为软件重复利用带来方便</li><li>均匀性：应当能对多种类型的数据进行处理</li><li>可扩充性：操作码要预留一定的编码空间</li></ul></li><li>设计的基本问题<ul><li>操作指令表：应提供多少和什么样的操作，操作有多复杂</li><li>数据类型：对哪几种数据类型完成操作</li><li>指令格式：指令的位长度、地址数目、各个字段的大小等</li><li>寄存器：能被指令访问的寄存器数目以及它们的用途</li><li>寻址：寻址方式的种类以及有效地址的计算</li><li>下一条指令地址的确定：通常通过PC 寄存器实现</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第13讲-总线</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%80%BB%E7%BA%BF/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第13讲-总线"><a href="#第13讲-总线" class="headerlink" title="第13讲-总线"></a>第13讲-总线</h2><span id="more"></span><h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><ol><li><p>类型</p><ul><li>芯片内部总线：连接芯片内部的各个部分<ul><li>例：CPU 中连接寄存器、ALU 等部分</li></ul></li><li>系统总线：连接CPU 、存储器、IO 控制器和其他功能设备</li><li>通信总线：连接主机和I/O 设备，或连接不同的计算机系统</li></ul></li><li><p>总线结构</p><ul><li>数据线：在系统组件之间传输数据<ul><li>数据线的数量决定了一次可以传输的数据的大小</li></ul></li><li>地址线：在数据线和地址I/O 端口上指定数据的来源和去向<ul><li>地址线的数量决定了寻址空间的大小</li></ul></li><li>控制线：控制对数据线和地址线的存取和使用<ul><li>时钟（clock）：用于总线同步操作</li><li>总线请求（bus request）：表示模块需要获得对总线的控制</li><li>总线允许（bus grant）：发出请求的设备已经被允许控制总线</li><li>中断请求（interrupt request）：表示某个中断正在悬而未决</li><li>中断响应（interrupt ACK）：未决的终端请求被响应</li><li>存储器读（memory read）：从存储器读数据到总线</li><li>存储器写（memory write）：将数据从总线写入存储器</li><li>I/O读（I/O read）：从I/O 端口读数据到总线</li><li>I/O写（I/O write）：将数据从总线写入I/O 端口<br><img src="image-20231215210246332.png" alt="image-20231215210246332" style="zoom:70%;" /></li></ul></li></ul></li><li>总线上数据传输的特点<ul><li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据<ul><li>如果同一时刻多个设备同时发送数据，会造成数据之间的混淆</li><li>使用总线进行数据传输<ul><li>如果连在总线上的某个设备希望向另一个设备发送数据，需要：<ul><li>获得总线的使用权</li><li>通过总线传送数据</li></ul></li><li>如果连在总线上的某个设备希望向另一个组件请求数据，需要：<ul><li>获得总线的使用权</li><li>通过总线向另一个设备发送请求，等待另一个设备发送数据</li></ul></li></ul></li></ul></li><li>当总线在被使用过程中，其它设备不可以抢占</li></ul></li></ol><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ol><li><p>用途：专用总线，复用总线</p><ul><li>专用（dedicated）总线：始终只负责一项功能，或始终分配给特定的计算机组件<ul><li>优点：高吞吐量，减少总线冲突</li><li>缺点：增加了系统的规模和成本</li></ul></li><li>复用（multiplexed）总线：将同一线路用于多种用途<ul><li>优点：使用的布线数量少，节省空间和成本</li><li>缺点：每个模块需要更复杂的控制电路，且共享可能会降低性能</li></ul></li></ul></li><li><p>仲裁（arbitration）：当多个设备需要与总线通信时，通过某种策略选择一个设备</p><ul><li>平衡因素<ul><li>优先级：优先级高的设备优先被服务</li><li>公平性：优先级最低的设备不能一直被延迟</li></ul></li><li>仲裁方案<ul><li>集中式（centralized）：由仲裁器（arbiter）或总线控制器（bus controller）负责分配总线使用权<ul><li>链式查询/菊花链（daisy chain）</li><li>计数器查询（query by a counter）</li><li>独立请求（independently request）</li></ul></li><li>分布式（distributed）：每个设备都包含访问控制逻辑，各设备共同作用分享总线<ul><li>自举式（self selection）</li><li>冲突检测（collision detection）</li></ul></li></ul></li><li>链式查询<ul><li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备。</li><li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号。</li><li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递。</li><li>优点：确定优先级很简单；可以很灵活地添加设备。</li><li>缺点：不能保证公平性；对电路故障敏感；限制总线的速度。<br><img src="ee7ff247291e6eb2fe3605d298a6306.png" alt="ee7ff247291e6eb2fe3605d298a6306" style="zoom:80%;" /></li></ul></li><li>计数器查询 <ul><li>将总线允许线替换为设备ID（地址）线 </li><li>当总线仲裁器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备ID 线发向各个部件</li><li>如果当前发送请求的设备ID 等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为繁忙 </li><li>优点<ul><li>通过使用不同的初始计数，可以灵活地确定设备优先级<ul><li>强调优先级：从1 开始</li><li>强调公平性：从下一个设备的ID 开始 </li><li>对电路故障不敏感 </li></ul></li></ul></li><li>缺点<ul><li>需要添加设备ID 线</li><li>需要解码和比较设备ID 信号</li><li>限制总线的速<br><img src="7b58c5908dbf8d0490b1137f3f1369f.png" alt="7b58c5908dbf8d0490b1137f3f1369f" style="zoom: 90%;" /></li></ul></li></ul></li><li>独立请求<ul><li>每个设备都有自己的总线请求线和总线允许线</li><li>当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器</li><li>总线仲裁器决定哪个设备可以使用总线<ul><li>确定策略：固定优先级，公平链式，LRU，FIFO</li></ul></li><li>优点：快速响应；可编程的优先级</li><li>缺点：复杂的控制逻辑；更多的控制线路<br><img src="a45b0f7154ac47e6ea3bd4ea0b74939.png" alt="a45b0f7154ac47e6ea3bd4ea0b74939" style="zoom:85%;" /></li></ul></li><li><p>自举式</p><ul><li><p>固定优先级</p></li><li><p>每个设备在其总线请求线上发送请求</p><ul><li>最低优先级的设备没有请求线</li></ul></li><li><p>每个设备自行判断自己是否在请求总线的设备中优先级最高<br><img src="862036a6fe5287ef6b619355bd58ab3.png" alt="862036a6fe5287ef6b619355bd58ab3" style="zoom:75%;" /></p></li></ul></li><li><p>冲突检测</p><ul><li><p>当一个设备想要使用总线时，它会检查总线是否繁忙</p><ul><li>如果总线空闲，设备使用总线</li></ul></li><li><p>冲突：如果两个设备发现总线空闲，它们可能同时使用总线</p><ul><li>在传输数据时，设备会监听总线，检查是否存在冲突</li><li>如果发生冲突，所有使用总线的设备将停止数据传输，并分别在随机时间间隔后再次请求总线</li></ul></li></ul></li></ul></li><li><p>时序（timing）</p><ul><li>确定每个总线事务的开始和结束时间</li><li>总线事务：地址+ 数据+ … + 数据</li><li>同步时序：事件的发生由时钟决定<ul><li>优点：更容易实现和测试</li><li>缺点：所有设备共享同一个时钟；总线长度受到时钟偏差的限制 </li></ul></li><li>异步时序：一个事件的发生取决于前一个事件的发生（顺序）<ul><li>握手策略<br><img src="99abe6d1946854ea2c3d21c573b4ad3.png" alt="99abe6d1946854ea2c3d21c573b4ad3"> </li><li>异步数据传输     <ol><li>CPU设置地址并设置 ReadReq 线</li><li>存储器读取相应地址并设置Ack 线</li><li>CPU释放地址线和ReadReq 线</li><li>存储器释放Ack 线</li><li>存储器将数据传到数据线并设置DataRdy 线</li><li>CPU读取数据并设置Ack 线</li><li>存储器释放数据线和dataRdy 线</li><li>CPU 释放Ack 线<br> <img src="8008a65b2bba709b69858ae51276bf4.png" alt="8008a65b2bba709b69858ae51276bf4" style="zoom:80%;" />     </li></ol></li><li>优点：可以灵活地协调速度不同的设备</li><li>缺点：接口逻辑复杂；对噪声敏感（被误认为信号）     </li></ul></li><li>半同步：同步时序和异步时序相结合     <ul><li>为了减少噪声的影响，在异步计时中使用时钟     </li><li>准备和响应信号在时钟上升沿有效     </li><li>半同步通信集同步与异步通信之优点，既保留了同步通信的基本特点     <ul><li>所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别。</li><li>同时又像异步通信那样，允许不同速度的模块和谐地工作。为此增设了一条“等待”( )响应信号线。     </li></ul></li><li>半同步时序的读命令     <ul><li>主模块在T1发出地址，T2发出命令       </li><li>从模块工作速度较慢，无法在下一时钟周期时刻提供数据，则必须在T3之前通知主模块，使其进入等待状态，此刻，从模块置$\overline{\text{WAIT}}$为低电平有效。主模块在测得$\overline{\text{WAIT}}$有效，则不立即从数据线上取数。       </li><li>主模块等待，直到测得$\overline{\text{WAIT}}$为高电平即等待无效时，主模块即把此刻的下一周期当作正常周期T3，即时获取数据，T4结束传输。<br><img src="446d584b9e1f4c178ab54809754e0cf.png" alt="img" style="zoom:80%;" /></li></ul></li><li>参考文章：<a href="https://blog.csdn.net/iteye_21199/article/details/82200294">总线的半同步通信-CSDN博客</a>            </li></ul></li><li>分离事务：设备准备数据期间释放总线   <ul><li>将一个总线事件分离为两个过程</li><li>优点：增加总线利用率</li><li>缺点：增加每个总线事件的持续时间和系统复杂度<br><img src="e5dc9f1eaeedae7136286233700c9c2.png" alt="e5dc9f1eaeedae7136286233700c9c2" style="zoom:85%;" /></li></ul></li></ul></li><li><p>总线带宽（bandwidth）：总线的最大数据传输速率。不要考虑总线仲裁、地址传输等因素。 </p></li><li>数据传输速率（data transfer rate）：考虑地址传输、握手等因素。<ul><li>例题1：假设同步总线的时钟周期为50 ns，每次传输需要一个时钟周期，异步总线每次握手需要40 ns 。两个总线都是32 位宽，内存的数据准备时间为200 ns 。当从存储器中读出一个32 位的字时，计算两个总线的数据传输速率。<ul><li>同步总线<ul><li>发送指令和地址到内存：50ns</li><li>内存准备数据：200ns</li><li>将数据传输到CPU：50ns</li><li>数据传输速率= 32bit / (50 + 200 + 50)ns = 106.7Mbps</li></ul></li><li>异步总线<ul><li>步骤1：40 ns</li><li>步骤2 、3 、4 / 数据准备：max(40ns* 3,200ns) = 200ns</li><li>步骤5 、6 、7：40ns * 3 = 120ns</li><li>数据传输速率= 32bit / (40 + 200 + 120)ns = 88.9Mbps<br><img src="d7157e052b62e7d824e1d4dfaf3089d.png" alt="d7157e052b62e7d824e1d4dfaf3089d"></li></ul></li></ul></li><li>例题2：假设同步总线的时钟周期为50 ns，每次传输需要一个时钟周期，异步总线每次握手需要40 ns 。两个总线都是32 位宽，存储器的数据准备时间为230 ns 。当从存储器中读出一个32 位的字时，计算两个总线的数据传输速率。<ul><li>同步总线：数据传输速率= 32bit / (50 + <strong>250</strong> + 50)ns = 91.4Mbps<ul><li>数据准备时间是250，因为必须必须是完整的时钟周期</li></ul></li><li>异步总线：数据传输速率= 32bit / (40 + 230 + 120)ns = 82.1Mbps</li></ul></li><li>例题3：假设系统具有以下特征<br>1.它支持访问大小为4 到16 个字（每个字32 位）的块<br>2.同步总线具有64 位宽和200MHz 时钟频率，需要1 个时钟周期来传输地址或64 位数据<br>3.在两个总线事务之间有2 个空闲时钟周期<br>4.内存访问时准备前4 个字需要200ns，后面每4 个字准备需要20ns<br>5.当前面的数据在总线上传输时，内存可以同时读取后面的数据<br>如果读取256 个字，分别计算每次传输4 个字和16 个字时的数据传输速率、传输时间和每秒总线事务数<ul><li>每次传输4 个字<ul><li>总线事务：地址+ 4 个字<ul><li>地址传输：1 个时钟周期</li><li>数据准备：200ns (40 个时钟周期）</li><li>数据传输：2 个时钟周期</li><li>空闲：2 个时钟周期</li></ul></li><li>总共：256 / 4 * (1 + 40 + 2 + 2) = 2880 个时钟周期</li><li>传输时间= 2880 * 5ns = 14400ns</li><li>每秒总线事务数= (256 / 4) * (1s / 14400ns) = 4.44M</li><li>数据传输速率= 256 * 32bit / 14400ns = 568.9Mbps</li></ul></li><li>每次传输16 个字<ul><li>总线事务：地址+ 16 个字<ul><li>地址传输：1 个时钟周期</li><li>数据准备（前4 个字）：200ns（40 个时钟周期）</li><li>数据传输：2 个时钟周期（同时读取后4 个字：20ns）</li><li>空闲：2 个时钟周期</li></ul></li><li>总共：256 / 16 <em> (1 + 40 + 3</em>max(2, 4)+ 2 + 2) = 912 个时钟周期</li><li>传输时间= 912 * 5ns = 4560ns</li><li>每秒总线事务数= 16 * 1s / 4560ns = 3.51M</li><li>数据传输速率= 256 * 32bit / 4560ns = 1796.5Mbps</li></ul></li></ul></li><li>提高总线的数据传输率<ul><li>提高时钟频率（时钟周期数不变的情况下）</li><li>增加数据总线宽度<ul><li>每次传输更多的数据（成本：更多的总线线路）</li></ul></li><li>块传输<ul><li>传输一次地址就传输一块数据（成本：高复杂性）</li></ul></li><li>分离总线事务<ul><li>减少总线空闲时间（成本：复杂性高，增加每个事务的持续时间）</li></ul></li><li>分离地址线和数据线<ul><li>同时传输地址和数据（成本：更多的总线线路）</li></ul></li></ul></li></ul></li><li>总线层次结构<ul><li>单总线结构：CPU、存储器和I/O 模块都连接到一条系统总线<ul><li>优点：简单，易于扩展</li><li>缺点：连接的设备越多，总线长度越大，传输延迟也就越大；聚集的传输请求接近总线容量时，总线成为瓶颈<br><img src="40ff86dbaedcc381a249137d805f48c.png" alt="40ff86dbaedcc381a249137d805f48c"></li></ul></li><li>双总线结构I   <ul><li>在CPU 和存储器中间增加一个存储器总线   </li><li>优点：增加CPU 和存储器之间的传输效率，同时降低系统总线的负担<br><img src="9194fe1c796dde6aa125281c54a038c.png" alt="9194fe1c796dde6aa125281c54a038c" style="zoom:75%;" /></li></ul></li><li>双总线结构II<ul><li>将系统总线分为存储器总线、I/O 总线和IOP (input/output）</li><li>优点：降低I/O 对总线的负担<br><img src="a4017a70126bfc3ae01d13b8c418ac4.png" alt="a4017a70126bfc3ae01d13b8c418ac4" style="zoom:80%;" /></li></ul></li><li>多总线结构I<ul><li>增加一个本地总线（local bus bus）来连接CPU 和cache</li><li>优点：分离了CPU 和I/O 的交互<br><img src="8ba12b322f24cb25b416dee800eb747.png" alt="8ba12b322f24cb25b416dee800eb747" style="zoom:80%;" /></li></ul></li><li>多总线结构II<ul><li>将系统总线分为存储器总线、I/O 总线和DMA 总线</li><li>优点：增加I/O 效率<br><img src="9a3f8dc17b40122e261822c986ab632.png" alt="9a3f8dc17b40122e261822c986ab632"></li></ul></li><li>多总线结构III<ul><li>增加一个高速I/O 总线来连接高速设备</li><li>优点：增加I/O 交互效率</li></ul></li></ul></li></ol><p><img src="d43da1decbed8bba82ae3b3f586a29d.png" alt="d43da1decbed8bba82ae3b3f586a29d" style="zoom:75%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第12讲-虚拟存储器</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC12%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC12%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第12讲-虚拟存储器"><a href="#第12讲-虚拟存储器" class="headerlink" title="第12讲-虚拟存储器"></a>第12讲-虚拟存储器</h2><span id="more"></span><h3 id="操作系统的出现"><a href="#操作系统的出现" class="headerlink" title="操作系统的出现"></a>操作系统的出现</h3><ol><li>第一台计算机诞生时，采用手工操作的方式<ul><li>一个用户独占全机：不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低</li><li>CPU等待手工操作：CPU 的利用不充分</li></ul></li><li>批处理系统：加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（包括程序、数据和命令）<ul><li>联机批处理系统，脱机批处理系统</li></ul></li><li>操作系统：一种控制应用程序运行和在计算机用户与计算机硬件之间提供接口的程序</li><li>目标：使计算机使用起来更方便；允许计算机系统的资源以有效的方式使用</li></ol><h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><ol><li>早期计算机的主存中仅包含系统软件和一个用户程序<ul><li>单道程序设计</li></ul></li><li>现在计算机的主存中包含操作系统和若干个用户程序<ul><li>当所有任务都需要等待I/O 时，为了避免处理器处于空闲状态，需要尽可能让更多的任务进入主存</li><li>多道程序设计：让处理器一次处理多个任务，提高处理器的利用率</li></ul></li><li>存储器管理<ul><li>在多道程序系统中，主存需要进一步划分给多个任务，划分的任务由操作系统动态执行</li><li>本门课不区分“进程”和“任务”这个更抽象的概念</li></ul></li></ol><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ol><li>如何将更多更大的任务装入主存<ul><li>增大主存容量</li><li>使用交换（exchange）技术<ul><li>当主存中没有处于就绪的任务时，操作系统调入其他任务来执行</li><li>区（partitioning）和分页（paging）</li></ul></li></ul></li><li>虚拟存储器<ul><li>请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上</li><li>虚拟地址</li></ul></li><li>分区方式<ul><li>分区方式将主存分为两大区域<ul><li>系统区：固定的地址范围内，存放操作系统</li><li>用户区：存放所有用户程序</li></ul></li><li>简单固定分区<ul><li>用户区划分成长度不等的固定长的分区</li><li>当一个任务调入主存时，分配一个可用的、能容纳它的、最小的分区</li><li>优点：简单</li><li>缺点：浪费主存空间</li></ul></li><li>可变长分区<ul><li>用户区按每个任务所需要的内存大小进行分配</li><li>优点：提高了主存的利用率</li><li>缺点：时间越长，存储器中的碎片就会越多</li></ul></li></ul></li><li>分页方式<ul><li>目的：减少碎片的产生</li><li>基本思想<ul><li>把主存分成固定长且比较小的存储块，称为页框（page frame），每个任务也被划分成固定长的程序块，称为页（page）</li><li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li></ul></li><li>逻辑地</li><li>物理地址：实际主存地址</li></ul></li></ol><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ol><li>问题：内存的大小是有限的，但对内存的需求不断增加</li><li>基本思想<ul><li>请求分页：仅将当前需要的的页调入主存<ul><li>通过硬件将逻辑地址转换为物理地址</li><li>未命中时在主存和硬盘之间交换信息</li></ul></li></ul></li><li>优点<ul><li>在不扩大物理内存的前提下，可以载入更多的任务</li><li>编写程序时不需要考虑可用物理内存的状态</li><li>程序员认为可以独享一个连续的、很大的内存</li><li>可以在大于物理内存的逻辑地址空间中编程</li></ul></li><li>设计要素<ul><li>页大小：4KB, 8KB, …</li><li>映射算法：全相联映射</li><li>写策略：写回</li><li>Cache比主存快10 倍，主存比硬盘快100000 多，故需要减少硬盘访问，尽可能提高主存命中率</li></ul></li><li>类型<ul><li>分页式虚拟存储器</li><li>分段式虚拟存储器</li><li>段页式虚拟存储器</li></ul></li><li>分页式虚拟存储器<ul><li>主存储器和虚拟地址空间都被划分为大小相等的页面<ul><li>虚拟页（virtual page，VP） / 逻辑页（logical page）：虚拟地址空间中的页面</li><li>物理页（physical page，PP） / 页框（page frame）：主存空间中的页面</li></ul></li><li>页表<ul><li>页表中包含了所有虚拟页的信息，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等等</li><li>保存在主存中</li><li>虚拟地址：虚拟页号 + 页内偏移量</li><li>根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址<br>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li></ul></li><li>快表（Translation Lookaside Buffer，TLB）<ul><li>页表的使用增加了主存的访问次数</li><li>为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li><li>后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中<ul><li>映射：关联映射，组关联映射</li><li>替换：随机替换</li></ul></li><li>主存中的页表相应地称之为“慢表”</li></ul></li><li>CPU访存<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac12%e8%ae%b2-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8/image-20231215203705409.png" alt="image-20231215203705409" style="zoom:67%;" /></div></li><li>TLB、页表、Cache 的缺失组合<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac12%e8%ae%b2-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8/image-20231215204207927.png" alt="image-20231215204207927" style="zoom:45%;" /></div></li></ul></li></ol><h3 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h3><ol><li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li><li>虚拟地址：段号+ 段内偏移量</li><li>与分页式虚拟存储器相比<ul><li>分页式虚拟存储器（页对程序员不可见）<ul><li>优点：实现简单、开销少</li><li>缺点：一个数据或一条指令可能会分跨在两个页面</li></ul></li><li>分段式虚拟存储器（段对程序员可见）<ul><li>优点：段的分界与程序的自然分界相对应，易于编译、管理、修改和保护</li><li>缺点：段的长度不固定（引起碎片）</li></ul></li></ul></li></ol><h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><ol><li>将程序和数据分段，段内再进行分页<ul><li>每个分段都有一个页表</li></ul></li><li>虚拟地址：段号+ 页号+ 页内偏移量</li><li>优点：程序按段实现共享与保护</li><li>缺点：需要多次查表</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第11讲-冗余磁盘阵列</title>
      <link href="/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC11%E8%AE%B2-%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
      <url>/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC11%E8%AE%B2-%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="第11讲-冗余磁盘阵列"><a href="#第11讲-冗余磁盘阵列" class="headerlink" title="第11讲-冗余磁盘阵列"></a>第11讲-冗余磁盘阵列</h2><span id="more"></span><h3 id="RAID简介"><a href="#RAID简介" class="headerlink" title="RAID简介"></a>RAID简介</h3><ol><li>冗余磁盘阵列/独立磁盘冗余阵列：Redundant Arrays of Independent Disks (RAID)</li><li>基本思想<ul><li>将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量</li><li>将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率</li><li>采用数据冗余来进行错误恢复以提高系统可靠性</li></ul></li><li>特性<ul><li>由一组物理磁盘驱动器组成，被视为单个逻辑驱动器。</li><li>数据是分布在多个物理磁盘上，分布方案称为条带。</li><li>冗余磁盘容量用于存储奇偶校验信息，保证磁盘万一损坏时能恢复数据。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214210403441.png" alt="image-20231214210403441" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><ol><li>数据以条带的形式在可用的磁盘上分布</li><li>不采用冗余来改善性能（不是RAID 家族中的真正成员）</li><li>用途<ul><li>高数据传输率</li><li>高速响应I/O 请求：两个I/O 请求所需要的数据块可能在不同的磁盘上.如果条的大小相对较大，那么单个IO请求只涉及单个磁盘访问，则多个等待的IO请求就可以被并行处理，减少了每个请求的排队时间。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211106615.png" alt="image-20231214211106615" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><ol><li>采用了数据条带，采用简单地备份所有数据的方法来实现冗余。</li><li>优点<ul><li>高速响应I/O 请求：即便是同一个磁盘上的数据块，也可以由两组硬盘分别响应。</li><li>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以选择寻道时间较小的那个。</li><li>写请求需要更新两个对应的条带：可以并行完成，但受限于写入较慢的磁盘。</li><li>单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单。</li></ul></li><li>缺点<ul><li>价格昂贵（一半的容量）。</li></ul></li><li><p>用途</p><ul><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li><li>与RAID 0 相比<ul><li>如果有大批的读请求，则RAID 1 能实现高速的I/O 速率，性能可以达到RAID 0<br>的两倍</li><li>如果I/O 请求有相当大的部分是写请求，则它不比RAID 0 的性能好多少<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211547297.png" alt="image-20231214211547297" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>RAID 01 vs. RAID 10</p><ul><li>RAID 01= RAID 0+1：先做RAID 0，再做RAID 1</li><li>RAID 10= RAID 1+0：先做RAID 1，再做RAID 0</li><li>两者在数据传输率和磁盘利用率上没有明显区别，主要区别是对磁盘损坏的容错能力</li><li>若Disk 0 和Disk 1 坏掉<ul><li>RAID 01：两个RAID 0均无法工作，整个体统无法工作。</li><li>RAID 10：两个RAID 1失去了校验功能，但仍可读写信息，系统可以正常工作。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211853938.png" alt="image-20231214211853938" style="zoom:67%;" /></div></li></ul></li></ul></li></ol><h3 id="RDIA-2"><a href="#RDIA-2" class="headerlink" title="RDIA 2"></a>RDIA 2</h3><ol><li>采用并行存取技术</li><li>目标:所有磁盘都参与每个I/O 请求的执行</li><li>特点<ul><li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li><li>采用数据条带：条带非常小，经常只有一个字节或一个字</li></ul></li><li>纠错：对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li><li>访问<ul><li>读取：获取请求的数据和对应的校验码</li><li>写入：所有数据盘和校验盘都被访问</li></ul></li><li>缺点<ul><li>冗余盘依然比较多，价格较贵</li><li>适用于多磁盘易出错环境，对于单个磁盘和磁盘驱动器已经具备高可靠性的情况没有意义（实际基本弃用）<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214213556398.png" /></div></li></ul></li></ol><h3 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h3><ol><li>采用并行存取技术<ul><li>各个驱动器的轴同步旋转</li><li>采用非常小的数据条带</li></ul></li><li>校验：对所有数据盘上同一位置的数据计算奇偶校验码<ul><li>当某一磁盘损坏时，可以用于重构数据𝑏<sub>0</sub>= 𝑃(𝑏) ⨁ 𝑏<sub>1</sub> ⨁ 𝑏<sub>2</sub> ⨁ 𝑏<sub>3</sub></li></ul></li><li>优点：能够获得非常高的数据传输率，对于大量读请求，性能改善特别明显</li><li>缺点：一次只能执行一个I/O 请求，在面向多个IO 请求时，性能将受损<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220525181.png" /></div></li></ol><h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h3><ol><li>采用独立存取技术<ul><li>每个磁盘成员的操作是独立的，各个I/O 请求能够并行处理</li><li>采用相对较大的数据条带（常见的是4KB） </li></ul></li><li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li><li>性能<ul><li>当执行较小规模的I/O 写请求时，RAID 4 会遭遇写损失<ul><li>对于每一次写操作，阵列管理软件不仅要修改用户数据，而且要修改相应的校验位<br>𝑃’(𝐵) =  𝑃(𝐵)⨁𝐵<sub>0</sub>⨁ 𝐵’<sub>0</sub></li></ul></li><li>当涉及所有磁盘的数据条带的较大I/O 写操作时，只要用新的数据位来进行简单的计算即可得到奇偶校验位</li><li>每一次写操作必须涉及到唯一的校验盘，校验盘会成为瓶颈（实际基本弃用）<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220514240.png" alt="image-20231214220514240" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><ol><li>与RAID 4 组织方式相似（常用）</li><li>在所有磁盘上都分布了奇偶校验条带<ul><li>避免潜在的I/O 瓶颈问题</li></ul></li><li><p>访问时的“两读两写”：读在写前，读写不需要并行<br>  𝑃’(𝐵) =  𝑃(𝐵)⨁𝐵<sub>0</sub>⨁ 𝐵’<sub>0</sub></p><div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220725519.png" alt="image-20231214220725519" style="zoom:80%;" /></div></li><li><p>RAID 50</p><ul><li>RAID 5 与RAID 0 的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5 彼此构成条带访问</li><li>RAID 50 在底层的任一组或多组RAID 5 中出现1 颗硬盘损坏时，仍能维持运作；如果任一组RAID 5 中出现2 颗或2 颗以上硬盘损毁，整组RAID 50 就会失效</li><li>RAID 50 由于在上层把多组RAID 5 进行条带化，性能比起单纯的RAID 5 高，但容量利用率比RAID 5 要低<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214221752126.png" alt="image-20231214221752126" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><ol><li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li><li>优点：提升数据可用性：只有在平均修复时间间隔内3 个磁盘都出了故障，才会造成数据丢失</li><li>缺点：写损失：每次写都要影响两个校验块（读3 个写3 个磁盘）</li></ol><h3 id="RAID比较"><a href="#RAID比较" class="headerlink" title="RAID比较"></a>RAID比较</h3><ol><li>RAID 0：提升I/O 响应能力，但数据可用性低</li><li>RAID 1：提升数据可用性，但容量利用率低</li><li>RAID 2和 RAID3：提升数据可用性和数据传输率，但一次只能处理一个I/O 请求</li><li>RAID 4和 RAID 5 和 RAID 6：提升数据可用性和读速率，但写速率受限</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第10讲-数据校验码</title>
      <link href="/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC10%E8%AE%B2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
      <url>/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC10%E8%AE%B2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="第10讲-数据校验码"><a href="#第10讲-数据校验码" class="headerlink" title="第10讲-数据校验码"></a>第10讲-数据校验码</h2><span id="more"></span><h3 id="差错（Error）"><a href="#差错（Error）" class="headerlink" title="差错（Error）"></a>差错（Error）</h3><ol><li>数据在计算机内部进行计算、存取和传送过程中，由于元器件故障或噪音干扰等原因，会出现差错</li><li>以存储为例<ul><li>硬故障（hard failure）：永久性的物理故障，以至于受影响的存储单元不能可靠地存储数据，成为固定的“1”或“0”故障，或者在0 和1之间不稳定地跳变。由恶劣的环境、制造缺陷和旧损引起</li><li>软故障（soft error）：随机非破坏性事件，它改变了某个或某些存储单元的内容，但没有损坏机器。由电源问题或α 粒子引起</li></ul></li><li>解决方案<ul><li>从计算机硬件可靠性入手，在电路、电源、布线等方面采取必要的措施，提高计算机的抗干扰能力</li><li>采取数据检错和校正措施，自动发现并纠正错误</li></ul></li></ol><h3 id="纠错（Error-Correction）"><a href="#纠错（Error-Correction）" class="headerlink" title="纠错（Error Correction）"></a>纠错（Error Correction）</h3><ol><li>基本思想：存储额外的信息以进行检错和校正</li><li>处理过程<ul><li>数据输入：使用函数𝑓在𝑀位数据𝐷上生成𝐾位校验码𝐶</li><li>数据输出：使用函数𝑓在𝑀位数据𝐷 上生成新的𝐾位代码𝐶”，并与取出的𝐾位码𝐶 进行比较<ul><li>没有检测到差错：使用数据𝐷</li><li>检测到差错且可以校正：校正数据𝐷 来生成数据𝐷”，并用数据𝐷</li><li>检测到差错但无法纠正：报告</li></ul></li></ul></li></ol><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ol><li><p>基本思想：增加1 位校验码来表示数据中1 的数量是奇数还是偶数</p><ul><li>奇校验：使传输的数据（数据位 校验位）中有奇数个1</li><li>偶校验：使传输的数据（数据位 校验位）中有偶数个1</li></ul></li><li><p>处理过程</p><ul><li>假设数据为𝐷<sub>𝑀</sub> … 𝐷<sub>2</sub> 𝐷<sub>1</sub>     </li><li>数据输入<ul><li>奇校验：𝐶 = 𝐷<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷<sub>2</sub> $\bigoplus$  𝐷<sub>1</sub>$\bigoplus$1</li><li>偶校验：𝐶 = 𝐷<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷<sub>2</sub> $\bigoplus$  𝐷<sub>1</sub>       </li></ul></li><li>数据输出<ul><li>奇校验：𝐶’ = 𝐷’<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷’<sub>2</sub> $\bigoplus$  𝐷’<sub>1</sub>$\bigoplus$1</li><li>偶校验：𝐶’ = 𝐷’<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷’<sub>2</sub> $\bigoplus$  𝐷’<sub>1</sub>       </li></ul></li><li>检错：S = 𝐶′$\bigoplus$′ 𝐶′       <ul><li>𝑆=0：正确/数据中出错的位数为偶数       </li><li>𝑆=1：数据中出错的位数为奇数       </li></ul></li><li>优点：代价低（只需要1 位额外数据，计算简单）</li><li>缺点：不能发现出错位数为偶数的情形；发现错误后不能校正。<ul><li>适用于对较短长度（如1 字节）的数据进行检错</li></ul></li></ul></li></ol><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><ol><li>基本思想：将数据分成几组，对每一组都使用奇偶校验码进行检错</li><li>处理过程<ul><li>将𝑀位数据分成𝐾组</li><li>数据输入：为数据𝐷中每组生成1 位校验码，合并得到𝐾位校验码𝐶</li><li>数据输出：为数据𝐷 中每组生成1 位校验码，合并得到新的𝐾位校验码𝐶</li><li>检错：将校验码𝐶 和取出的校验码C’ 按位进行异或，生成𝐾位故障字（syndrome word）</li></ul></li><li>校验码长度<ul><li>假设最多1 位发生错误</li><li>可能的差错<ul><li>数据中有1 位出现错误：𝑀</li><li>校验码中有1 位出现错误：𝐾</li><li>没有出现错误：1</li></ul></li><li>校验码的长度：2<sup>𝐾</sup> &gt;𝑀+ 𝐾+1<br><img src="image-20231214142811606.png" alt="image-20231214142811606" style="zoom:67%;" />   </li><li>故障字的作用<ul><li>每种取值都反映一种情形（数据出错/校验码出错/未出错）</li><li>规则<ul><li>全部是0：没有检测到错误</li><li>有且仅有1 位是1：错误发生在校验码中的某一位，不需要纠正</li><li>有多位为1：错误发生在数据中的某一位，将𝐷 中对应数据位取反即可纠正（得到𝐷”）</li></ul></li></ul></li><li>数据位划分<ul><li>假定数据位为8位𝐷 = 𝐷8 … 𝐷2𝐷1, 校验码为4位𝐶 = 𝐶4𝐶3𝐶2𝐶1</li><li>数据位/校验码与故障字的关系</li><li>数据位划分<br>𝐶1 = 𝐷1 ⊕ 𝐷2 ⊕ 𝐷4 ⊕ 𝐷5 ⊕ 𝐷7<br>𝐶2 = 𝐷1 ⊕ 𝐷3 ⊕ 𝐷4 ⊕ 𝐷6 ⊕ 𝐷7<br>𝐶3 = 𝐷2 ⊕ 𝐷3 ⊕ 𝐷4 ⊕ 𝐷8<br>𝐶4 = 𝐷5 ⊕ 𝐷6 ⊕ 𝐷7 ⊕ 𝐷8<br><img src="1349b08cd70575e934a3476e41fbb69.png" alt="1349b08cd70575e934a3476e41fbb69" style="zoom:50%;" /></li></ul></li></ul></li></ol><h3 id="码距和纠错理论"><a href="#码距和纠错理论" class="headerlink" title="码距和纠错理论"></a>码距和纠错理论</h3><ol><li>码距：同一编码中，任意两个合法编码之间不同二进制数位数的最小值<ul><li>{0000, 0001, 0010, 0011} 码距为1</li><li>{0000,0011} 码距为2 </li></ul></li><li>纠错理论：𝑳 - 𝟏 = 𝑫 + 𝑪 <ul><li>𝐿是码距，𝐷 是检错位数，𝐶 是纠错位数</li><li>奇偶校验的码距是2，1 位能检错，不能纠错</li><li>海明码的码距是3，1 位能检错和纠错</li></ul></li></ol><h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><ol><li>奇偶校验问题：额外成本很大；要求将数据分成字节</li><li>循环冗余校验（Cyclic Redundancy Check, CRC）<ul><li>适用于以流格式存储和传输大量数据</li><li>用数学函数生成数据和校验码之间的关系</li></ul></li><li>基本思想：假设数据有M 位，左移数据K 位（右侧补00），并用K+1 位生成多项式除它（模2 运算）<ul><li>采用K 位余数作为校验码</li><li>把校验码放在数据（不含补的00）后面，一同存储或传输。</li></ul></li><li>校错：如果M+K 位内容可以被生成多项式除尽，则没有检测到错误；否则，发生错误。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第9讲-外部存储器</title>
      <link href="/2023/12/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC9%E8%AE%B2-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC9%E8%AE%B2-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第9讲-外部存储器"><a href="#第9讲-外部存储器" class="headerlink" title="第9讲-外部存储器"></a>第9讲-外部存储器</h2><span id="more"></span><h4 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h4><ol><li>特性：用于存储不经常使用的、数据量较大的信息；非易失。</li><li>类型：<ul><li>磁盘存储器（magnetic disk disk）</li><li>光存储器（optical memory memory）</li><li>磁带（magnetic tape tape）</li><li>U盘（USB flash disk disk）</li><li>固态硬盘（solid state disk disk，SSD）</li></ul></li></ol><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><ol><li>磁盘是由涂有可磁化材料的非磁性材料（基材）构成的圆形盘片<ul><li>基材：铝、铝合金、玻璃</li><li>玻璃基材的优势（稳定可靠、为存储更多信息提供基础）<ul><li>改善磁膜表面的均匀性，提高磁盘的可靠性</li><li>显著减少整体表面瑕疵，以帮助减少读写错误</li><li>能够支持（磁头）较低的飞行高度</li><li>更高的硬度，使磁盘转动时更加稳定</li><li>更强的抗冲击和抗损伤能力</li></ul></li></ul></li><li>类型：硬盘、软盘</li><li>磁头：对盘片进行读写操作的装置<ul><li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动。在任何时候，所有磁头都位于距磁盘中心等距离的磁道上。</li><li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li><li>磁头越窄，电磁感应能力越弱，离盘片的距离就越近</li><li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li><li>硬盘必须密封</li><li>温彻斯特磁头（Winchester head head）<ul><li>磁头实际上是一个空气动力箔片，当磁盘静止时，它轻轻地停留在盘片的表面上</li><li>旋转圆盘时产生的空气压力足以使箔片上升到盘片表面上方<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e20e1bd3a341940ab123750d324233a.png" alt="e20e1bd3a341940ab123750d324233a" style="zoom: 80%;" /></div></li></ul></li></ul></li><li>读写机制<ul><li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li><li>磁头的数量<ul><li>单磁头：读写公用同一个磁头（软盘、早期硬盘）</li><li>双磁头：使用一个单独的磁头进行读写（当代硬盘）</li></ul></li><li>写入机制<ul><li>电流脉冲被发送到写入磁头</li><li>变化的电流激发出磁场</li><li>产生的磁性图案被记录在下面的盘片表面上</li><li>反转电流方向，则记录介质上的磁化方向也会反转，由此区分0和1</li></ul></li><li>读取机制<ul><li>旧的磁盘系统使用单磁头，当磁盘在磁头下方旋转时，会产生与记录的磁极相同的电流，根据电流方向读取数据。</li><li>现代磁盘用单独的读磁头<ul><li>读取磁头是由一个部分屏蔽的磁阻（MRMR）敏感器组成，其电阻取决于在其下移动的介质的磁化方向</li><li>恒定电流通过MR 敏感器时，通过电压信号检测其电阻变化</li><li>MR传感器允许更高频率的操作，实现更高的存储密度和更快的操作速度<br><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/bcb749bfc52178b14ab2f9ae805d7f6.png" alt="bcb749bfc52178b14ab2f9ae805d7f6"></li></ul></li></ul></li></ul></li><li>数据组织<ul><li>盘片上的数据组织呈现为一组同心圆环，称为<strong>磁道</strong>（track）。</li><li>数据以<strong>扇区</strong>（sector）的形式传输到磁盘或从传出磁盘（一般为512字节）。</li><li>相邻磁道之间有间隙（gap），相邻的扇区之间也留有间隙，否则磁场容易相互影响。</li><li>磁道编号从外往里递增（0~N），磁头静止时停在磁道0 外侧。</li><li>扇区划分<ul><li>恒定角速度（Constant angular velocity, CAV)：增大记录在盘片区域上的信息位的间隔，使得磁盘能够以恒定的速度扫描信息，即恒定的数据传输率<ul><li>优点：能以磁道号和扇区号直接寻址各个数据块</li><li>缺点：磁盘存储容量受到了最内层磁道所能实现的最大记录密度的限制</li></ul></li><li>多带式记录 / 多重区域记录（Multiple zone recording）：将盘面划分为多个同心圆区域，每个区域中各磁道的扇区数量是相同的，距离中心较远的分区包含的扇区数多于距离中心较近的分区<ul><li>优点：提升存储容量</li><li>缺点：需要更复杂的电路<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/8d555856ec333a4a99944c32925294f.png" alt="8d555856ec333a4a99944c32925294f" style="zoom:80%;" /></div></li></ul></li></ul></li><li>所有盘片上处于相同的相对位置的一组磁道被称为柱面(cylinder)</li></ul></li><li>格式化<ul><li>磁道必须有一些起始点和辨别每个扇区起点及终点的方法</li><li>格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取的额外数据<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213204908276.png" alt="image-20231213204908276" style="zoom:40%;" /></div></li><li>低级格式化/物理格式化：创建硬盘扇区（sector）使硬盘具备存储能力的操作<ul><li>清除数据（如果硬盘分过区，所有区都会被清除）</li><li>有损：是一种损伤性操作，它对硬盘寿命有影响</li><li>建议场景：硬盘受到外部强磁体、强磁场的影响而受到物理性损伤的情况</li></ul></li><li>高级格式化 逻辑格式化：根据用户选定的文件系统（如FAT12 、FAT16 、FAT32 、exFAT 、NTFS 、EXT2 、EXT3 等），在磁盘的特定区域写入特定数据，以达到初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作<ul><li>快速格式化：会删除目标磁盘上原有的文件分配表和根目录，不检测坏道，不备份数据，它格式化的速度很快，但不是很稳定。</li><li>一般 完全格式化：会清除目标磁盘上的所有的数据（非物理的）。重新生成引导信息、初始化文件分配表、标注逻辑坏道，一样不备份数据。</li></ul></li></ul></li><li>I/O访问时间<ul><li>寻道时间（seek time time）：初始启动时间，以及当访问臂达到速度后，遍历需跨越的磁道所需花费的时间。不是线性函数，而是包含了建立时间（把磁头放置到目标磁道之后，直到确认磁道标识的时间）。</li><li>旋转延迟（rotational delay delay）：等待响应扇区的起始处到达磁头所需的时间<ul><li>通常是磁道旋转半周所需的时间</li></ul></li><li>传送时间（transfer time time）：数据传输所需的时间，取决于磁盘的旋转速度。<br>T = 传送时间，b = 传送字节数，N = 每磁道的字节数，r = 旋转速率，单位是转/秒。<script type="math/tex; mode=display">T=\frac{b}{r N}</script></li><li>平均访问时间(T<sub>s</sub>是平均寻道时间)<script type="math/tex; mode=display">T_{a}=T_{S} + \frac{1}{2r}+\frac{b}{rN}</script></li><li>当连续访问多个相邻的磁道时，跨越磁道：<ul><li>对于每个磁道都需要考虑旋转延迟</li><li>通常只需要考虑第一个磁道的寻道时间，但在明确知道跨越每个磁道需要的时间时需要考虑</li></ul></li></ul></li><li>磁头寻道/磁盘调度<ul><li>目标：当有多个访问磁盘任务时，使得平均寻道时间最小。</li><li>常见的磁头寻道 磁盘调度算法<ul><li>先来先服务（First Come First Service Service，FCFSFCFS）</li><li>最短寻道时间优先（Shortest Seek Time First First，SSTFSSTF）</li><li>扫描/电梯（SCANS）</li><li>LOOK</li><li>循环扫描（C-SCAN）</li><li>C-LOOK</li></ul></li><li>先来先服务（FCFSFCFS）<ul><li>按照请求访问磁盘的先后次序进行处理</li><li>优点：公平简单</li><li>缺点：如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性能上很差，寻道时间长</li></ul></li><li>最短寻道时间优先（SSTF）<ul><li>优先处理起始位置与当前磁头位置最接近的读写任务</li><li>优点：每次的寻道时间最短（局部最优），平均寻道时间缩短</li><li>缺点：可能产生饥饿现象，尤其是位于两端的磁道请求</li></ul></li><li>扫描/电梯（SCAN）<ul><li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li><li>优点：性能较好，平均寻道时间短，不会产生饥饿现象</li><li>缺点：只有到最边上的磁道才能改变磁头的移动方向，对于各个位置磁道响应频率不平均</li></ul></li><li>循环扫描（C-SCAN）<ul><li>只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不做任何处理</li><li>优点：与SCAN 算法相比，对于各位置磁道的响应频率平均</li><li>缺点：与SCAN 算法相比，平均寻道时间更长</li></ul></li><li>LOOK<ul><li>SCAN算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li></ul></li><li>C-LOOK<ul><li>C-SCAN 算法的改进，只要在磁头移动方向上不再有请求，就立即让磁头返回起</li></ul></li></ul></li></ol><h4 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h4><ol><li><p>光存储器产品</p><ul><li>光盘（Compact disk，CD）</li><li>光盘只读存储器（CD read only memory，CD-ROM）</li><li>可刻录光盘（CD recordable，CD-R）</li><li>可重写光盘（CD rewritable，CD-RW）</li><li>数字多功能光盘（digital versatile disk，DVD）</li><li>可刻录DVD（DVD recordable，DVD-R）</li><li>可重写DVD（DVD rewritable，DVD-RW）</li><li>高清晰视频光盘（High definition video disk，Blu Ray DVD）<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213212222255.png" alt="image-20231213212222255" style="zoom:67%;" /></div></li></ul></li><li><p>CD和CD-ROM</p><ul><li>CD和CD-ROM 采用类似的技术，但CD-ROM 更加耐用且有纠错功能</li><li>制造方法<ul><li>用精密聚焦的高强度激光束制造一个母盘</li><li>以母盘作为模板压印出聚碳酸酯的复制品</li><li>在凹坑表面上镀上一层高反射材料（一般采用铝，HQCD 采用银合金）</li><li>使用丙烯酸树脂保护高反射材料</li><li>在丙烯酸树脂层上用丝网印刷术印制标签</li></ul></li><li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD 或CD ROM 处读取信息<ul><li>如果激光束照在凹坑（pit）上，由于凹坑表面有些不平，因此光被散射，反射回低强度的激光</li><li>如果激光束照在台 面（land）上，台的表面光滑平坦，反射回来的是高强度的激光</li><li>光电传感器检测凹坑和台之间的变化，凹坑的起点或终点代表“11”，没有高度变化则记为“00”。</li></ul></li><li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同<ul><li>从内向外扫描，角速度逐渐变小</li><li>凹坑被激光以恒定线速度读出<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/3d2877d801e717f0a82870495705abe.png" alt="3d2877d801e717f0a82870495705abe" style="zoom:80%;" />    </div></li></ul></li><li>优点<ul><li>存储有信息的光盘可以廉价地进行大规模复制</li><li>光盘更换方便</li><li>寿命长       </li></ul></li><li>缺点<ul><li>它是只读的，不能更改</li><li>其存取时间比磁盘存储器慢得多</li></ul></li></ul></li><li>CD-R（写一次）<ul><li>包含了一个染色层，用于改变反射率，并且由高强度激光激活</li><li>生成的盘既能在 CD R 驱动器上也能在CD ROM 驱动器上读出</li></ul></li><li>CD-RW（写多次）<ul><li>使用了一种在两种不同相位状态下有两种显著不同反射率的材料，激光束能改变这种材料的相位状态</li><li>材料老化最终会永久失去相位可变的特性，当前的材料可用于50 万次到100 万次的擦除</li></ul></li><li>数字多功能光盘（DVD）<ul><li>DVD vs.CD<ul><li>DVD上的位组装更紧密：光道间隙，凹坑间距（容量达到4.7GB）</li><li>DVD采用双层结构：设有半反射层，可以通过调整焦距读取每一层（容量达到8.5GB）</li><li>DVD-ROM 可以用两面记录数据（容量达到17GB17GB）</li><li>DVD的激光束更细，所以能读DVD 的设备可以读CDCD，但反过来不行</li></ul></li><li>DVD-R 和DVD-RW</li></ul></li><li>高清晰光盘<ul><li>通过使用更短波长的激光（在蓝 紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li></ul></li></ol><h4 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h4><ol><li>使用与磁盘类似的记录和读取技术</li><li>记录：介质是柔韧的聚酯薄膜带，外涂磁性材料</li><li>读取<ul><li>磁带：顺序读取（sequential access）</li><li>磁盘：直接读取（direct access）</li><li>并行记录 vs. 串行记录（蛇形记录）</li><li>并行+串行<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213220640293.png" alt="image-20231213220640293" style="zoom:67%;" /></div></li></ul></li></ol><h4 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h4><ol><li>U盘（USB flash disk disk）<ul><li>采用了快闪存储器，属于非易失性半导体存储器</li><li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li></ul></li><li>固态硬盘（Solid State Disk/Drive Drive）<ul><li>与U 盘没有本质区别：容量更大，存储性能更好</li><li>与硬磁盘存储器相比：抗振性好，无噪声，能耗低，发热量低</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第8讲-高速缓冲存储器</title>
      <link href="/2023/12/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC8%E8%AE%B2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC8%E8%AE%B2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第8讲-高速缓冲存储器"><a href="#第8讲-高速缓冲存储器" class="headerlink" title="第8讲-高速缓冲存储器"></a>第8讲-高速缓冲存储器</h2><span id="more"></span><h3 id="Cache的目的和基本思路"><a href="#Cache的目的和基本思路" class="headerlink" title="Cache的目的和基本思路"></a>Cache的目的和基本思路</h3><ol><li>问题：CPU的速度比内存的速度快，且两者差距不断扩大—内存墙。</li><li>解决：CPU和内存之间增加Cache。<ul><li>解决内存墙带来的CPU和主存协作问题</li><li>在使用主存（相对大而慢）之余，添加一块小而快的cache</li><li>Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块</li><li>Cache中存放了主存中的部分信息的“副本”</li></ul></li></ol><p><img src="74050a5ff91819f99d4608f61d2be55.png" alt="74050a5ff91819f99d4608f61d2be55" style="zoom:75%;" /></p><h3 id="Cache的工作流程"><a href="#Cache的工作流程" class="headerlink" title="Cache的工作流程"></a>Cache的工作流程</h3><ol><li><p>检查（Check）：当CPU试图访问主存中的某个字时，首先检查这个字是否在cache中</p></li><li><p>检查后分两种情况处理：</p><ul><li>命中（Hit）：如果在cache中，则把这个字传送给CPU</li><li>未命中（Miss）：如果不在cache中, 则将主存中包含这个字固定大小的块（block）读入cache中，然后再从cache传送该字给CPU</li></ul></li><li><p>如何判断是命中还是未命中?</p><ul><li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li></ul></li><li><p>局部性原理</p><ul><li>定义：处理器频繁访问主存中相同位置或者相邻存储位置的现象。</li><li>时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同存储位置的信息）</li><li>空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据<ul><li>顺序局部性：当数据被线性排列和访问时，出现的空间局部性的一种<br>特殊情况</li><li>例如：遍历一维数组中的元素</li></ul></li><li>利用“时间局部性”：将未命中的数据在返回给CPU的同时存放在Cache中，以便再次访问时命中。</li><li>利用“空间局部性”：将包含所访问的字的块存储到Cache中，以便在访问相邻数据时命中。</li></ul></li><li><p>平均访问时间</p><ul><li>假设p是命中率， 𝑇<sub>c</sub> 是cache的访问时间， 𝑇<sub>M</sub> 是主存的访问时间，使用cache时的<br>平均访问时间𝑇<sub>A</sub>为<script type="math/tex; mode=display">𝑇_{A} = 𝑝×𝑇_{C} + (1 − 𝑝) × (𝑇_{C} + 𝑇_{M})= 𝑇_{C} + (1 − 𝑝)×𝑇_{M}</script></li><li>命中率p越大， 𝑇<sub>c</sub>越小， 效果越好。</li><li>如果想要𝑇<sub>A</sub>&lt; 𝑇<sub>M</sub>, 必须要求p&gt;𝑇<sub>C</sub> /𝑇<sub>M</sub>。</li><li>难点：cache的容量远远小于主存的容量（随机访问时𝑝 = Cache容量/主存容量）</li></ul></li><li><p>Cache未命中的原因</p><ol><li>义务失效（Compulsory Miss）/ 冷启动失效（Cold Start Miss）<ul><li>第一次访问一个块时</li><li>例如：第一次访问一个数组，会发生义务失效</li></ul></li><li>容量失效（Capacity Miss）<ul><li>Cache无法保存程序访问所需的所有数据块，则当某数据块被替换后，又重新被访问，则发生失效</li><li>例如： cache大小为8KB，如果需要重复访问一个16KB大小的数组，数组无法全部放入cache，会发生容量失效</li></ul></li><li>冲突失效（Conflict Miss）<ul><li>多个存储器位置映射到同一Cache位置</li><li>例如：有两个4KB大小的数组都映射到了相同的地址，需要来回访问，则发生冲突失效</li></ul></li></ol></li></ol><h3 id="Cache的设计要素"><a href="#Cache的设计要素" class="headerlink" title="Cache的设计要素"></a>Cache的设计要素</h3><h4 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h4><ol><li>实现主存块到cache行的映射</li><li>块号，块内地址</li><li>映射方式的选择会影响cache的组织结构<ul><li>直接映射</li><li>关联映射</li><li>组关联映射</li></ul></li><li>直接映射<ul><li>把每个主存块映射到唯一可能得高速缓存行。<script type="math/tex; mode=display">i = j\mod m</script>其中：i=高速缓存行号，j=主存块号，m=高速缓存行数</li><li>优点：简单且便宜</li><li>缺点：对任何给定的块都只有固定的高速缓存位置。因此，如果一个程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断地被交换到cache中，cache的命中率将会降低，即发生冲突失效。称为抖动现象。</li><li>适合大容量cache：行数变多，发生冲突失效的概率降低； 硬件电路简单，增大容量对𝑇<sub>c</sub>的影响不明显</li><li>地址计算：<ul><li>地址长度 =（s+w）位</li><li>块大小 =  行大小 = 2<sup>w</sup></li><li>主存中块的数量 = 2<sup>s</sup></li><li>Cache中的行数 = m = 2<sup>r</sup></li><li>Cache容量 = 行大小 * 行数 = 2<sup>w+r</sup></li><li>标记长度 = s - r</li><li>Cache行号长度 = r</li><li>块内地址长度 = w</li></ul></li></ul></li></ol><p><img src="eb4b064e6488289e1eafa9b63784dab-17023862155193.png" alt="eb4b064e6488289e1eafa9b63784dab"></p><ol><li>关联映射（全相联映射）<ul><li>允许每个主存块加载到任何高速缓存行</li><li>优点：避免抖动。</li><li>缺点：实现复杂；搜索代价大。</li><li>适合容量较小的Cache：小容量更容易发生冲突失效；小容量检查的时间短。</li><li>地址计算：<ul><li>地址长度 = （s + w）位</li><li>标记长度 = s</li><li>快内地址长度 = w</li></ul></li></ul></li></ol><p><img src="ccd0f4d2f8dd8ee56fa0a949f118f48.png" alt="ccd0f4d2f8dd8ee56fa0a949f118f48"></p><ol><li><p>组关联映射</p><ul><li>一种折中方案，结合了直接映射和关联映射的优点和缺点。</li><li>k路组相联映射<script type="math/tex; mode=display">m=v\times k</script><script type="math/tex; mode=display">i=j \mod v</script>其中，i=cache组号，j=主存块号，v=cache组数，m=cache行数，k=每组行数。</li><li>地址计算<ul><li>地址长度 = （s+w）位</li><li>组中行数 = k</li><li>组数 = v = 2<sup>d</sup></li><li>Cache中行数 = m = k*v</li><li>标记长度 = s - d</li><li>组号长度 = d </li><li>块内地址长度 = w<img src="《计算机组织结构》期末复习-第8讲-高速缓冲存储器/5ba3c5f66e0dde4ee4c57550709aa73.png" alt="5ba3c5f66e0dde4ee4c57550709aa73" style="zoom:67%;" /></li></ul></li></ul></li><li><p>三种映射方式比较</p><ul><li>关联度（Correlation）：一个主存块映射到cache中可能存放的位置个数<ul><li>直接映射：1</li><li>关联映射：m</li><li>组关联映射：k</li></ul></li><li>关联度越低，命中率越低，</li><li>关联度越低，判断是否命中的时间越短。</li><li>关联度越低，标记所占额外空间开销越小。</li></ul></li></ol><h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4><ol><li>一旦cache行被占用，当新的数据块装入cache中时，原先存放的数据块将会被替换掉。</li><li>对于直接映射，每个数据块都只有唯一对应的行可以放置，没有选择的机会。</li><li>对于关联映射和组关联映射，每个数据块被允许在多个行中选择一个进行放置，就需要替换算法来决定替换哪一行中的数据块</li><li>常用替换策略：<ul><li>最近最少使用算法（Least Recently Used, LRU）</li><li>先进先出算法（First In First Out, FIFO）</li><li>最不经常使用算法（Least Frequently Used, LFU）</li><li>随机替换算法（Random）</li></ul></li><li>最近最少使用算法（LRU）<ul><li>替换掉在cache中最长时间未被访问的数据块。</li><li>实现：每个cache行添加LRU位，长度为log<sub>2</sub>k位。<ul><li>命中时，被访问的行的计数器清零，比其低的计数器加 1，其余不变。</li><li>未命中且该组还有空闲行时，则新装入的行的计数器设为0，其余全加1。</li><li>未命中且该组无空闲行时，计数值最大的那一行中的主存块被淘汰新装入的行的计数器设为0，其余加1。从计数器变化规则可以看出，计数值越高的行中的主存块越是最近最少用。</li></ul></li><li>缺点：当程序中的分块局部化范围(即程序中某段时间集中访问的存储区)超过了 cache 组的大小时，命中率可能变得很低。例如，假设上述例子中的访存地址流是1，2，3，4，1，2，3，4，1，2，34而cache每组只有3行，那么命中率为0。这种现象称为颠簸(pingpong)或抖动(thrashing)</li></ul></li><li>先进先出算法（FIFO）<ul><li>策略：替换掉在Cache中停留时间最长的块。</li><li>实现：时间片轮转法或环形缓冲技术。<ul><li>每行包含<strong>一</strong>个标识位</li><li>当同一组中的某行被替换时，将其标识位设为1，同时将其下一行的标识位设为0</li><li>如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为0</li><li>当将新的数据块读入该组时，替换掉标识位为0的行中的数据块</li></ul></li></ul></li><li>最不经常使用算法（LFU）<ul><li>策略：替换掉cache中被访问次数最少的数据块。</li><li>实现：为每一行设置计数器</li></ul></li><li>随机替换算法（Random）<ul><li>策略：随机替换cache中的数据块</li><li>实现：随机替换</li><li>性能上只稍逊于其他算法，而且代价低。</li></ul></li></ol><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><ol><li><p>缓存命中时的写策略。当cache中的某个数据块被替换时，需要考虑该数据块是否被修改。</p><ul><li>如果没被修改，则该数据块可以直接被替换掉。</li><li>如果被修改，则在替换掉该数据块之前，必须将修改后的数据块写回到主存中对应位置。</li><li>写直达（Write Through）：所有写操作都同时对cache和主存进行。<ul><li>优点：确保主存中的数据总是和cache中的数据一致，总是最新的（例如多CPU同步的场景）。</li><li>缺点：产生大量的主存访问，减慢写操作。</li></ul></li><li>写回法（Write Back）：先更新cache中的数据，当cache中某个数据块被替换时，如果它被修改了，才被写回主存。<ul><li>利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改。</li><li>优点：减少了访问主存的次数。</li><li>缺点：部分主存数据可能不是最新的（例如未发生替换但需要读主存的场景）。</li></ul></li></ul></li><li><p>缓存未命中时的写策略。</p><ul><li>写不分配（Write Non-Allocate）：直接将数据写入主存，无需读入cache。<ul><li>优点：避免cache和主存中的数据不一致。</li><li>通常搭配：写直达。</li></ul></li><li>写分配（Write Allocate）：将数据所在的块读入cache后，在cache中更新内容。<ul><li>优点：利用了cache的高速特性，减少写内存次数。</li><li>通常搭配：写回法。</li></ul></li></ul></li></ol><h4 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h4><ol><li>假设从行的大小为一个字开始，随着行大小的逐步增大，则Cache命中率会增加<ul><li>数据块中包含了更多周围的数据，每次会有更多的数据作为一个块装入cache中</li><li>利用了空间局部性</li></ul></li><li>当行大小变得较大之后，继续增加行大小，则Cache命中率会下降<ul><li>当Cache容量一定的前提下，较大的行会导致Cache中的行数变少，导致装入cache中的数据块数量减少，进而造成数据块被频繁替换</li><li>每个数据块中包含的数据在主存中位置变远，被使用的可能性减小</li></ul></li><li>行大小与命中率之间的关系较为复杂<ul><li>行太小，行数太多反时间局部性</li><li>行太大，行数太少反空间局部性</li></ul></li></ol><h4 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h4><ol><li><p>一级v.s.多级</p><ul><li>一级<ul><li>将cache与处理器置于同一芯片（片内cache）</li><li>减少处理器在外部总线上的活动，从而减少了执行时间</li></ul></li><li>多级<ul><li>当L1未命中时，减少处理器对总线上DRAM或ROM的访问</li><li>使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2 cache结合到处理器芯片上</li></ul></li></ul></li><li><p>统一v.s.分立</p><ul><li>统一（指令数据混合式）<ul><li>更高的命中率，在获取指令和数据的负载之间自动进行平衡。</li><li>只需要设计和实现一个cache。</li></ul></li><li>分立（指令和数据分离）<ul><li>消除cache在指令的取值/译码单元和执行单元之间的竞争，在任何基于指令流水线的设计中都是重要的。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第7讲-内部存储器</title>
      <link href="/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第7讲-内部存储器"><a href="#第7讲-内部存储器" class="headerlink" title="第7讲-内部存储器"></a>第7讲-内部存储器</h2><span id="more"></span><h3 id="存储器（Memory）"><a href="#存储器（Memory）" class="headerlink" title="存储器（Memory）"></a>存储器（Memory）</h3><ol><li>定义：存储器（Memory）由一定数量的单元构成，每个单元可以被唯一标识，每个单元都<br>   有存储一个数值的能力<ul><li>地址：单元的唯一标识符（采用二进制）</li><li>地址空间：可唯一标识的单元总数</li><li>寻址能力：存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间<br>— 大多数存储器是字节（8bit）寻址的，32位计算机的最大寻址空间为4GB</li></ul></li><li>层次结构<ul><li>主板内存储器：寄存器，Cache，主存。</li><li>主板外存储器：磁盘，CD-ROM，CD-RW，DVD-RW，DVD-RAM。</li><li>离线存储器：磁带<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231211215347325.png" alt="image-20231211215347325" style="zoom:100%;" /></div></li></ul></li></ol><h3 id="AND-OR锁存器"><a href="#AND-OR锁存器" class="headerlink" title="AND-OR锁存器"></a>AND-OR锁存器</h3><p>参考文章：<a href="https://www.zhihu.com/question/373693400">谁能告诉我AND-OR锁存器原理？ - 知乎 (zhihu.com)</a><br>先解释OR锁<strong>OR锁：</strong></p><p><img src="v2-eea6e461a97e4273e93fcec13276ebba_720w-17030664435721.webp" alt="img"><br>OR门B输入和输出连接。<br>INIT为初始状态A=B=0；<br>当A=1，B=0时，OUTPUT变为1同时将B变为1；<br>此时，当A变回0，OUTPUT仍为1（被锁住）。</p><p><strong>AND锁：</strong></p><p><img src="v2-0cf2e34ec4c12654f5c11156192d7406_720w.webp" alt="img"></p><p>AND门B输入和输出连接。</p><p>INIT为初始状态A=B=1；</p><p>当A=0，B=1时，OUTPUT变为0同时将B变为0；</p><p>此时，当A变回1，OUTPUT仍为0（被锁住）。</p><p><strong>AND-OR锁存器：</strong></p><p><img src="v2-1995e8bd1afa8bd20bac2f4098ae6cce_720w.png" alt="img"></p><p>锁存器有两个输入SET和RESET，其<a href="https://www.zhihu.com/search?q=电路&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1093469618}">电路</a>如上图连接。</p><p>INIT为初始状态SET=RESET=0，最终输出OUTPUT=0；</p><p>当SET=1，RESET=0（SET激活、RESET未激活）时，将输出变为1，锁住（可看出SET变为0，结果不变）</p><p>此时RESET激活（SET=1，RESET=1），将输出重新变为0，即为重置。</p><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><ol><li>用半导体芯片作主存储器是目前的主流做法</li><li><p>位元（memory cell）</p><ul><li>半导体存储器的基本元件，用于存储1位数据</li><li>特性<ol><li>呈现两种稳态（或半稳态）：分别表示二进制的0和1</li><li>它们能够至少被写入（write）数据一次：用来设置状态</li><li>它们能够被读取（read）来获得状态信息  </li></ol></li><li>操作<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/03ce4ce3bddda304f78a7874c4fbc21.png" alt="03ce4ce3bddda304f78a7874c4fbc21" style="zoom:80%;" /></li></ul></li><li><p>半导体存储器类型</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">存储器类型</th><th style="text-align:center">种类</th><th style="text-align:center">可擦除性</th><th style="text-align:center">写机制</th><th style="text-align:center">易失性</th></tr></thead><tbody><tr><td style="text-align:center">随机存取存储器（RAM）</td><td style="text-align:center">读写存储器</td><td style="text-align:center">电可擦除，字节级</td><td style="text-align:center">电</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">只读存储器（ROM）</td><td style="text-align:center">只读存储器</td><td style="text-align:center">不可擦除</td><td style="text-align:center">掩膜</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">可编程ROM（PROM）</td><td style="text-align:center">只读存储器</td><td style="text-align:center">不可能</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">可擦除ROM（EPROM）</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">紫外线可擦除，芯片级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">电可擦除PROM（EEPROM）</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">电可擦除，字节级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">快闪存储器</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">电可擦除，块级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr></tbody></table></div><h4 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h4><ol><li>Random-Access Memory（RAM）<ul><li>随机访问：对存储器中任意数据的访问所花费的时间与数据所在位置无关</li></ul></li><li>特性<ul><li>可以简单快速地进行读/写操作</li><li>易失的（Volatile）</li></ul></li><li>类型<ul><li>静态RAM（SRAM）：Static RAM（1963年由Robert Norman在仙童发明）</li><li>动态RAM（DRAM）：Dynamic RAM（1967年由Robert Dennard在IBM发明）</li></ul></li><li>静态RAM（SRAM）<ol><li>用传统的触发器逻辑门结构来存储二进制。只要有电源供电，SRAM就会保存数据（断电信息丢失）。常用于Cache。      </li><li>典型结构：六管静态MOS管存储元件   <ol><li>状态   <ul><li>1状态：C1点为高电平，C2点为低电平，此时T2、T3导通，T1、T4截止。   </li><li>0状态：C1点为低电平，C2点为高电平，此时T2、T3截止，T1、T4导通。   </li></ul></li><li>信息保持：字选择线（地址线）加低电平，T5、T6截止，触发器与外界隔离，信息保持不变。</li><li>读出：首先在两根位线上加高电平，地址线加高电平，T5、T6导通。若为状态1，T2导通，所以有电流从位线$\overline{\text{B}}$经过T6、T2流入地，位线$\overline{\text{B}}$上产生负脉冲。反之，若为状态0，位线B上产生负脉冲。</li><li>写入：地址线加高电平，T5、T6导通。若写入1，位线$\overline{\text{B}}$加低电平，T3导通，T1截止，C1电位升高，完成写1.若写入，位线B加低电平，T4导通，T2截止，C2电位升高，完成写0.   </li><li>即使元件不读写时，保持状态1时，T2、T3导通，仍有电流经T3、T2流向地线，因此功耗大。<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/cpt7-4.png" alt="img" style="zoom:80%;" /></li></ol></li></ol></li><li>动态RAM（DRAM）<ol><li>DRAM的存储单元把数据存储为电容上的电荷。电容上的电荷存在或不存在被解释为状态1或0。   </li><li>写入：字选择线加高电平，T导通。若写1，位线加高电平，给电容充电；若写0，位线加低电平，给电容放点。   </li><li>读出：字选择线加高电平，T导通。若原存1，电容放点，位线产生电流；若原存0，则无电流流过。放电后，电容点位下降，需要重写，成为“再生”操作。由于电容放点产生的电流不会很大，需要放大器增大电流。</li><li>电容存在漏电效应，一段时间后电荷会流失，导致数据丢失。因此需要定时刷新。<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/6aee1147c0a2b1dcbb6aad2260ac01a.png" alt="6aee1147c0a2b1dcbb6aad2260ac01a" style="zoom:80%;" /></li></ol></li><li>SRAM与DRAM的对比<br>|              |     SRAM     | DRAM  |<br>| :—————: | :—————: | :—-: |<br>|  <strong>易失性</strong>  |     易失     | 易失  |<br>| <strong>存储单元</strong> | 双稳态触发器 | 电容  |<br>|  <strong>集成度</strong>  |      低      |  高   |<br>|   <strong>功耗</strong>   |      高      |  低   |<br>|   <strong>速度</strong>   |      快      |  慢   |<br>|   <strong>刷新</strong>   |      无      |  有   |<br>|   <strong>价格</strong>   |    $1/MB     | $1/GB |</li></ol><h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ol><li>只读存储器（ROM）<ol><li>Read-only memory（ROM），一种可以长期保存信息的存储器，具有断电后信息仍可继续保存的特点，在正常工作时只可读取数据，而不能写入数据。</li><li>特性<ul><li>非易失性：不要求供电来维持数据</li><li>可读，但不能写入新数据</li></ul></li><li>应用：微程序设计，常用函数的库子例程，系统程序，函数表</li><li>问题：<ul><li>数据插入步骤包含了相对较大的固定成本，不论制造的是特定ROM的一个还是几千个副本。</li><li>无出错处理机会：如果有一位出错，整批的ROM芯片只能报废。</li><li>用户无法写入数据：唯一的数据写入机会再出厂时完成。</li></ul></li></ol></li><li>可编程ROM（PROM）<ol><li>Programmable ROM（PROM），写处理的执行是电气化的，可以由供应商或客户在原始芯片制作出来后执行。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/c45a7bcd8f2fe3922ee186b9169abe8.png" alt="c45a7bcd8f2fe3922ee186b9169abe8" style="zoom:50%;" /></div></li><li>特性<ul><li>非易失的</li><li>只能被写入一次。写入过程使用电信号执行，需要特殊设备来完成写或编程过程。   </li></ul></li><li>与ROM的对比<ul><li>PROM提供了灵活性和方便性。</li><li>ROM在大批量生产领域仍具有吸引力。<h4 id="以读为主存储器"><a href="#以读为主存储器" class="headerlink" title="以读为主存储器"></a>以读为主存储器</h4></li></ul></li></ol></li><li>Read-Mostly Memory</li><li>特性<ul><li>非易失的</li><li>写操作与读操作相比，较为困难</li></ul></li><li>应用：读操作比写操作频繁地多且又需要非易失性存储器的场景</li><li>类型：EPROM、EEPROM、闪存</li><li>光可擦除可编程只读存储器（EPROM）<ol><li>Erasable programmable read-only memory（EPROM）</li><li>特性<ul><li>电写入（1- &gt;0）：漏极和选择栅加高压，电子温度上升变为热电子，上升穿过氧化层，进入浮栅。P型半导体的负电子被浮栅中的电子排斥，原理绝缘层，效应管不导通，数据被写入0。</li><li>光擦除（0-&gt;1)：将封装芯片暴露在紫外线下，照射使电子获得能量，逃出浮栅，场效应管导通，所有单元变回状态1。每次擦除需要约20分钟。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/95b95b545a8e205757cc1393d05ab4a.png" alt="95b95b545a8e205757cc1393d05ab4a" style="zoom: 50%;" /></div></li></ul></li></ol></li><li>电可擦除可编程只读存储器（EEPROM）<ol><li>Electrically erasable programmable read-only memory（EEPROM）。目前用于车载摄像头和传感器出厂设置、安全气囊的弹出记录以及需要长时间通电的工业自动化设备和服务器的数据记录系统等；在DDR SDRAM中也会使用EEPROM，用于保存内存的相关信息，计算机会在开机自检时会读取这些信息</li><li>特性<ul><li>可以随时写入而不删除之前的内容；只更新寻址到的一个或多个字节。</li><li>电写入（1-&gt;0）：源极和漏极接地，控制栅接高电平，电子进入浮栅。写操作每字节需要大约5ms，而读一个字节大约0.5微秒。</li><li>电擦除（0-&gt;1）：源极和控制栅接地，漏极接高电平，浮栅中电子进入衬底。每次擦除仅需4~6ms，可擦除百万次。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/b55108f28bef2e7de730bce977c3680.png" alt="b55108f28bef2e7de730bce977c3680" style="zoom:50%;" /></div></li></ul></li></ol></li><li>快闪存储器（Flash Memory）<ol><li>特性<ul><li>电可擦除：与EEPROM原理类似，优于EPROM。</li><li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM。</li><li>需要先擦除再写入。</li></ul></li><li>分类<ul><li>NOR Flash：数据线和地址线分开，可以读任意字节。</li><li>NAND Flash：数据线可地址线共用，只能按页读取。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/70d77704608eec0f638c9073f3ed293.png" alt="70d77704608eec0f638c9073f3ed293" style="zoom:50%;" /></div></li></ul></li></ol></li><li>各类ROM 对比<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/0f98bebd96a8cbcd7ee9b3b692a4aec.png" alt="0f98bebd96a8cbcd7ee9b3b692a4aec" style="zoom:67%;" /></div></li></ol><h3 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h3><h4 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h4><ol><li>寻址单元（Addressable unit）：由若干相同地址的位元组成。</li><li>寻址模式：字节（Byte）：常用；字（Word）：专门用途的计算机。</li></ol><h4 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h4><ol><li><p>芯片引脚</p><ul><li>Address：A0 - A19</li><li>Data：D0 - D7</li><li>Vcc：电源</li><li>Vss：地线</li><li>CE：芯片允许引脚</li><li>Vpp：程序电压</li><li>WE：写允许</li><li>OE：读允许</li><li>RAS：行地址选通</li><li>CAS：列地址选通<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/f94ea025cf9e0640b3c9ed1137bf7ba.png" alt="f94ea025cf9e0640b3c9ed1137bf7ba" style="zoom:70%;" /></div></li></ul></li><li><p>存储阵列（Memory Array）：由大量寻址单元组成</p><div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231212180159945.png" alt="image-20231212180159945" style="zoom: 50%;" /></div></li><li>如何寻址<ol><li>获得总线控制权。</li><li>CPU向存储阵列发送地址。</li><li>时序和控制单元将地址分解为行地址或列地址。</li><li>向行地址缓冲器发出行地址。</li><li>行译码器选中行。</li><li>数据进入行放大器。</li><li>向列地址缓冲区发出列地址。</li><li>列译码器选出对应列。</li><li>数据进入数据输入缓冲区。</li></ol></li><li>如何刷新<ol><li>约束：刷新会占用片选线、地址线、地址译码器</li><li>刷新时只给各芯片送行地址和RAS信号，这样一行的所有元素被选中并进行读出操作。因此刷新按行进行，一次可刷新一行。2048x2038x4位的芯片只要2048次刷新。</li><li>三种刷新方式<ul><li>集中式刷新<ul><li>停止读写操作，并逐行刷新</li><li>刷新时无法操作内存（死区）</li></ul></li><li>分散式刷新<ul><li>在每个存储周期中，当读写操作完成时进行刷新</li><li>一次读写刷新一行，逐行刷新</li><li>会增加每个存储周期的时间</li></ul></li><li>异步刷新<ul><li>每一行各自以固定间隔（小于最大刷新周期，毫秒级）刷新</li><li>将DRAM的刷新安排在CPU对指令的译码阶段，可有效避免死区</li><li>效率高：常用<h4 id="DDR-DRAM"><a href="#DDR-DRAM" class="headerlink" title="DDR DRAM"></a>DDR DRAM</h4></li></ul></li></ul></li></ol></li><li>异步DRAM与同步DRAM<ul><li>异步DRAM：传统DRAM是异步的。读写操作时，处理器向内存提供地址和控制电平。接着进入访问延迟时间，这段时间内DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，处理器只能等待这段延迟，即存取时间，从而降低了系统性能。</li><li>同步DRAM：SDRAM在系统时钟控制下移入和移出数据。处理器或其他主机发出指令和地址信息，并有SDRAM锁存。然后SDRAM在一定的时钟周期后响应。同时，当SDRAM处理请求时，主设备可以安全地执行其他任务。</li></ul></li><li>DRAM读写周期<ol><li>读周期<br>（1）行地址必须在$\overline{\text{RAS}}$信号有效之前送到芯片的地址输入端。<br>（2）$\overline{\text{CAS}}$信号应滞后$\overline{\text{RAS}}$一段时间,并滞后列地址送到芯片地址输入端的时间。<br>（3）$\overline{\text{RAS}}$、$\overline{\text{CAS}}$的时延分别为 t<sub>RAS</sub>和 <sub>CAS</sub>，它们应有足够的宽度。<br>（4）$\overline{\text{WE}}$信号为高电平，并在$\overline{\text{CAS}}$有效之前建立。<br>（5）每次读后要再生，即重新写人一次。<ol><li>写周期：在写周期中,$\overline{\text{RAS}}$与$\overline{\text{CAS}}$之间的关系以及与地址信息间的关系和读周期相同但还有两点不同。<br>（1）$\overline{\text{WE}}$信号为低电平，并在$\overline{\text{CAS}}$信号有效之前建立。（$\overline{\text{WE}}$上有一条上划线，表示取反，$\overline{\text{WE}}$=0时，表示写使能有效）<br>（2）写数据必须在$\overline{\text{CAS}}$有效之前出现在D端。    <div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e95c8b405fbb5f2f6a13581cd132445.png" alt="e95c8b405fbb5f2f6a13581cd132445" style="zoom:60%;" /></div></li></ol></li></ol></li><li>SDRAM读写<br> SDRAM的每一步操作都在外部系统时钟CLK 的控制下进行支持突发(burst)传输方式。只要在第一次存取时给出首地址，以后按地址顺序读写即可，而不再需要地址建立时间和行列预充电时间就能快速连续地从行缓冲器(row buffer)中输出一连串数据。行缓冲器用来缓存指定行中每一行的数据，通常用SRAM 元件实现。内部的工作方式寄存器(也称模式寄存器)可用来设置传送数据的长度以及从收到读命令(与CAS 信号同时发出)到开始传送数据的延迟时间等前者称为突发长度(burst length，BL)，后者称为CAS潜伏期(CAS latency，CL)。根据所设定的 BL和CL，CPU 可以确定何时开始从总线上取数以及连续取多少个数据在开始的第一个数据读出后，同一行的所有数据都被送到行缓冲器中，因此，以后每个时钟可从SDRAM读取一个数据，并在下一个时钟内通过总线传送到 CPU。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e408d144336de24dd3b59c2a6482d6c.png" alt="e408d144336de24dd3b59c2a6482d6c" style="zoom:50%;" /></div></li><li>DDR SDRAM<ul><li>Double Data Rate：每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在下降沿。</li><li>通过三种途径获得更高的数据速率，DDR -&gt; DDR2 -&gt;  DDR3 -&gt; DDR4 -&gt; DDR5<ul><li>数据传输被同步到时钟的上升沿和下降沿，而不仅仅在上升沿，使得数据速率加倍。</li><li>使用更高的总线时钟频率。</li><li>使用缓冲方案。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/image-20231212192727683.png" alt="image-20231212192727683" style="zoom:100%;" /> <img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/image-20231212192717520.png" alt="image-20231212192717520" style="zoom:100%;" /><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/d9de3049edd4019913d6b9fecaec64e.png" alt="d9de3049edd4019913d6b9fecaec64e" style="zoom:100%;" /><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/762c7f6add775ffee42a7e0c099b8b4.png" alt="762c7f6add775ffee42a7e0c099b8b4" style="zoom:100%;" /></div></li></ul></li></ul></li></ol><h4 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h4><ol><li>位扩展：地址线不变，数据线增加<ul><li>使用8 块4K*1 bit 的芯片组成4K*8 bit的存储器</li></ul></li><li>字扩展：地址线增加，数据线不变<ul><li>使用4 个16K*8 bit 的芯片组成64K*8bit 的存储器</li></ul></li><li>字、位同时扩展：地址线增加，数据线增加<ul><li>使用8 个16K*4 bit 的芯片组成64K*8bit 的存储器<div align="center"><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/399904474e1ad0c8309a6027406e9b7.png" alt="399904474e1ad0c8309a6027406e9b7" style="zoom:80%;" /></div></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20231210周记</title>
      <link href="/2023/12/10/20231210%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/10/20231210%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本周的算法学习主要是刷题+看书，没有学什么新算法，只零碎地学了一些小的知识点。</p><span id="more"></span><h3 id="二分模版"><a href="#二分模版" class="headerlink" title="二分模版"></a>二分模版</h3><p>虽然以前二分写的不少，但从来没有一次写对过，看了lyd的书之后才知道有两种二分模版。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &gt;= x) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">// 避免进入l = mid的死循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模版二</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt;= x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;  <span class="comment">// 避免进入 r = mid的死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="货仓选址问题"><a href="#货仓选址问题" class="headerlink" title="货仓选址问题"></a>货仓选址问题</h3><p>数轴上有N家商店，坐标分别为A[1]~A[N]，选一个位置建货仓，令货仓到每家商店的距离之和最小。</p><ul><li>货仓必须建在中位数处，证明不难，思考一下。</li></ul><h3 id="矩形面积问题"><a href="#矩形面积问题" class="headerlink" title="矩形面积问题"></a>矩形面积问题</h3><p>复习了一下这几道题，很典型。</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形 - 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/largest-submatrix-with-rearrangements/">1727. 重新排列后的最大子矩阵 - 力扣（LeetCode）</a></p><p>顺便记录一下，力扣400题达成！</p><p><img src="d497adb09462806195c69527368fd00.png" alt="d497adb09462806195c69527368fd00" style="zoom:50%;" /></p><h3 id="第32次CSP认证"><a href="#第32次CSP认证" class="headerlink" title="第32次CSP认证"></a>第32次CSP认证</h3><p>今天去考了csp认证，感觉题目比上几次稍微难一点。</p><ul><li>第一题，签到题，忘了，100分。</li><li>第二题，分解质因数，这周刚刚做过哈哈哈，100分。</li><li>第三题，树。哭了感觉这次第三题不是模拟而是算法了。暴力解60分，加了记忆化还是60分，不会优化了。。。</li><li>第四题，暴力，35分。</li><li>第五题，试图暴力，但找不出哪里写错了，0分。</li></ul><p>最后295分，还以为能上300的。。。问题不大，毕竟氪了西西艾弗的会员，明年再来！</p><h3 id="杂念"><a href="#杂念" class="headerlink" title="杂念"></a>杂念</h3><p>准备了一段时间的csp也结束了，之后学算法的时间应该会缩短了，因为期末周快到了呜。接下来保持每天3道以上的刷题，然后花点时间继续啃lyd的书。其余更多的时间就要用来准备期末考了。另外，为了应对机组机考，下周进行Java复健，刷题尽量写爪哇吧，毕竟一个学期都没咋写过了。</p><p>最近读完了《围城》。读书时只顾情节，不及品悟“围城”的含义。直到最后戛然而止，心想“围城”何在？原来“围城”处处在。方鸿渐一次又一次冲出“围城”，却又进入另一个“围城”。他不断辗转，希望通过“出城”来改善处境，不料处境丝毫未见好转。人生在世，难免有处境不顺的时候。有人埋怨环境，认为是地方不好，以为换一个环境就能过的更好。然而事实往往是，当他们换了一个环境之后，又觉得还是不够好，于是不断辗转，最后却还是没过上称心如意的生活。其实，“围城”真的存在吗？自己的处境，真的是环境造成的吗？我想，围住自己的不是外部的城，而是自己的心墙。一个人内心苍白，无论在哪都无趣；内心没有目标，无论走多远都走不出围城。我们要做的，不是期待遇到一个好人、工作、环境带给自己幸福，而是要让自己成为一个有“幸福力“的人，让自己保持幸福的状态。这样的话，无论和谁在一起，身处何地，都是幸福的。</p><p>一个人的内心是一个人真正的主人。心念所囚即为牢笼，心念所驻即为城池。能困住人的永远不会是墙，困住人的是现实的琐碎和人心的羁绊，是自己筑成的心墙。心若被困住，哪里都是围城，心若没有栖息，哪里都是流浪。<br>需要我们记住的是：自由不在墙外，自由在你心里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》机试复习</title>
      <link href="/2023/12/08/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/08/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://sprooc.github.io/2023/12/08/《计算机组织结构》机试复习/64.jpg" alt="64" style="zoom:25%;" /></p><hr><span id="more"></span><h3 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h3><p>1.将整数真值（十进制表示）转化成补码表示的二进制，默认长度32位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br><span class="line">    <span class="keyword">if</span>(num == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="string">&quot;10000000000000000000000000000000&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">        neg = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp.insert(<span class="number">0</span>, num % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> temp.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span> - len; i++) &#123;</span><br><span class="line">        temp.insert(<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span>(neg) &#123;</span><br><span class="line">        ans = addOne(negation(ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对二进制的每一位取反</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">negation</span><span class="params">(String num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> num.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i++) &#123;</span><br><span class="line">        sb.append(num.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二进制数加一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">addOne</span><span class="params">(String num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(num);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> num.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            sb.setCharAt(i, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.setCharAt(i, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.将补码表示的二进制转化成整数真值（十进制表示）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> binStr.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        num += (<span class="number">1</span> &lt;&lt; (len - i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        num -= (<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.将十进制整数的真值转化成NBCD表示（符号位用4位表示）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">NBCD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           neg = <span class="literal">true</span>;</span><br><span class="line">           num = -num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, getNBCD_4(num % <span class="number">10</span>));</span><br><span class="line">           num /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> NBCD.length();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">28</span> - len; i++) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (neg) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&quot;1101&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&quot;1100&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> NBCD.toString();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 将一位十进制数转化为NBCD码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNBCD_4</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           sb.setCharAt(loc, i % <span class="number">2</span> == <span class="number">1</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           i /= <span class="number">2</span>;</span><br><span class="line">           loc--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.将NBCD表示（符号位用4位表示）转化成十进制整数的真值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + fourNBCDTOInt(NBCDStr, <span class="number">7</span> + <span class="number">4</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.charAt(<span class="number">3</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fourNBCDTOInt</span><span class="params">(String bits, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num += (<span class="number">1</span> &lt;&lt; i) * (bits.charAt(r - i) == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.将浮点数真值转化成32位单精度浮点数表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.valueOf(floatStr);</span><br><span class="line">       <span class="keyword">if</span> (num &gt; Float.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; -Float.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; Float.MIN_VALUE &amp;&amp; num &gt; -Float.MIN_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> (floatStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>) + <span class="string">&quot;0000000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           num = -num;</span><br><span class="line">           neg = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> neg ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">bias</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; Float.MIN_NORMAL) &#123;</span><br><span class="line">           ans += <span class="string">&quot;00000000&quot;</span>;</span><br><span class="line">           System.out.println(<span class="string">&quot;n1 &quot;</span> + num);</span><br><span class="line">           num *= Math.pow(<span class="number">2</span>, <span class="number">126</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;n2 &quot;</span> + num);</span><br><span class="line">           ans += fixToString(num);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (num &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">               num /= <span class="number">2</span>;</span><br><span class="line">               exp++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">               num *= <span class="number">2</span>;</span><br><span class="line">               exp--;</span><br><span class="line">           &#125;</span><br><span class="line">           exp += bias;</span><br><span class="line">           ans += intToBinary(exp+<span class="string">&quot;&quot;</span>).substring(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">           ans += fixToString(num - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 将浮点数转化为23位的二进制数（0&lt;num&lt;1)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">fixToString</span><span class="params">(<span class="type">float</span> num)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">23</span>; i++) &#123;</span><br><span class="line">           num *= <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">               sb.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">               num -= <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>6.将32位单精度浮点数表示转化成浮点数真值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> bitsToInt(binStr.substring(<span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">frac</span> <span class="operator">=</span> bitsToInt(binStr.substring(<span class="number">9</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frac == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (neg ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;+&quot;</span>) + <span class="string">&quot;Inf&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;NaN&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf((<span class="type">float</span>) ((neg ? (-<span class="number">1</span>) : <span class="number">1</span>) * frac * Math.pow(<span class="number">2</span>, -<span class="number">149</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf((<span class="type">float</span>) ((neg ? (-<span class="number">1</span>) : <span class="number">1</span>) * (<span class="number">1</span> + frac * Math.pow(<span class="number">2</span>, -<span class="number">23</span>)) * Math.pow(<span class="number">2</span>, exp - <span class="number">127</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bitsToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        num += (str.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整数算术运算"><a href="#整数算术运算" class="headerlink" title="整数算术运算"></a>整数算术运算</h3><p>1.一位全加器（输出为长度为2 的字符串，包括1 位的进位输入和1 位的加法运算结果）</p><p><img src="a1f8e264b3b7dc7bd44becc79bbb698.png" alt="a1f8e264b3b7dc7bd44becc79bbb698" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">fullAdder</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x - <span class="string">&#x27;0&#x27;</span>) ^ (y - <span class="string">&#x27;0&#x27;</span>) ^ (c - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//三位异或</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> ((x - <span class="string">&#x27;0&#x27;</span>) &amp; (y - <span class="string">&#x27;0&#x27;</span>)) | ((y - <span class="string">&#x27;0&#x27;</span>) &amp; (c - <span class="string">&#x27;0&#x27;</span>)) | ((x - <span class="string">&#x27;0&#x27;</span>) &amp; (c - <span class="string">&#x27;0&#x27;</span>));  <span class="comment">//有两位为1则产生进位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + carry + bit;  <span class="comment">//第一个空串让后面的加法都变为字符串加法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4位先行进位加法器</p><p><img src="779f91b211dbac0dd55bcde8d454722.png" alt="779f91b211dbac0dd55bcde8d454722" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">claAdder</span><span class="params">(String operand1, String operand2, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">P</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">G</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        P = P + ((operand1.charAt(i) == <span class="string">&#x27;1&#x27;</span> || operand2.charAt(i) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        G = G + ((operand1.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; operand2.charAt(i) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        C = ((G.charAt(i) == <span class="string">&#x27;1&#x27;</span> || P.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; C.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>) + C;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C.charAt(<span class="number">0</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        result = result + fullAdder(operand1.charAt(i), operand2.charAt(i), C.charAt(i + <span class="number">1</span>)).charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现16 位的部分先行进位加法器（基于上述方法claAdder）</p><p><img src="16bc6143fed111070678490bfa0a843.png" alt="16bc6143fed111070678490bfa0a843" style="zoom:33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">pclaAdder</span><span class="params">(String operand1, String operand2, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = claAdder(operand1.substring(i * <span class="number">4</span>, i * <span class="number">4</span> + <span class="number">4</span>), operand2.substring(i * <span class="number">4</span>, i * <span class="number">4</span> + <span class="number">4</span>), c);</span><br><span class="line">        c = temp.charAt(<span class="number">0</span>);</span><br><span class="line">        result = temp.substring(<span class="number">1</span>) + result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c + result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.实现32位整数加法（基于fullAdder方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> fullAdder(operand1.charAt(i), operand2.charAt(i), c);</span><br><span class="line">        result.append(temp.charAt(<span class="number">1</span>));</span><br><span class="line">        c = temp.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.实现32位整数减法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(src.toString());</span><br><span class="line">negAndAddOne(str);</span><br><span class="line">      <span class="keyword">return</span> add(<span class="keyword">new</span> <span class="title class_">DataType</span>(str.toString()), dest);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 取反加一</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">negAndAddOne</span><span class="params">(StringBuilder str)</span>&#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (flip) &#123;</span><br><span class="line">              str.setCharAt(i, str.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              flip = str.charAt(i) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一次遍历实现取反加一：假设原二进制数最低位的1在第n位（最低位为第0位），那么该二进制数可以表示为：xx…xx10…0（后缀n个0）。取反之后为：xx…xx01…1，前面的x全部取反。再加一之后变为：xx…xx10…0可以发现，最后的10…0没有改变，只有前面的x取反了一次。所以我们只需要从后面开始遍历，在遇到第一个1之前不作改变，遇到1之后再开始取反。</p><p>6.实现32位整数布斯乘法</p><p><img src="bdd5337ccfca477eced16a1580b3bd3.png" alt="bdd5337ccfca477eced16a1580b3bd3" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">       <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> src.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">       negAndAddOne(sb);</span><br><span class="line">       <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2 + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(product.charAt(<span class="number">63</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; product.charAt(<span class="number">64</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">               highAdd(operand1, product);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(product.charAt(<span class="number">63</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; product.charAt(<span class="number">64</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">               highAdd(negOperand1, product);</span><br><span class="line">           &#125;</span><br><span class="line">           ASR(product);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(product.substring(<span class="number">32</span>,<span class="number">64</span>));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 在dest的高32位上加上src</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">highAdd</span><span class="params">(String src, StringBuilder dest)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> dest.substring(<span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">       temp = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(temp), <span class="keyword">new</span> <span class="title class_">DataType</span>(src)).toString();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           dest.setCharAt(i, temp.charAt(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 算数右移</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASR</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">       sb.insert(<span class="number">0</span>, sb.charAt(<span class="number">0</span>));</span><br><span class="line">       sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>7.恢复余数的32位整数除法</p><p><img src="37a20113d188fa2949334ee757f2a11.png" alt="37a20113d188fa2949334ee757f2a11" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">    negAndAddOne(temp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span> (operand1.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    StringBuilder product;</span><br><span class="line">    <span class="keyword">if</span> (operand2.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span> + operand2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        LeftShift(product, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            highAdd(negOperand1, product);</span><br><span class="line">            <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) != operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                highAdd(operand1, product);</span><br><span class="line">                c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            highAdd(operand1, product);</span><br><span class="line">            <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                highAdd(negOperand1, product);</span><br><span class="line">                c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        product.setCharAt(<span class="number">63</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(product.substring(<span class="number">0</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="comment">// 若除数与被除数异号，商取反加一</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">quotient</span> <span class="operator">=</span> product.substring(<span class="number">32</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span> (operand1.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(quotient);</span><br><span class="line">        negAndAddOne(temp);</span><br><span class="line">        quotient = temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理特殊情况：余数与除数相等，余数改为0，商加一；</span></span><br><span class="line">    <span class="comment">//             余数与除数相反，余数改为0，商减一。</span></span><br><span class="line">    <span class="keyword">if</span>(remainderReg.toString().equals(operand1)) &#123;</span><br><span class="line">        remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        quotient = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(quotient), <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>)).toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(remainderReg.toString().equals(negOperand1)) &#123;</span><br><span class="line">        remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        quotient = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(quotient), <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span>)).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(quotient);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">LeftShift</span><span class="params">(StringBuilder sb, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.不恢复余数的32位整数除法</p><p><img src="9a4262aaef43f3886d50bf544803d39.png" alt="9a4262aaef43f3886d50bf544803d39" style="zoom:30%;" /></p><p><img src="fcb272820a3b29419ddc6112b7b0a80.png" alt="fcb272820a3b29419ddc6112b7b0a80" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">    negAndAddOne(temp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span> (operand1.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    StringBuilder product;</span><br><span class="line">    <span class="keyword">if</span> (operand2.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span> + operand2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        highAdd(negOperand1, product);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        highAdd(operand1, product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            LeftShift(product, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            highAdd(negOperand1, product);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LeftShift(product, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            highAdd(operand1, product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">quotientSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(product.substring(<span class="number">32</span>, <span class="number">64</span>));</span><br><span class="line">    <span class="comment">// 商修正：商左移一位，若余数寄存器与除数同号，低位补1；若异号，低位补0.</span></span><br><span class="line">    <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        LeftShift(quotientSB, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LeftShift(quotientSB, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若被除数与除数异号，商加一</span></span><br><span class="line">    <span class="keyword">if</span>(operand1.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        highAdd(<span class="string">&quot;00000000000000000000000000000001&quot;</span>, quotientSB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 余数修正：若余数与被除数同号，不修正；</span></span><br><span class="line">    <span class="comment">//          若余数与被除数异号：若被除数与除数同号，余数减去除数；</span></span><br><span class="line">    <span class="comment">//                           若被除数与除数异号，余数加上除数。</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">remainderSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(product.substring(<span class="number">0</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">if</span> (remainderSB.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operand1.charAt(<span class="number">0</span>) == operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            highAdd(negOperand1, remainderSB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            highAdd(operand1, remainderSB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若余数与除数相等，余数改为0，商加一；</span></span><br><span class="line">    <span class="comment">//若余数与除数相反，余数改为0，商减一。</span></span><br><span class="line">    <span class="keyword">if</span> (remainderSB.toString().equals(operand1)) &#123;</span><br><span class="line">        remainderSB = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        highAdd(<span class="string">&quot;00000000000000000000000000000001&quot;</span>, quotientSB);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainderSB.toString().equals(negOperand1)) &#123;</span><br><span class="line">        remainderSB = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        highAdd(<span class="string">&quot;11111111111111111111111111111111&quot;</span>, quotientSB);</span><br><span class="line">    &#125;</span><br><span class="line">    remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(remainderSB.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(quotientSB.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数算数运算"><a href="#浮点数算数运算" class="headerlink" title="浮点数算数运算"></a>浮点数算数运算</h3><p>1.计算两个浮点数的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(addCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="keyword">if</span>(isZero(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(isFinite(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> Math.max(xexp, yexp);</span><br><span class="line">    <span class="keyword">if</span> (yexp &lt; exp) &#123;</span><br><span class="line">        yfrac = rightShift(yfrac, exp - yexp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xexp &lt; exp) &#123;</span><br><span class="line">        xfrac = rightShift(xfrac, exp - xexp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    String frac;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) &#123;</span><br><span class="line">        frac = ALU.add(<span class="string">&quot;0&quot;</span> + xfrac, <span class="string">&quot;0&quot;</span> + yfrac).toString();</span><br><span class="line">        s = xs;</span><br><span class="line">        exp++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xs == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ys == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = ALU.sub(<span class="string">&quot;0&quot;</span> + yfrac, <span class="string">&quot;0&quot;</span> + xfrac).toString();</span><br><span class="line">        s = frac.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            frac = ALU.negation(frac);</span><br><span class="line">        &#125;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        frac = ALU.sub(<span class="string">&quot;0&quot;</span> + xfrac, <span class="string">&quot;0&quot;</span> + yfrac).toString();</span><br><span class="line">        s = frac.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            frac = ALU.negation(frac);</span><br><span class="line">        &#125;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(round(s, Transformer.intToBinary(exp + <span class="string">&quot;&quot;</span>).substring(<span class="number">32</span> - <span class="number">8</span>), frac.substring(<span class="number">0</span>, <span class="number">27</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.计算两个浮点数的差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>((s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>) + s.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> add(src, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.计算两个浮点数的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(mulCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) s = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isZero(x) || isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(x) || isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> xexp + yexp - <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">frac</span> <span class="operator">=</span> ALU.mul(xfrac, yfrac).toString();</span><br><span class="line">    <span class="keyword">if</span> (frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        exp++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">        exp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.计算两个浮点数的商。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(divCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) s = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isZero(x)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    <span class="keyword">if</span> (isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> yexp - xexp + <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">frac</span> <span class="operator">=</span> ALU.div(xfrac, yfrac).toString();</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(round(s, Transformer.intToBinary(exp + <span class="string">&quot;&quot;</span>).substring(<span class="number">32</span> - <span class="number">8</span>), frac));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h3><p>1.计算使用先来先服务算法（FCFS）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> loc : request) &#123;</span><br><span class="line">        result += Math.abs(start - loc);</span><br><span class="line">        start = loc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.计算最短寻到时间优先算法（SSTF）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> request.length;</span><br><span class="line">    LinkedList&lt;Integer&gt; requests = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : request) &#123;</span><br><span class="line">        requests.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!requests.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> findMinDistance(start, requests);</span><br><span class="line">        result += Math.abs(start - requests.get(loc));</span><br><span class="line">        start = requests.get(loc);</span><br><span class="line">        requests.remove(loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMinDistance</span><span class="params">(<span class="type">int</span> start, LinkedList&lt;Integer&gt; request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minD</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.size(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newD</span> <span class="operator">=</span> Math.abs(start - request.get(i));</span><br><span class="line">        <span class="keyword">if</span> (newD &lt; minD) &#123;</span><br><span class="line">            minD = newD;</span><br><span class="line">            loc = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.计算扫描算法（SCAN）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="number">0</span>) direction = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == Disk.TRACK_NUM) direction = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">            result = maxTrace - start;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            result = Disk.TRACK_NUM - <span class="number">1</span> - start + Disk.TRACK_NUM - <span class="number">1</span> - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= maxTrace) &#123;</span><br><span class="line">            result = start - minTrace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = start + maxTrace;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.计算C-SCAN算法访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">        result = maxTrace - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; maxTrace) &#123;</span><br><span class="line">        result = Disk.TRACK_NUM - <span class="number">1</span> - start + maxTrace + Disk.TRACK_NUM - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request[i] &lt; start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request[i] &gt; lb) &#123;</span><br><span class="line">                    lb = request[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Disk.TRACK_NUM - <span class="number">1</span> - start + lb + Disk.TRACK_NUM - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.计算LOOK算法访问磁道的平均寻道长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) direction = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= maxTrace) direction = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">        result = maxTrace - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= maxTrace) &#123;</span><br><span class="line">        result = start - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">        result = maxTrace - start + maxTrace - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = start - minTrace + maxTrace - minTrace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.计算C-LOOK算法访问磁道的平均寻道长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= minTrace) &#123;</span><br><span class="line">            result = maxTrace - start;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; maxTrace) &#123;</span><br><span class="line">            result = start - minTrace + maxTrace - minTrace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request[i] &lt; start) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request[i] &gt; lb) &#123;</span><br><span class="line">                        lb = request[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = maxTrace - start + maxTrace - minTrace + lb - minTrace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / request.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些数学</title>
      <link href="/2023/12/05/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6/"/>
      <url>/2023/12/05/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (LL)ans * a % m;</span><br><span class="line">    a = (LL)a * a % m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>龟速乘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">  a %= p;</span><br><span class="line">  b %= p;</span><br><span class="line">  LL c = (<span class="type">double</span>)a * b / p;</span><br><span class="line">  LL x = a * b;</span><br><span class="line">  LL y = c * p;</span><br><span class="line">  LL ans = (LL)(x % p) - (LL)(y % p);</span><br><span class="line">  <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += p;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等比数列（公比为p，项数为e，以1为首项）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> e, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)(<span class="number">1</span> + <span class="built_in">pow</span>(p, e / <span class="number">2</span>, m)) * <span class="built_in">sum</span>(p, e / <span class="number">2</span>, m) % m;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">pow</span>(p, e / <span class="number">2</span>, m)) * <span class="built_in">sum</span>(p, e / <span class="number">2</span>, m) % m +</span><br><span class="line">            <span class="built_in">pow</span>(p, e - <span class="number">1</span>, m)) % m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分解质因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  p[s] = i; c[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">    a /= i; c[s]++;</span><br><span class="line">  &#125;</span><br><span class="line">  s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  p[s] = a; c[s++]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：</p><p><a href="https://www.acwing.com/problem/content/description/99/">97. 约数之和 - AcWing题库</a><br><a href="http://poj.org/problem?id=1995">1995 — Raising Modulo Numbers (poj.org)</a></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/591377294">ACM——常见的几种分解质因子的方法 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231203周记</title>
      <link href="/2023/12/03/20231203%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/03/20231203%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本周主要学习内容：树状数组、线段树、ST表、石子合并问题。</p><span id="more"></span><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>前半周主要学了树状数组，可以很熟练地把模版敲出来了。相关题目可以看<a href="[315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">leetcode315</a>)，以及当时写的小结：<a href="https://sprooc.github.io/2023/11/28/leetcode-315-计算右侧小于当前元素的个数/">[leetcode]315. 计算右侧小于当前元素的个数 | Sprooc</a>。</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>接下来系统梳理了线段树，掌握了懒惰标记和动态开点的方法，参考文章：<br><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713">线段树 从入门到进阶（超清晰，简单易懂）_线段树怎么写-CSDN博客</a><br><a href="https://leetcode.cn/problems/falling-squares/solutions/1518392/by-ac_oier-zpf0/">699. 掉落的方块 - 力扣（LeetCode）</a></p><h4 id="Sparse-Table"><a href="#Sparse-Table" class="headerlink" title="Sparse Table"></a>Sparse Table</h4><p>模版题目：<a href="https://www.luogu.com.cn/problem/solution/P3865">P3865 【模板】ST 表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="CSP真题"><a href="#CSP真题" class="headerlink" title="CSP真题"></a>CSP真题</h4><p>周六限时做了202203的CSP真题。前三题满分还是挺轻松的。第四题写了一个小时，暴力求“通信对”超时拿了50分。后来想改成实时维护“通信对”数量，但总该不对，大概有些细节问题，没有细究了。第五题一脸懵，直接放弃了。三个小时拿了350分。</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="fc1b9f4f1e7383b08328814347efeed.png" alt="fc1b9f4f1e7383b08328814347efeed"></h4><h4 id="石子合并问题"><a href="#石子合并问题" class="headerlink" title="石子合并问题"></a>石子合并问题</h4><p>做csp202203-5时了解到石子合并问题，找了些资料学了一学。参考资料：</p><p><a href="https://www.cnblogs.com/jiu0821/p/4493497.html">石子合并问题（直线版） - jiu~ - 博客园 (cnblogs.com)</a><br><a href="https://zhuanlan.zhihu.com/p/398419302">算法学习笔记(79): 四边形不等式优化DP - 知乎 (zhihu.com)</a></p><h4 id="力扣第374次周赛"><a href="#力扣第374次周赛" class="headerlink" title="力扣第374次周赛"></a>力扣第374次周赛</h4><p>两题遗憾收场，总排名意外的不算太低，感觉这次周赛确实上难度了。</p><p><img src="1635377acebfff7866915f1586771c1.png" alt="1635377acebfff7866915f1586771c1"></p><p><img src="0b495cd39acc31a7289b0558514d06a.png" alt="0b495cd39acc31a7289b0558514d06a"></p><p>第一题送分题。第二题需要自己模拟一下，思路比较难找，但终究还是写出来了。第三题思路本来是对的，先找到满足条件2的子串，再对每个子串求满足条件1的子串数量。求满足条件1的子串用滑动窗口，窗口大小为k的整数倍。当时我按照这种思路写结果超时了，以为有更优的解法。看了别人的代码才发现，不应该将字符串总长度作为窗口大小的上界，窗口最大只能是26k，因为只有26个字母，如果一个字符串满足条件，它的长度最大也只能是每个字母都出现k次，总长度就是26k。只改了一行代码结果结果了。又是细节上出了问题，看来还是经验不足。第四题实则是一道数学题。比赛时来不及做，之后看题解发现思路还是不困难的。但是发现一些原来不知道的数论知识，顺便补了一课：<a href="https://blog.csdn.net/LeBron_Yang/article/details/82948732">逆元（关于除法取模）_除法逆元-CSDN博客</a></p><p>总体来看，这周的收获还是挺大的（也更加感到自己与佬的差距）。目前的问题主要是经验不足和知识体系有很多缺漏。接下来还是要多刷题多总结。当然也要多啃书。另外刚买了一本李煜东的算法竞赛进阶指南，用来给自己补一补洞吧。</p><p>这周大概就是这样了。不知不觉就到了今年的最后一个月了，发现很快2023年就要结束了。感觉时间总是在不知不觉中溜走了，有一种被时间推着走的感觉。还没有做好迎接新一年的准备，就恍恍惚惚地被逼着迈入下一年。无论如何，没准备好也好，也只能硬着头皮走下去了。那么，为了让今年少一点遗憾，最后一个月，加油干吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>石子合并问题</title>
      <link href="/2023/12/03/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/03/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>石子合并问题：有N堆石子，现要将石子有序的合并成一堆，规定如下：每次只能移动相邻的2堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费最小（或最大）。</p><p>这是一道典型的动态规划题目。令<code>dp[i][j]</code>为将第i到j堆石子合并成一堆的最小代价<code>w[i][j]</code>为第i到j堆石子的总数。就可以写出状态转移方程：</p><script type="math/tex; mode=display">dp[i][j] = min_{k=i}^{j-1}(dp[i][k] + dp[k+1][j]) + w[i][j]</script><p>直接暴力求解就可以，复杂度O(n<sup>3</sup>)。</p><p>改进方法是用平行四边形不等式优化，缩小k的范围，复杂度O(n<sup>2</sup>) :<a href="https://zhuanlan.zhihu.com/p/398419302">算法学习笔记(79): 四边形不等式优化DP - 知乎 (zhihu.com)</a></p><p>问题的变种是让石子环形排列，即第一堆和最后一堆看成是相邻的。解决方法是在n堆石子后面再加上与前面一样的n堆石子，这样最后一堆和第一堆就相邻了。把总堆数看成2n，用上面的方法解出来就可以了。最后还需要遍历一下dp数组，求出2n堆石子里面结果最小的n堆石子作为最终结果。</p><p><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">stones</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; s(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp1(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sum</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; stones[i];</span><br><span class="line">    stones[n + i] = stones[i];</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + stones[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + stones[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span> * n; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> j = i + r;</span><br><span class="line">      <span class="keyword">if</span> (j &gt; <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>, dp1[i][i] = <span class="number">0</span>, s[i][i] = i;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] = INF;</span><br><span class="line">      dp1[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = s[i][j - <span class="number">1</span>]; k &lt;= min(j - <span class="number">1</span>, s[i + <span class="number">1</span>][j]); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k + <span class="number">1</span>][j]) &#123;</span><br><span class="line">          dp[i][j] = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">          s[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">        dp1[i][j] = max(dp1[i][j], dp1[i][k] + dp1[k + <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] += (sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">      dp1[i][j] += (sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> re1 = INF;</span><br><span class="line">  <span class="type">int</span> re2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    re1 = min(re1, dp[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    re2 = max(re2, dp1[i][i + n - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, re1, re2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sparse Table(稀疏表)</title>
      <link href="/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/"/>
      <url>/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<p>Sparse Table简称ST，用于对一组静态数据进行区间查询。</p><span id="more"></span><p>例如：</p><ul><li>RMQ：区间最大（最小）值</li><li>RGQ：区间最大公因数</li></ul><p>这两个问题都可以用线段树解决。但线段树的查询时间是O(logn)，ST可以在O(1)时间内完成查询。代价是是ST不能对数组进行动态维护，数组在查询之前就固定下来。因此，如果需要动态维护数组，用线段树；反之，用ST。</p><p>什么样的问题可以用ST解决？例如说，求区间最小值，我们可以先把一个区间分成两个小区间，两个小区间的的最小值就是大区间的最小值。最大公因数也同理，求一个大区间的最大公因数，先求两个小区间的最大公因数，再求这两个数的最大公因数就是大区间的最大公因数。类似这类问题都能用ST解决。形式化的，ST能解决的问题为：</p><ul><li><p>求数组的某一区间S的某一性质F(S)，性质F满足：</p><script type="math/tex; mode=display">若{s_1}\cup {s_2}=S，则F(S)=F(F(s_1),F(s_2)).</script><p>可以验证，min和gcd都满足以上要求。</p><p>详细内容参照<a href="[ST稀疏表(Sparse Table">这篇文章</a>算法笔记-CSDN博客](<a href="https://blog.csdn.net/narcissus2_/article/details/89423591))。">https://blog.csdn.net/narcissus2_/article/details/89423591))。</a></p></li></ul><p>下面是代码（read函数是快速读入一个整数的函数，只是用来过洛谷的oj）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">21</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="built_in">log2</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="built_in">gcd</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(dp[k][l], dp[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  n = <span class="built_in">read</span>();</span><br><span class="line">  m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    l = <span class="built_in">read</span>();</span><br><span class="line">    r = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(l - <span class="number">1</span>, r - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[leetcode]315. 计算右侧小于当前元素的个数</title>
      <link href="/2023/11/28/leetcode-315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2023/11/28/leetcode-315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>力扣315，没有花里胡哨的题面，属于树状数组的模版题了。正好复习一下BIT。先看题目：</p><h1 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="[计算右侧小于当前元素的个数]"></a>[计算右侧小于当前元素的个数]</h1><div class="table-container"><table><thead><tr><th style="text-align:center">Category</th><th style="text-align:center">Difficulty</th><th style="text-align:center">Likes</th><th style="text-align:center">Dislikes</th></tr></thead><tbody><tr><td style="text-align:center">algorithms</td><td style="text-align:center">Hard (43.45%)</td><td style="text-align:center">1032</td><td style="text-align:center">-</td></tr></tbody></table></div><p>给你一个整数数组 <code>nums</code> ，按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0] </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有 1 个更小的元素 (1)</span><br><span class="line">1 的右侧有 0 个更小的元素</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,-1]</span><br><span class="line">输出：[0,0]</span><br></pre></td></tr></table></figure><p>看完题目，很自然想到用树状数组来做。关于树状数组，可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组 - 知乎 (zhihu.com)</a></p><p>思路大概是：</p><ul><li>通过排序获得<code>num</code>中每个数在数组中的由小到大排位，该排位值就是该数在树状数组里的下标。</li><li>由于查询每个点时，我们只需要知道右侧元素中小于该数的元素数量。因此从右往左遍历数组，遍历到某一点时，可以保证右侧元素对应的树状数组位置已被更新过。先用<code>query</code>查询，再将用该数更新数组。</li><li>遍历完成，返回答案。</li></ul><p>下面是代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; loc &lt;= n; loc += <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">      tree[loc]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; loc &gt; <span class="number">0</span>; loc -= <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">      ans += tree[loc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    tree = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; sortNums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">locOfNum</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      sortNums.<span class="built_in">emplace_back</span>(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sortNums.<span class="built_in">begin</span>(), sortNums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      locOfNum[sortNums[i].second] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      result[i] = <span class="built_in">query</span>(locOfNum[i]);</span><br><span class="line">      <span class="built_in">update</span>(locOfNum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了用树状数组，还有没有其它O(nlogn)的算法呢？答案是有的。用归并排序求逆序对的数量也能解决本题。</p><p>首先定义<strong>逆序对</strong>。对于数组<code>nums</code>的下标<code>i</code>, <code>j</code>，若<code>i&lt;j</code>且<code>nums[i]&gt;nums[j]</code>，则称<code>(nums[i], nums[j])</code>是一对逆序对。题目中所要求的<code>count[i]</code>，就是以<code>nums[i]</code>为左边元素的逆序对的个数。这样问题就被转化为了求逆序对。</p><p>考虑由两个数组<code>L</code>, <code>R</code>，分别从两数组中取一个元素<code>a</code>和<code>b</code>，求使<code>(a, b)</code>为逆序对的取法由多少种。如果暴力枚举，复杂度为O(n<sup>2</sup>)，不符合我们的期望。然而，如果<code>L</code>和<code>R</code>是两个从小到大排列好的数组，问题将会很好解决。首先定义两个指针<code>p1</code>和<code>p2</code>，初始时分别指向<code>L</code>和<code>R</code>的第一个元素，然后执行以下算法：</p><p>1、右移<code>p2</code>直到<code>R[p2]&gt;=L[p1]</code>。由于<code>R[p2]</code>是数组<code>R</code>中第一个大于等于<code>L[p1]</code>的元素，即数组<code>R</code>中<code>p2</code>之前的元素均小于<code>L[p1]</code>，均能与<code>L[p1]</code>组成逆序对。故数组<code>R</code>开头到<code>p2</code>的元素个数就是能与<code>L[p1]</code>组成逆序对的元素个数。<br>2、右移<code>p1</code>，回到第一步求L中下一个元素能组成的逆序对个数。</p><p>该算法p1和p2均只经历一次遍历，时间复杂度为O(n)，符合我们的要求。然而这个算法只能求分别从两个数组各取一个元素所能组成的逆序对，不能求在同一个数组中元素形成的逆序对。为使用上述算法，我们希望找到一个办法，<strong>让数组中的任意两个元素都有且仅有一次地被置于两个数组之中，并按上述算法求判断它们能否组成逆序对</strong>。这样我们不会遗漏任一逆序对，也不会重复计算。归并排序恰好能实现我们的期望。归并排序每次都会将数组分成两个小数组，通过递归调用分别将这两个小数组排好序，再合并这两个数组。如果我们在两个小数组排序好之后，对这两个数组执行计算逆序对的算法，之后再合并，能否满足要求呢？下面我们证明确实可以。</p><ul><li>首先，证明<strong>任意两个元素都至少有一次被置于两个不同的数组中，且对这两个数组执行求逆序对算法</strong>。归并排序递归的终止状态是待排序的数组中只有一个元素。也就是说，数组中的每一个元素，最初都处于只含有自己一个元素的数组中。而在排序的最后，所有元素都处在同一个数组中。也就是说，数组中的任意两个元素，最初都在不同的数组中，然而有一个合并的过程，将它们所在的两个数组合并为一个数组。只要在该次合并之前执行求逆序对算法，就能保证任意两个元素都有一次被置于两个不同的数组中求逆序对。</li><li>接着，证明<strong>任意两个元素被分别置于两个数组求逆序对的经历只有一次</strong>。我们已经证明的该过程必有一次。而经历了这一次之后，两个元素被合并到同一个数组之中，以后不可能再被置于不同数组中了。因此可以保证只有一次。</li><li>容易知道，原数组中的任意两个元素<code>a</code>和<code>b</code>，若<code>a</code>位于<code>b</code>的左侧，则在归并排序过程中，<code>a</code>所在的数组和<code>b</code>所在的数组在执行求逆序对过程中，<code>a</code>所在数组一定在<code>b</code>所在数组左侧。</li></ul><p>证明完成。另外还有一点，排序之后元素顺序被打乱了，但我们需要知道每个元素在原数组中的下标，以将其所能组成的逆序对数量记录在数组counts的相应位置。我们可以将原数组中的元素换成二元组<code>(元素值，下标)</code>。如此我们在排序过程中就能知道元素在原数组中的下标了。至此，思路已经很清晰了，下面看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;pii&gt; tem;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;pii&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, begin, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="type">int</span> l = begin;</span><br><span class="line">    <span class="type">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">      <span class="keyword">while</span> (r &lt;= end &amp;&amp; nums[r] &lt; nums[l]) r++;</span><br><span class="line">      result[nums[l].second] += (r - mid - <span class="number">1</span>);</span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = begin;</span><br><span class="line">    l = begin;</span><br><span class="line">    r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[l] &lt; nums[r]) &#123;</span><br><span class="line">        tem[k++] = nums[l++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tem[k++] = nums[r++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">      tem[k++] = nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; r; i++) &#123;</span><br><span class="line">      nums[i] = tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    result = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    tem = <span class="built_in">vector</span>&lt;pii&gt;(n);</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">indexNums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      indexNums[i] = &#123;nums[i], i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MergeSort</span>(indexNums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231128小记</title>
      <link href="/2023/11/28/20231128%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/11/28/20231128%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>近日思绪繁多，终得明朗，记于此。</p><span id="more"></span><p>近日常思考今后的学习方向，是研究技术搞开发，还是研究算法搞理论。不是算法学不起，学习技术更有性价比。学习算法成本高风险大。但若学有所成，不论是对学业还是未来工作都大有所益。故算法这条道虽难走，但亦值得一试。犹豫之时，忽忆起前日前辈经验分享会上一席话：“你们才大二，有的是试错的机会。如果犹豫走哪个方向，不如都试一试。“既然如此，即可放手一搏，研究算法之道。既定下决心，记于此处，以自勉。</p><p>今日起，日刷力扣五题，并力肝算法导论一书。每周末小记本周学习心得与收获，总结反思，亦可记录成长的足迹。</p><p>“行路难！行路难！多歧路，今安在？”。惟愿“长风破浪会有时，直挂云帆济沧海”！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS-PA3 实验记录</title>
      <link href="/2023/11/15/ICS-PA3%20docs/"/>
      <url>/2023/11/15/ICS-PA3%20docs/</url>
      
        <content type="html"><![CDATA[<p>记录一下pa的完成过程。前面的pa1和pa2没有记录，等以后有机会二刷再补上吧。</p><span id="more"></span><h2 id="PA3-1"><a href="#PA3-1" class="headerlink" title="PA3-1"></a>PA3-1</h2><p>PA3的第一阶段是实现异常响应机制。为实现异常响应，需要添加几个特殊寄存器，称为控制和状态寄存器（CSR）。PA中需要用到的包括：</p><div class="table-container"><table><thead><tr><th style="text-align:center">CSR</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">mepc</td><td style="text-align:center">存放触发异常的PC</td></tr><tr><td style="text-align:center">mcause</td><td style="text-align:center">存放触发异常的原因</td></tr><tr><td style="text-align:center">mstatus</td><td style="text-align:center">存放处理器的状态</td></tr><tr><td style="text-align:center">mtvec</td><td style="text-align:center">存放异常入口地址</td></tr></tbody></table></div><p>触发异常前，需要调用cte_init()函数进行初始化，将异常入口地址存到mtvec寄存器中，并注册一个事件处理回调函数，当触发异常时，将会以上下文信息和信息为参数调用此回调函数，执行异常处理操作。</p><p>RISCV32通过ecall指令触发自陷。具体来说，ecall指令执行的操作为：</p><ul><li>CSR[mepc] &lt;- pc</li><li>CSR[mcause] &lt;- 异常号</li><li>PC &lt;- CSR[mtvec] （执行异常响应程序）</li></ul><p>完成异常响应程序后，恢复上下文信息，通过mret指令将PC从mepc中恢复（并+4），从中断处继续执行。</p><p>大致理解机制之后，再RTFM和RTFSC之后就可以敲代码了。</p><p>首先是在代码中添加寄存器，直接加一个数组就好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">word_t</span> gpr[MUXDEF(CONFIG_RVE, <span class="number">16</span>, <span class="number">32</span>)];</span><br><span class="line">  <span class="type">vaddr_t</span> pc;</span><br><span class="line">  <span class="type">word_t</span> csr[<span class="number">4</span>];</span><br><span class="line">&#125; MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);</span><br></pre></td></tr></table></figure><p>接下来实现csrr和cswr指令，实现CSR的读写。这两条指令是通过I类指令的立即数来指代某一个CSR的，通过RTFM可以找到找到寄存器对应的代码。</p><p><img src="f70598671b2221a0543914666a6f06b.png" alt="f70598671b2221a0543914666a6f06b"></p><p>方便起见，写一个函数将代码做个映射：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">checkCSR</span><span class="params">(<span class="type">int</span> gr)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (gr)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x342</span>: <span class="comment">//mcause</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x300</span>: <span class="comment">//mstatus</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x341</span>: <span class="comment">//mepc</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x305</span>: <span class="comment">//mtvec</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    panic(<span class="string">&quot;Unknow csr %x&quot;</span>, gr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再定义一个宏来访问对应的寄存器，这样就能很方便的查找CSR了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CSRs(gr) (cpu.csr[checkCSR(gr)])</span></span><br></pre></td></tr></table></figure></p><p>实现指令就是直接抄手册了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 001 ????? 11100 11&quot;</span>, csrrw  , I, <span class="type">word_t</span> t = CSRs(imm); CSRs(imm) = src1; R(rd) = t); </span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 11100 11&quot;</span>, csrrs  , I, <span class="type">word_t</span> t = CSRs(imm); CSRs(imm) = (t | src1); R(rd) = t);</span><br></pre></td></tr></table></figure></p><p>接下来实现ecall指令。ecall的操作在isa_raise_intr()函数里实现，按要求写就行，没啥别的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_raise_intr</span><span class="params">(<span class="type">word_t</span> NO, <span class="type">vaddr_t</span> epc)</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cpu.csr[<span class="number">2</span>] = epc;</span><br><span class="line">  cpu.csr[<span class="number">0</span>] = NO;</span><br><span class="line">  <span class="keyword">return</span> cpu.csr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的实现很简单，主要问题是参数NO从哪来？查手册发现riscv自陷Exception Code是11, 所以ecall指令的操作就是以11和PC值为参数调用isa_raise_intr()，再将函数返回值赋值给s-&gt;dnpc就可以了。</p><p>最后mret指令就更容易了，置PC就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;0000000 00000 00000 000 00000 11100 11&quot;</span>, ecall  , I, s-&gt;dnpc = isa_raise_intr(<span class="number">11</span>, s-&gt;pc));</span><br><span class="line">INSTPAT(<span class="string">&quot;0011000 00010 00000 000 00000 11100 11&quot;</span>, mret   , R, s-&gt;dnpc = CSRs(<span class="number">0x341</span>) + <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><p>再此尝试运行yield test，得到错误输出“Unhandled event”。发现是在注册的回调函数simple_trap()中，事件编号错误。想了很久才发现原因：</p><p>执行ecall之后会跳转到__am_asm_trap函数，这个函数是用汇编写的，定义在trap.S中。此函数会保存上下文信息，然后跳转到__am_irq_handle()函数，这个函数参数为刚才保存的上下文信息Context，包含通用寄存器和CSR的值。它将根据mcause的值设置事件编号，并调用回调函数。默认时事件编号都会被设置为EVENT_ERROR，肯定会发生错误，所以添加一条case，mcause为11时事件编号设为EVENT_YIELD，这样一来理论上应该就没问题了。</p><p>然而还是出错了。。。</p><p>再是一番冥思苦想，发现am_asm_trap里一串代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)</span><br><span class="line">#define OFFSET_STATUS ((NR_REGS + 1) * XLEN)</span><br><span class="line">#define OFFSET_EPC    ((NR_REGS + 2) * XLEN)</span><br></pre></td></tr></table></figure></p><p>这几个宏定义的是设置参数Context时三个寄存器在栈中的位移，按顺序应该是mcause, mstatus, mepc，并且都是更在32个通用寄存器后面。但Context结构体却是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> fix the order of these members to match trap.S</span></span><br><span class="line">  <span class="type">uintptr_t</span>  mcause, mstatus, gpr[NR_REGS], mepc;</span><br><span class="line">  <span class="type">void</span> *pdir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>明显顺序有误，应该调整一下顺序。改完之后yield test就通了。</p><p>写到这里我真的心情复杂，这么难发现的坑怎么不再文档里面说？？气愤之时继续往下做，突然发现后面文档里面有写要调整结构体顺序。。。原来是我没看完文档，只看了第一部分就开始做，结果绕了大弯。而且糊里糊涂地把后面的内容都做完了。。。不过虽然走了弯路耗时长了一点，但相应的理解也更深刻了。算是吸取个教训，以后要看完文档再动手。</p><p>最后的etrace轻松完成，至此第一阶段完成，耗时4小时。（大部分时间在走弯路。。。）</p><h5 id="必答题-理解上下文结构体的前世今生"><a href="#必答题-理解上下文结构体的前世今生" class="headerlink" title="必答题- 理解上下文结构体的前世今生"></a>必答题- 理解上下文结构体的前世今生</h5><blockquote><p>你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>, <code>c</code>指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? <code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</p></blockquote><p>上下文结构体在__am_asm_trap()函数的调用栈中。阅读trap.S的代码可以知道，32个通用寄存器、三个CSR依次被压入栈中，依次完成Context结构体的赋值。之后作为参数传入__am_irq_handle()函数。</p><h5 id="必答题-理解穿越时空的旅程"><a href="#必答题-理解穿越时空的旅程" class="headerlink" title="必答题 - 理解穿越时空的旅程"></a>必答题 - 理解穿越时空的旅程</h5><blockquote><p>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</p></blockquote><p>yield test中，首先调用cte_init()进行初始化，具体操作为：<br>1、将__am_asm_trap()函数的地址存在mtvec寄存器中。<br> 2、注册回调函数simple_trap。<br> 然后进入hello_intr()函数，输出一些信息。然后进入循环调用yield()函数。yield()函数使用内联汇编”li a7 -1”指令将异常号存在a7中，然后执行指令ecall。ecall指令依次完成一下操作：<br> 1、CSR[mepc] &lt;- pc<br> 2、CSR[mcause] &lt;- a7<br> 3、PC &lt;- CSR[mtvec]<br> 这时PC将会指向__am_asm_trap函数并执行。此函数首先会将32个通用寄存器、3个CSR的值压入栈中，构成Context结构体c，将该结构体作为参数调用__am_irq_handle()函数。此函数会定义一个Event结构体，根据c中储存有的mcause值，设置Event结构体的事件编号，再以Context和Event两个结构体为参数调用之前注册的回调函数simple_trap()。此函数会根据Event结构体中的事件编号识别事件，做出相应的输出。由于循环很大，程序会不断输出y，之后退出异常响应是否正确实现不得而知。</p><h2 id="PA3-2"><a href="#PA3-2" class="headerlink" title="PA3-2"></a>PA3-2</h2><p>PA3第二阶段主要是引入操作系统nanos-lite，实现操作系统加载用户程序和系统调用。目前nanos-lite的功能很简陋，大概看一下main.c就大致明白它的工作流程了：初始化设备和存储器，加载程序，最后触发yield自陷。</p><p>我们的第一个任务时使操作系统能加载程序，即实现loader()。这里的程序指的是ELF文件，它存放在硬盘(ramdisk.img)。我们需要解析ELF文件，并将其加载到运行时内存。解析ELF可以按照以下流程：</p><ul><li><p>读取ELF头，根据魔数e_ident检查是否为ELF文件。</p></li><li><p>从ELF头获取程序头program header的位移e_phoff和程序头的数量e_phnum。</p></li><li>逐个读取程序头，判断其类型是否为PT_LOAD。</li><li>若是，将该节加载到内存。加载的地址、长度都包含在程序头里面了。</li><li>完成加载，loader()函数返回程序入口e_entry。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> phdr_size = <span class="keyword">sizeof</span>(Elf_Phdr);</span><br><span class="line">  Elf_Ehdr *ehdr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  Elf_Phdr *phdr = <span class="built_in">malloc</span>(phdr_size);</span><br><span class="line">  ramdisk_read((<span class="type">void</span>*)ehdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  assert(*(<span class="type">uint32_t</span> *)ehdr-&gt;e_ident == <span class="number">0x464c457f</span>);</span><br><span class="line">  assert(EXPECT_TYPE == ehdr-&gt;e_machine);</span><br><span class="line">  <span class="type">uint32_t</span> phdr_num = ehdr-&gt;e_phnum;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; phdr_num; i++) &#123;</span><br><span class="line">    ramdisk_read((<span class="type">void</span>*)phdr, ehdr-&gt;e_phoff + i * phdr_size, phdr_size);</span><br><span class="line">    <span class="keyword">if</span>(phdr-&gt;p_type != PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">    ramdisk_read((<span class="type">void</span>*)phdr-&gt;p_vaddr, phdr-&gt;p_offset, phdr-&gt;p_filesz);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)phdr-&gt;p_vaddr + phdr-&gt;p_filesz, <span class="number">0</span>, phdr-&gt;p_memsz - phdr-&gt;p_filesz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ehdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在init_proc()里调用naive_uload()，naive_uload()会加载硬盘中的程序，并获取入口地址，跳转到入口地址执行。这样操作系统就能够加载用户程序并执行了。</p><p>接下来编译并在nanos运行dummy。第一次编译dummy可能需要重启ternimal，应该刚配置的NAVY_HOME环境变量还没生效，Makefile还无法识别。</p><p>dummy程序会触发系统调用。触发系统调用和上一阶段实现的自陷都是用ecall指令实现的，如何区分它们？阅读源码可知，系统调用前会往GPR1(a7)里面填入type，yield()在ecall之前也会往a7里填入-1。因此，我们可以根据a7里的值区分EVENT_YIELD和EVENT_SYSCALL。而寄存器内容都保存在上下文信息c里面了，我们很容易读取。因此，修改cte.c内代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>: </span><br><span class="line">        <span class="keyword">if</span>(c-&gt;GPR1 == <span class="number">-1</span>) ev.event = EVENT_YIELD;</span><br><span class="line">        <span class="keyword">else</span> ev.event = EVENT_SYSCALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定事件类型之后会调用注册的回调函数。在nanos中为do_event()。这里做点简单判断就行了，如果是EVENT_SYSCALL就交给do_syscall()处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: <span class="built_in">printf</span>(<span class="string">&quot;Event: yield!\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVENT_SYSCALL: do_syscall(c); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled eventdd ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用也有不同的类型。在do_syscall里，我们只需要根据GPR1识别系统调用类型，然后把任务分配给给个sys_xxx()函数实现系统调用即可。实现sys_yield和sys_exit，dummy就可以通了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_yield</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  yield();</span><br><span class="line">  c-&gt;GPRx = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  halt(c-&gt;GPR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现标准输出sys_write，这里按照手册写就可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_write</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = (<span class="type">int</span>)c-&gt;GPR2;</span><br><span class="line">  <span class="type">void</span> *buf = (<span class="type">void</span> *)c-&gt;GPR3;</span><br><span class="line">  <span class="type">size_t</span> count = (<span class="type">size_t</span>)c-&gt;GPR4;</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">1</span> || fd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  c-&gt;GPRx = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们还需要给用户程序提供标准输入的接口_write()，把系统调用抽象成一个屏蔽底层细节的接口。其实将系统调用做个封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_write, fd, (<span class="type">intptr_t</span>)buf, count); <span class="comment">//记得设返回值，不然printf会重复输出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是实现堆区管理。这里的用户接口是_sbrk(int increment)，参数是请求分配的长度。它负责维护program break，即当前堆区终点。其工作方式如下：</p><ul><li>将program break初始化到end位置。</li><li>被调用时，计算新的program break = program_bread + increment。</li><li>通过SYS_brk向操作系统请求分配到新program break的堆空间。</li><li>若系统调用返回0，分配成功，更新program break，并将旧program break的值作为返回值返回。</li><li>若失败，返回-1。</li></ul><p>这里end的使用方法需要查手册。end是一个被放在程序数据段结尾的字符，&amp;end可以读出它的地址，即数据段结尾地址，也就是堆区起点。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end;</span><br><span class="line"><span class="type">void</span> *program_break = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> *_sbrk(<span class="type">intptr_t</span> increment) &#123;</span><br><span class="line">  <span class="keyword">if</span> (program_break == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    program_break = &amp;end; <span class="comment">//如果是第一次被调用，要初始化program_break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">void</span> *addr = program_break + increment;</span><br><span class="line">  <span class="keyword">if</span> (_syscall_(SYS_brk, (<span class="type">intptr_t</span>)addr, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    program_break = addr;</span><br><span class="line">    <span class="keyword">return</span> addr - increment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_brk</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行hello就可以顺利输出字符串了。</p><p>PA3-2 over!</p><h5 id="必答题-hello程序是什么-它从而何来-要到哪里去"><a href="#必答题-hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="必答题 - hello程序是什么, 它从而何来, 要到哪里去"></a>必答题 - hello程序是什么, 它从而何来, 要到哪里去</h5><blockquote><p>我们知道<code>navy-apps/tests/hello/hello.c</code>只是一个C源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</p></blockquote><p>hello被编译成ELF文件后，我们将它放进了硬盘(ramdisk.img)里，然后nanos在执行到init_proc()时，调用naive_uload()，naive_uload()又调用loader()加载ramdisk.img里面的hello程序。loader()会依次读取hello的ELF头和program header，根据从program header获取需要加载的内容在ELF中的位置、要加载到的内存位置、需加载的文件长度等信息，根据这些信息将程序加载到内存空间。它的第一条指令由ELF头的e_entry指示，它是loader函数的返回值。naive_uload获取到入口地址之后就跳转到第一条指令开始执行。</p><p>hello通过printf()输出字符串。printf在经过一系列逻辑处理之后，通过标准输出的用户接口_write()。这个函数会将参数储存在规定的寄存器中，然后触发SYS_write的系统调用。当程序运行到ecall时，跳转到中断响应程序。识别事件类型为系统调用后，交给nanos注册的回调函数do_event处理。do_event识别系统调用类型为SYS_write，调用sys_write，最后通过putch一个个输出字符。</p><h2 id="PA3-3"><a href="#PA3-3" class="headerlink" title="PA3-3"></a>PA3-3</h2><h3 id="简易文件系统"><a href="#简易文件系统" class="headerlink" title="简易文件系统"></a>简易文件系统</h3><p>下面在nanos里实现一个简易文件系统。PA中的硬盘是用ramdisk.img这个文件模拟的。每次更新navy-apps中的内容并编译更新之后，更新的文件会被载入到ramdisk.img文件中，同时更新文件记录表ramdisk.h。需要读取某一个文件时，只需要查这个表，获得所需文件在ramdisk.img内的位置和长度，然后读取文件即可。框架代码已经实现了部分功能，我们只需要实现以下四个函数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>这些函数在c语言中都有原型，可以通过手册查看它们的功能。</p><p>首先是fs_open。我们可以无视flags和mode，只关注文件名pathname即可。这个函数需要在文件目录内查找匹配文件名，然后返回文件描述符。这里文件描述符直接用文件记录表中的下标，之后读写文件就可以用这个下标来访问文件了。</p><p>实现另外几个函数之前，先给Finfo结构体增加一个成员变量open_offset，用于记录此文件的目前操作位置。每次读写几个字节，open_offset就增加多少，这样下次读写文件就可以直接从上次的末尾继续了。</p><p>fs_read()和fs_write()的实现类似。首先，为防止操作越过文件边界，确定最大文件读写长度，为<code>文件大小-open_offset</code>和参数<code>len</code>的较小值。然后通过<code>ramdisk_read()</code>和<code>ramdisk_write()</code>对文件进行读写。最后修改<code>open_offset</code>。</p><p>另外，stdin, stdout, stderr是虚拟的文件，ramdisk内不存在并没有它们，所以对它们读写需要特殊操作。我们只需要处理stdout和stderr的写入。注意到，Finfo结构体有两个函数变量read和write。普通文件的这两个变量为空，它们应该用正常方式读写。特殊文件这两个变量不为空时，需要用这两个函数读写。stdout和stderr的写入就是将字符输出到串口。所以我们需要实现device.c中的serial_write()，通过putch把buf存储的字符串一个个输出来。然后修改file_table，把stdin和stdout的write函数修改成serial_write。最后还要在fs_read()和fs_write()里做个判断，如果存在特殊读写函数，调用读写函数；否则，按普通方式读写文件。</p><p>最后实现fs_leek()。这个函数将open_offset移动到指定为止。根据whence，有三种不同的偏移方式：</p><ul><li>SEEK_SET：从文件头开始偏移，open_offset = offset</li><li>SEEK_CUR：从当前位置开始偏移，open_offset += offset</li><li>SEEK_END：从文件末尾开始偏移，open_offset = file_size + offset （此时offset一般为负数；offset为0可读取文件长度）</li></ul><p>最后还要检查是否超出文件边界。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_files; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pathname, file_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">      file_table[i].open_offset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;no such file&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (file_table[fd].read) <span class="keyword">return</span> file_table[fd].read(buf, file_table[fd].open_offset, len);</span><br><span class="line">  <span class="type">size_t</span> max_len = file_table[fd].size - file_table[fd].open_offset;</span><br><span class="line">  len = len &lt; max_len ? len : max_len;</span><br><span class="line">  <span class="type">int</span> rl = ramdisk_read(buf, file_table[fd].disk_offset + file_table[fd].open_offset, len);</span><br><span class="line">  file_table[fd].open_offset += len;</span><br><span class="line">  <span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (file_table[fd].write) <span class="keyword">return</span> file_table[fd].write(buf, file_table[fd].open_offset, len);</span><br><span class="line">  <span class="type">size_t</span> max_len = file_table[fd].size - file_table[fd].open_offset;</span><br><span class="line">  len = len &lt; max_len ? len : max_len;</span><br><span class="line">  <span class="type">int</span> rl = ramdisk_write(buf, file_table[fd].disk_offset + file_table[fd].open_offset, len);</span><br><span class="line">  file_table[fd].open_offset += len;</span><br><span class="line">  <span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> new_offset;</span><br><span class="line">  <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEEK_SET: new_offset = offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_CUR: new_offset = file_table[fd].open_offset + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_END: new_offset = file_table[fd].size + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_offset &gt;= file_table[fd].size) new_offset = file_table[fd].size;</span><br><span class="line">  file_table[fd].open_offset = new_offset;</span><br><span class="line">  <span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>接下来在Navy和Nanos的syscall.c里添加相应的系统调用，就可以通过file_test了。</p><p>之前实现的loader默认要执行的程序放在文件开头，现在有了文件系统，就可以通过文件名找到程序在文件中的位置了。实现很简单，在loader函数中，先用fs_open打开文件，获取文件描述符fd，下面用fs_read(fd, …)操作就行了。完成之后，修改proc.c的init_proc()函数，调用naive_uload()时第二个参数改为“/bin/file-test”，就可以将要执行的文件名传给loader了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load program here</span></span><br><span class="line">naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/file-test&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在Navy的Makefile内，test后加上file-test，update，run，运行测试。PASS！</p><h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><p>时钟时输入设备，但一般通过一个单独的系统调用来获取时间，而不是抽象成文件。获取时间使用系统调用gettimeofday。下面实现此系统调用。sys_gettimeofday()函数需要用io_read()获取当前时刻，将当前时刻的秒和微秒写入一个结构体Timeval。PA2实现的ioe忘记怎么用了，重温~/ics2023/abstract-machine/am/src/platform/nemu/ioe/。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_gettimeofday</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv</span> =</span> (<span class="keyword">struct</span> timeval *)c-&gt;GPR2;</span><br><span class="line">  <span class="type">uint64_t</span> time = io_read(AM_TIMER_UPTIME).us; </span><br><span class="line">  tv-&gt;tv_sec = time / <span class="number">1000000</span>;</span><br><span class="line">  tv-&gt;tv_usec = time % <span class="number">1000000</span>;</span><br><span class="line">  c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加系统调用。下面实现NDL_GetTicks()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">NDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">   gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个ioe是键盘。操作系统要向用户程序传递键盘信息，首先要规定信息的格式。我们使用简单的字符串</p><ul><li>按下按键事件, 如<code>kd RETURN</code>表示按下回车键</li><li>松开按键事件, 如<code>ku A</code>表示松开<code>A</code>键</li></ul><p>用户程序通过系统调用请求键盘信息时，操作系统直接将上述字符串填入buf，传给用户程序。这样，用户程序就可以像读取文件一样读取键盘信息了。所以，把键盘抽象成一个虚拟文件<code>/dev/events</code>，并用函数events_read()来读取信息。在file_table添加表项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, events_read&#125; <span class="comment">// 不必实现lseek，位移和大小都是0就行</span></span><br></pre></td></tr></table></figure><p>接下来需要实现events_read()。用io_read(AM_INPUT_KEYBRD)读取键盘信息，然后写入字符串。这里我为了防止字符串长度超出限制，先填入另一个字符串，确定长度之后再写入buf。或许有点过分谨慎了。。。而且应该用sprintf更优雅，但是懒得改了。最后在字符串末尾填0，不然后续问题很麻烦。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">events_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123; </span><br><span class="line">  <span class="comment">//这段代码写得及其丑陋。。。</span></span><br><span class="line">  <span class="type">int</span> real_len = <span class="number">0</span>; </span><br><span class="line">  <span class="type">char</span> str_buf[<span class="number">15</span>];</span><br><span class="line">  AM_INPUT_KEYBRD_T kbd = io_read(AM_INPUT_KEYBRD);</span><br><span class="line">  <span class="keyword">if</span> (kbd.keycode == AM_KEY_NONE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (kbd.keydown) <span class="built_in">strcpy</span>(str_buf, <span class="string">&quot;kd &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">strcpy</span>(str_buf, <span class="string">&quot;ku &quot;</span>);</span><br><span class="line">  real_len += <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(str_buf + real_len, keyname[kbd.keycode]);</span><br><span class="line">  real_len += <span class="built_in">strlen</span>(keyname[kbd.keycode]);</span><br><span class="line">  len = len &lt; real_len ? len : real_len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    ((<span class="type">char</span> *)buf)[i] = str_buf[i];</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">char</span> *)buf)[len] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> NDL_PollEvent()就很简单了，用读文件的方式读取键盘就可以了。返回值需要注意一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_PollEvent</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ret = read(fd, buf, len);</span><br><span class="line">  <span class="keyword">return</span> ret == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是VGA。我们需要添加两个虚拟文件：显存(fb)和屏幕尺寸信息(dispinfo)，并使用特殊写入函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, fb_write&#125;,</span><br><span class="line">&#123;<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, dispinfo_read&#125;,</span><br></pre></td></tr></table></figure><p>跟键盘信息一样，屏幕信息也用字符串表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WIDTH : <span class="number">400</span></span><br><span class="line">HEIGHT : <span class="number">300</span></span><br></pre></td></tr></table></figure><p>所以，dispinfo_read()要做的就是把读取屏幕信息，并把字符串填入buf。另外，由于下面实现fb_write()需要屏幕长宽信息，所以在dispinfo_read()读取屏幕长宽之后，我顺便把它们存起来，方便后面使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> screen_w = <span class="number">0</span>, screen_h = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">dispinfo_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_GPU_CONFIG_T cfg = io_read(AM_GPU_CONFIG);</span><br><span class="line">  screen_w = cfg.width; screen_h = cfg.height;</span><br><span class="line">  <span class="comment">// snprintf, 如此优雅！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, len, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, screen_w, screen_h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是显存。由于它需要支持lseek，但我们无法在编写代码时确定文件大小（即屏幕大小），需要在inif_fs()中初始化显存大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> initialize the size of /dev/fb</span></span><br><span class="line">file_table[FD_FB].size = io_read(AM_GPU_CONFIG).vmemsz;</span><br></pre></td></tr></table></figure><p>接下来是实现fb_write()，需要调用io_write(AM_GPU_FBDRAW, …)写入显存。由于fb_write()只知道写入的起始位置和长度，不知道应该在何处换行，因此虽然io_write(AM_GPU_FBDRAW, …)能同时填充多行的矩形，fb_write()一次调用也只能填充一行。在dispinfo_read()被调用时已经保存了屏幕长宽，再根据offset就可以计算出写入的起始坐标了。因为只能写一行，填入矩形的宽为len，高为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">// 以四字节为一个单位，需要做一些转化。</span></span><br><span class="line">  io_write(AM_GPU_FBDRAW, (offset % (screen_w * <span class="number">4</span>)) / <span class="number">4</span>,</span><br><span class="line">           offset / (screen_w * <span class="number">4</span>), (<span class="type">uint32_t</span> *)buf, len / <span class="number">4</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备好了操作系统写入显存的功能，就可以实现NDL的一些图像函数了。在NDL中，我们也需要直到屏幕的尺寸，所以可以在NDL_init()里首先从/proc/dispinfo文件读出屏幕信息并记录在全局变量screen_w和screen_h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_Init</span><span class="params">(<span class="type">uint32_t</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> dispinfo = open(<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  read(dispinfo, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, &amp;screen_w, &amp;screen_h);</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    evtdev = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NDL_OpenCanvas()只需要记录画布大小即可。查阅API手册，发现若NDL_OpenCanvas()传入的参数w, h都指向0，需要分别修改为屏幕长和高，即让画布占满屏幕。否则将画布长和高设为w和h，并将画布长和高记录在全局变量canvas_w和canvas_h里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(*w == <span class="number">0</span> &amp;&amp; *h == <span class="number">0</span>) &#123;</span><br><span class="line">    *w = screen_w;</span><br><span class="line">    *h = screen_h;</span><br><span class="line">  &#125; </span><br><span class="line">  canvas_w = *w;</span><br><span class="line">  canvas_h = *h;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写下来是NDL_DrawRect()。它需要把一个颜色信息填充到指定位置的矩形矩形。由于上面实现的写入显存只能逐行写入，这里也需要逐行填充。先打开显存文件/dev/fb，写入每一行前，先用lseek把文件指针移动到此行要写入的第一个像素点处，再写入一行的信息。同样需要注意一单位为四字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, (screen_w * (i + y) + x) * <span class="number">4</span>, SEEK_SET);</span><br><span class="line">    write(fd, pixels + w * i, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行bmp-test可以看到屏幕上显示Logo。</p><p><img src="9d1f5d7b92ded7a96638233931b2731.png" alt="9d1f5d7b92ded7a96638233931b2731"></p><h3 id="更丰富的运行时环境"><a href="#更丰富的运行时环境" class="headerlink" title="更丰富的运行时环境"></a>更丰富的运行时环境</h3><p>PA3剩下的部分基本是去运行一些应用程序了。很多应用程序都会调用SDL库，而SDL库大部分函数都没有实现。为了防止程序运行时用到了某个没有实现的函数还傻傻没发现，我们先在每个未实现函数中加一句assert(0)。若程序调用某个未实现函数，程序就会立即停止，我们就很容易找到它了。</p><p>nemu没有实现浮点数运算，但是可以用定点算数来进行实数运算。这是一种不同于IEEE754的一种及其简单的32位实数表示法。简单来说就是前24位是整数位，后8位是小数位。这种表示法的实数做加减法运算只需要将它当场整数运算就行。做乘法需要相乘后右移八位，做除法需要相除后左移八位。这样一来，即使硬件不支持实数运算，也可以用软件来实现了。这里只涉及一些简单的数学推导，难度不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Multiplies a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_muli</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A * B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Divides a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_divi</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A / B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Multiplies two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_mul</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">int64_t</span>)A * B) &gt;&gt; FIXEDPT_FBITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Divides two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_div</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">uint64_t</span>)(A &lt;&lt; FIXEDPT_FBITS) / B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_abs</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A &gt; <span class="number">0</span> ? A : -A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_floor</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (A &gt;&gt; FIXEDPT_FBITS) &lt;&lt; FIXEDPT_FBITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_ceil</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fixedpt_floor(A + <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navy中的应用程序"><a href="#Navy中的应用程序" class="headerlink" title="Navy中的应用程序"></a>Navy中的应用程序</h3><p>尝试在Nanos中运行NSlider播放幻灯片。需要实现void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h)。先看它的参数，s是一个SDL_Surface结构体，包含了一帧画面信息。其变量w, h是画布长和高，pixels数组是每个像素点的颜色，按行优先排列。其实SDL_UpdateRect()和NDL_DrawRect()实现的功能基本相同。只是SDL_UpdateRect()的参数s中包含了整个屏幕的颜色信息，而NDL_DrawRect()的参数pixels只含有需要填充的矩形的颜色信息。故SDL_UpdateRect()只需要将从s-&gt;pexels中提取中需要填充的矩形的颜色信息，再调用NDL_DrawRect()就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>) &#123; <span class="comment">// w=h=0时，使用默认大小即全屏</span></span><br><span class="line">    w = s-&gt;w;</span><br><span class="line">    h = s-&gt;h;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="type">uint32_t</span> *pixel = <span class="built_in">malloc</span>(w * h * <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> *src = (<span class="type">uint32_t</span> *)s-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(pixel + w * i, src + (y + i) * s-&gt;w + x, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  NDL_DrawRect(pixel, x, y, w, h);</span><br><span class="line">  <span class="built_in">free</span>(pixel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个要实现的SDL函数是 SDL_WaitEvent()。这个函数不停通过NDL_PollEvent()读取键盘信息，直到读取到键盘按下或弹起，然后根据读入字符串的第2位是’d’还是’u’来判断是键盘按下还是弹起，再把字符串第4位起的子字符串与keyname中的按键名称逐一比对，确定按键。将按键信息存入传入的结构体指针，再返回1。实现了这个函数就可以通过按键给幻灯片翻页了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_WaitEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    event-&gt;type = buf[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span> ? SDL_KEYUP : SDL_KEYDOWN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">83</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyname[i], buf + <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        event-&gt;key.keysym.sym = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后可以将导入的PDF转化成幻灯片显示出来了。运行convert.sh前需要先<code>sudo apt install imagemagick</code>，安装ImageMagick。运行nslider就可以看到幻灯片了。还能通过up和down键翻页。</p><p><img src="09be4fd6e56ae4ae02d45830c7d0fe9.png" alt="09be4fd6e56ae4ae02d45830c7d0fe9"></p><p>下一个应用程序是开机菜单Menu。需要实现两个SDL函数：SDL_BlitSurface()和SDL_FillRect()。</p><p>SDL_BlitSurface():将一张画布中的指定矩形区域复制到另一张画布的指定位置。首先需要确定源矩形和目标矩形的位置，以及矩形大小。需要分别考虑srcrect和dstrect分别为空和非空的情况。按以下规定来确定。</p><ul><li>规定符号 w: 画布宽 h: 画布高 (sx, sy): 源矩形位置坐标 (dx, dy): 目标矩形位置坐标</li><li>srcrect不为空时， 按srcrect设置w, h, sx, sy；</li><li>srcrect为空时，(sx, xy) = (0, 0)，w, h设为src的w, h(画布的宽和高)，即整个画布；</li><li>dstrect不为空时，按dstrect设置dx, dy；</li><li>dstrect为空时，(dx, dy) = (0, 0)。</li></ul><p>之后将src-&gt;pixels的内容复制到dst-&gt;pixels对应位置就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_BlitSurface</span><span class="params">(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst,</span></span><br><span class="line"><span class="params">                     SDL_Rect *dstrect)</span> &#123;</span><br><span class="line">  assert(dst &amp;&amp; src);</span><br><span class="line">  assert(dst-&gt;format-&gt;BitsPerPixel == src-&gt;format-&gt;BitsPerPixel);</span><br><span class="line">  <span class="type">int</span> w, h;</span><br><span class="line">  <span class="type">int</span> sx, sy, dx, dy;</span><br><span class="line">  <span class="keyword">if</span> (srcrect) &#123;</span><br><span class="line">    w = srcrect-&gt;w; h = srcrect-&gt;h;</span><br><span class="line">    sx = srcrect-&gt;x; sy = srcrect-&gt;y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sx = sy = <span class="number">0</span>;</span><br><span class="line">    w = src-&gt;w; h = src-&gt;h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dstrect) &#123;</span><br><span class="line">    dx = dstrect-&gt;x; dy = dstrect-&gt;y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dx = dy = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> *sp = (<span class="type">uint32_t</span> *)src-&gt;pixels;</span><br><span class="line">  <span class="type">uint32_t</span> *dp = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      dp[(dy + i) * dst-&gt;w + dx + j] = sp[(sy + i) * src-&gt;w + sx + j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>SDL_FillRect()往画布的指定矩形区域中填充指定的颜色。同样要处理dstrect为空和非空的情况，方法和SDL_BlitSurface相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y, w, h;</span><br><span class="line">  <span class="keyword">if</span> (dstrect) &#123;</span><br><span class="line">    x = dstrect-&gt;x; y = dstrect-&gt;y;</span><br><span class="line">    w = dstrect-&gt;w; h = dstrect-&gt;h;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w = dst-&gt;w;  h = dst-&gt;h;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      pixels[(y + i) * dst-&gt;w + x + j] = color;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Menu可以看到菜单界面。</p><p><img src="94de8b722d07ac6f014b4ee35f35638.png" alt="94de8b722d07ac6f014b4ee35f35638"></p><p>下一个应用程序Nterm，一个简易终端。需要实现两个SDL函数SDL_GetTicks()和SDL_PollEvent()。</p><p>SDL_GetTicks()直接返回NDL_GetTicks()就行了，两者功能完全相同。</p><p>SDL_PollEvent()和SDL_WaitEvent()相似，只是SDL_WaitEvent()会不停读取键盘信息直到有事件发生，而SDL_PollEvent()只读取一次，若没有事件发生，直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_PollEvent</span><span class="params">(SDL_Event *ev)</span> &#123;</span><br><span class="line">  CallbackHelper(<span class="number">2</span>);</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  ev-&gt;type = buf[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span> ? SDL_KEYUP : SDL_KEYDOWN;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">83</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyname[i], buf + <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      ev-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面运行一个游戏Flappy Bird。需要实现IMF-Koad()，实现方式文件写得很清楚了：</p><ol><li>用libc中的文件操作打开文件, 并获取文件大小size</li><li>申请一段大小为size的内存区间buf</li><li>将整个文件读取到buf中</li><li>将buf和size作为参数, 调用<code>STBIMG_LoadFromMemory()</code>, 它会返回一个<code>SDL_Surface</code>结构的指针</li><li>关闭文件, 释放申请的内存</li><li>返回<code>SDL_Surface</code>结构指针</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDL_Surface* <span class="title function_">IMG_Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="type">void</span> *buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">  lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  read(fd, buf, size);</span><br><span class="line">  SDL_Surface *surface = STBIMG_LoadFromMemory((<span class="type">char</span> *)buf, size);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好之后运行游戏。帧数有点低，但是能玩。</p><p><img src="7104bd4e45b94cb7afad614f757f2b9.png" alt="7104bd4e45b94cb7afad614f757f2b9"></p><p>终于到PAL(仙剑奇侠传)啦！PAL不需要实现其它的函数，但是要增强一些SDL函数的功能，让它支持8位像素格式。其实只要增加一个条件判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(src-&gt;format-&gt;BitsPerPixel == <span class="number">32</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(src-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现内容基本一样。SDL_UpdateRect()在最后调用NDL_DrawRect()，传入的参数pixels必须是32位格式的，不然会显示错误颜色。因此需要现将8位颜色转为32位的，再填入pixels。s-&gt;format-&gt;palette-&gt;colors是一个SDL_Color类型的数组，以8位颜色为下标时可以获得其对应的SDL_Color，结构体包含rgba四个8位数字，再写一个函数将4个8位数字转化为一个32位数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">color_translater</span><span class="params">(SDL_Color *c)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (c-&gt;a &lt;&lt; <span class="number">24</span>) | (c-&gt;r &lt;&lt; <span class="number">16</span>) | (c-&gt;g &lt;&lt; <span class="number">8</span>) | c-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填充pixel:</span></span><br><span class="line">pixel[i * w + j] = color_translater(&amp;s-&gt;format-&gt;palette-&gt;colors[src[(y + i) * s-&gt;w + x + j]]);</span><br></pre></td></tr></table></figure><p>尝试运行PAL，发现assert(0)了。原来是SDL_GetKeyState()没有实现。这个函数需要返回一个指针，指向一个数组，这个数组实时反映按键的状态，若某个按键被按下，对应位置为1，否则为0。所以我们要维护一个数组，大小为按键数目。在SDL_PollEvent()或SDL_WaitEvent()发现按键按下时，将数组对应位置改为1，按键弹起时，重置为0。SDL_GetKsyState()直接返回这个数组地址。另外还要往参数numkeys指向位置写入按键的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *<span class="title function_">SDL_GetKeyState</span><span class="params">(<span class="type">int</span> *numkeys)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (numkeys) *numkeys = <span class="number">83</span>;</span><br><span class="line">  <span class="keyword">return</span> key_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，可以运行PAL了。</p><p><img src="c67a925b441a8c1312d8df31c39ad80.png" alt="c67a925b441a8c1312d8df31c39ad80" style="zoom:75%;" /></p><p><img src="df624eba8247425258fef010a24c817.png" alt="df624eba8247425258fef010a24c817"></p><p>接下来实现AM的API。首先是ioe_read()和ioe_write()。由于用户程序是跑在Nanos上的，它并不能直接调用AM的ioe_read和ioe_write，这是直接跑在Nemu上的Nanos的权限。所以用户程序需要通过系统调用实现ioe。用什么系统调用呢？当然是read和write，因为它们的本质都是读写文件，只要把ioe也当成文件就可以了。但ioe的设备寄存器有很多个，难道要为每个设备寄存器设置一个文件吗？其实有个方法，我们用文件指针来表示读取哪个寄存器。所有的ioe都抽象为同一个文件，用文件的open_offset区分具体指向哪一个ioe。用户程序打开这个文件后，将文件指针移动到<code>reg</code>位置上，再读写。操作系统处理读写时，就以<code>open_offset</code>判断读取哪个寄存器就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件记录表中添加表项</span></span><br><span class="line">&#123;<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">128</span>, <span class="number">0</span>, am_ioe_read, am_ioe_write&#125;</span><br><span class="line"><span class="comment">// 实现两个读写操作函数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">am_ioe_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  ioe_read(offset, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">am_ioe_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  ioe_write(offset, (<span class="type">void</span> *)buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~/ics2023/navy-apps/libs/libam/src/ioe.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_read</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lseek(fd, reg, SEEK_SET);</span><br><span class="line">  read(fd, buf, <span class="number">0</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_write</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lseek(fd, reg, SEEK_SET);</span><br><span class="line">  write(fd, buf, <span class="number">0</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以在nanos上运行am应用打字游戏了。</p><p>运行FCEUX不需要其它写另外的代码，但是有个坑。fceux的main函数在此处<code>/home/sprooc/ics2023/fceux-am/src/drivers/sdl/sdl.cpp</code>。RTFSC可以发现，如果定义了宏<code>__NO_FILE_SYSTEM__</code>，main函数有一个参数<code>romname</code>，表示要运行的游戏名称，但我们没法给main函数传参（或许有的，只是我实在搞不懂），所以<code>romname</code>是个空指针，后面会读取空指针导致错误。但是，如果我们不定义<code>__NO_FILE_SYSTEM__</code>，就会从argv里获取游戏名称，如果没有传入参数，使用默认的游戏路径，这样即使不传参也可以运行了。所以要取消掉宏定义<code>__NO_FILE_SYSTEM__</code>。加一句<code>undef</code>或修改Makefile都可以。下面是在Nanos打开的fceux界面。</p><p><img src="1818d9d700c49467344ebf58e7b25e3.png" alt="1818d9d700c49467344ebf58e7b25e3"></p><p>下面实现运行Nplayer。由于我最后没有成功运行，所以不保证以下内容的正确性。</p><p>添加两个音频相关的设备文件：声卡的流缓冲区，声卡控制和状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/sb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, sb_write&#125;,</span><br><span class="line">&#123;<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, sbctl_read, sbctl_write&#125;,</span><br></pre></td></tr></table></figure><p>然后实现它们的读写函数。<code>sb_write()</code>（名字有点不文雅，但它确实叫这名）调用<code>ioe_write()</code>写入流缓冲区，需要Area结构体参数，结构体包含start(写入内容起始地址), end(写入内容末尾地址)。在<code>sb_write()</code>填好这个结构体，调用ioe_write就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  Area wbuf;</span><br><span class="line">  wbuf.start = (<span class="type">void</span> *)buf;</span><br><span class="line">  wbuf.end = (<span class="type">void</span> *)buf + len;</span><br><span class="line">  io_write(AM_AUDIO_PLAY, wbuf);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sbctl_write()</code>往声卡的控制寄存器写入三个值：<code>freq</code>, <code>channels</code>, <code>samples</code>，它们会被依次放在buf后的12个字节。以它们为参数调用<code>io_write(AM_AUDIO_CTRL, ...)</code>就行了。<code>stctl_write()</code>要读取声卡流缓冲区的空闲字节数。AM_AUDIO_CONFIG和AM_AUDIO_STATUS分别存有流缓冲区的总容量和已写入字节数，它们的差值就是空闲字符数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sbctl_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_AUDIO_CONFIG_T cfg = io_read(AM_AUDIO_CONFIG);</span><br><span class="line">  AM_AUDIO_STATUS_T stat = io_read(AM_AUDIO_STATUS);</span><br><span class="line">  *((<span class="type">uint32_t</span> *)buf) = cfg.bufsize - stat.count;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再NDL对这些音频文件的读写操作做个简单的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenAudio</span><span class="params">(<span class="type">int</span> freq, <span class="type">int</span> channels, <span class="type">int</span> samples)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sbctl = open(<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">uint32_t</span> buf[] = &#123;freq, channels, samples&#125;;</span><br><span class="line">  write(sbctl, (<span class="type">void</span> *)buf, <span class="number">12</span>);</span><br><span class="line">  close(sbctl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_PlayAudio</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sb = open(<span class="string">&quot;/dev/sb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> write(sb, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_QueryAudio</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> sbctl = open(<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  read(sbctl, (<span class="type">void</span> *)&amp;size, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在SDL做进一步封装。首先看SDL_OpenAudio()，这个函数需要从desired获取freq, channels, samples三个信息，使用它们初始化声卡设备。desired还有一个参数callback，这是一个用户程序注册回调函数，这个函数用于填充音频数据，需要由SDL定期调用它来获取音频数据，并将获得的数据写到声卡流缓冲区。这貌似要用多线程，因为在定期调用和其它代码的执行应该是并行的。使用多线程应该是正解，但在Navy里面实现太麻烦了，我们另辟蹊径。查看nplayer的代码，SDL_PauseAudio(0)之后音频开始播放，这之后SDL应该定期调用回调函数。同时nplayer进入一个循环，重复调用SDL_PollEvent(&amp;ev)查询事件，直到音频播放完成。我们不如让SDL_PollEvent()调用回调函数，这样同样可以实现nplayer循环和SDL回调函数同时运行的效果。我们实现一个函数CallbackHelper()，维护一个计时器和音频播放状态。<code>st</code>为1时，播放，<code>st</code>为0时，停止播放。传入的参数flag用于修改st。flag为1时，st设为1；flag为0时，st设为0；flag为2时，不改变状态。因此开始播放时以1为参数调用它；SDL_PollEvent以2为参数调用，使其保持运行状态以定期调用回调函数；关闭音频时以0为参数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CallbackHelper</span><span class="params">(<span class="type">int</span> flag)</span> &#123; <span class="comment">//1: start; 0: stop; 2: contunue</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> timer = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> st = <span class="number">0</span>; <span class="comment">// 1 running ; 0 no working</span></span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">1</span>) st = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">0</span>) st = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(st == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(SDL_GetTicks() - timer &lt; gap) <span class="keyword">return</span>;</span><br><span class="line">  timer = SDL_GetTicks();</span><br><span class="line">  callback(<span class="literal">NULL</span>, stream, samples);</span><br><span class="line">  NDL_PlayAudio(stream, samples);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">SDL_OpenAudio</span><span class="params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span> &#123;</span><br><span class="line">  freq = desired-&gt;freq;</span><br><span class="line">  gap = <span class="number">1000</span> / freq;</span><br><span class="line">  channels = desired-&gt;channels;</span><br><span class="line">  samples = desired-&gt;samples;</span><br><span class="line">  callback = desired-&gt;callback;</span><br><span class="line">  NDL_OpenAudio(freq, channels, samples);</span><br><span class="line">  stream = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(samples);</span><br><span class="line">  CallbackHelper(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_CloseAudio</span><span class="params">()</span> &#123; CallbackHelper(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_PauseAudio</span><span class="params">(<span class="type">int</span> pause_on)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(pause_on != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">uint32_t</span> delay = <span class="number">1000</span> / freq;</span><br><span class="line">  <span class="type">uint8_t</span> *stream = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(samples);</span><br><span class="line">  CallbackHelper(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现好之后运行nplayer，却在音频解析的时候就错误了，跟自己实现的函数应该没有关系。我弄不清楚于是就放弃了。</p><p><img src="95de1c1a4545547ca9a098de6b929a2.png" alt="95de1c1a4545547ca9a098de6b929a2"></p><h3 id="基础设施-3"><a href="#基础设施-3" class="headerlink" title="基础设施(3)"></a>基础设施(3)</h3><p>这部分不太想写。。。</p><h3 id="展示你的批处理系统"><a href="#展示你的批处理系统" class="headerlink" title="展示你的批处理系统"></a>展示你的批处理系统</h3><p>实现系统调用sys_execve:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_execve</span><span class="params">(Context *c)</span> &#123; naive_uload(<span class="literal">NULL</span>, (<span class="type">const</span> <span class="type">char</span> *)c-&gt;GPR2); &#125;</span><br></pre></td></tr></table></figure><p>再修改sys_exit，就可以使用开机菜单来选择要运行的程序了。</p><p>接下来尝试换成nterm。主要是实现nterm的<code>sh_handle_cmd()</code>函数。这里有点坑，命令字符串的末尾会有一个换行，如果直接用这个字符串作为文件名会因为多了个换行符无法匹配，所以要把换行符去掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  <span class="type">char</span> *str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">strncpy</span>(str, cmd, len - <span class="number">1</span>);</span><br><span class="line">  str[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// execve(str, NULL, NULL);</span></span><br><span class="line">  execvp(str, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="必答题-理解计算机系统"><a href="#必答题-理解计算机系统" class="headerlink" title="必答题 - 理解计算机系统"></a>必答题 - 理解计算机系统</h5><blockquote><p>仙剑奇侠传究竟如何运行 运行仙剑奇侠传时会播放启动动画, 动画里仙鹤在群山中飞过. 这一动画是通过<code>navy-apps/apps/pal/repo/src/main.c</code>中的<code>PAL_SplashScreen()</code>函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件<code>mgo.mkf</code>中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从<code>mgo.mkf</code>文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么? (Hint: 合理使用各种trace工具, 可以帮助你更容易地理解仙剑奇侠传的行为)</p></blockquote><p>每一次更新画面，先从mgo.mkf中读取此帧的像素信息，用SDL_BlitSurface()等函数填充Surface的缓冲区，最后调用SDL_UpdateRect()更新画面。SDL_UpdateRect()读取相应信息之后调用NDL_DrawRect()，NDL_DrawRect()通过系统调用打开显存设备文件，往显存里面写入画面数据。用户程序最终会调用libos里的__syscall__()函数发起系统调用，然后转移到nanos执行。nanos通过fb_write()函数处理这个写入显存的操作。它会调用AM提供的接口io_write()往设备寄存器AM_GPU_FBDRAW写入数据。这段指令在机器代码中被会被翻译成往FB_ADDR这个地址里写入数据。当Nemu执行到这个写指令时，会发现这个地址映射到显存，故并不实际地往里面写数据，而是调用SDL库把画面显示到屏幕上。到此完成了更新屏幕画面的全过程。</p><p>PA3到此结束！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ics-pa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, world!</title>
      <link href="/2023/11/15/Hello-world/"/>
      <url>/2023/11/15/Hello-world/</url>
      
        <content type="html"><![CDATA[<p>诞生于2023/11/14。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
