<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>倍增算法</title>
      <link href="/2024/01/23/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/01/23/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>所谓“倍增”，就是成倍增长。在一些求解空降较大的问题中，如果使用通常的线性递推，需要线性的时间复杂度。而如果采用倍增的方式，通常能优化为对数时间复杂度。简单地解释倍增思想，就是每次都试图使结果范围扩大一定长度，如果扩大后仍满足要求，则扩大，并将下一次试图扩大的长度变为原来的两倍；若不满足，则将扩大长度减半，再次尝试，若仍不满足，则继续减半。最终，扩大长度减为0，就得到了所需的结果。下面是两个使用倍增算法的例子。</p><h3 id="求小于T的最大数组前缀和"><a href="#求小于T的最大数组前缀和" class="headerlink" title="求小于T的最大数组前缀和"></a>求小于T的最大数组前缀和</h3><blockquote><p>给定一个长度为N的数列 A，然后进行若干次询问，每次给定一个整数T,求大的 k，满足 $\sum_{i=1}^{N}{A[i]}\le T$。你的算法必须是在线的（必须即时回答每一个询问能等待收到所有询问后再统一处理），假设$0\le T\le\sum_{i=1}^{N}{A[i]}$。</p></blockquote><ol><li>最朴素的做法当然是从前往后累加数组，直到累加和大于T，时间复杂度是O(N)。</li><li>首先用O(N)的时间预处理，求出前缀和数组，再用二分查找确定小于等于T的上界。每次查找O(logN)。</li><li>如果每次查找的T都很小，使用二分查找可能还不如直接从头遍历数组，那么可以使用倍增算法：<ol><li>令p=1，k=0，sum=0。</li><li>比较“A数组中 k之后的p个数的和”与T的关系，也就是说，如果 sum+S[k+p]-S[k]≤T,则令 sum+=S[k+p]-S[k],k+=p,p*=2,即累加上这 p个数的和，然后把p的跨度增长一倍。如果sum+S[k+p]-S[k]&gt;T，则令 p/= 2。</li><li>重复上一步，直到p的值变为0，此时k就是答案。</li></ol></li></ol><p>下面给出使用二分查找和倍增算法的代码，并比较二者的求解时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pre_sum;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; xs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    pre_sum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : xs) &#123;</span><br><span class="line">      sum += x;</span><br><span class="line">      pre_sum.<span class="built_in">push_back</span>(sum);</span><br><span class="line">      nums.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用倍增算法查询</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query_double</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, l = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k + l &lt; pre_sum.<span class="built_in">size</span>() &amp;&amp; sum + pre_sum[k + l] - pre_sum[k] &lt;= t) &#123;</span><br><span class="line">        sum += (pre_sum[k + l] - pre_sum[k]);</span><br><span class="line">        l *= <span class="number">2</span>;</span><br><span class="line">        k += l;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 通过二分查找查询</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query_binary_search</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> loc = <span class="built_in">upper_bound</span>(pre_sum.<span class="built_in">begin</span>(), pre_sum.<span class="built_in">end</span>(), t);</span><br><span class="line">    <span class="keyword">return</span> loc - pre_sum.<span class="built_in">begin</span>() - <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="comment">// 设置随机数</span></span><br><span class="line">  random_device rd;</span><br><span class="line">  <span class="function">default_random_engine <span class="title">eng</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distr</span><span class="params">(<span class="number">0</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成一个随机数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="built_in">set</span>(nums);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.t随机分布</span></span><br><span class="line">  <span class="comment">// 生成测试数组</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; test_list;</span><br><span class="line">  <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">  distr = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, sum);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    test_list.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用两种方法分别测试</span></span><br><span class="line">  <span class="type">clock_t</span> start, end;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_binary_search</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using binary search: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_double</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using times increase: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. t比较小</span></span><br><span class="line">  <span class="comment">// 生成测试数组</span></span><br><span class="line">  test_list.<span class="built_in">clear</span>();</span><br><span class="line">  distr = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, sum / <span class="number">10000</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    test_list.<span class="built_in">push_back</span>(<span class="built_in">distr</span>(eng));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用两种方法分别测试</span></span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_binary_search</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using binary search: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">  start = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t : test_list) &#123;</span><br><span class="line">    s.<span class="built_in">query_double</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;time of using times increase: &quot;</span></span><br><span class="line">       &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// t随机分布</span><br><span class="line">time of using binary search: 0.019</span><br><span class="line">time of using times increase: 0.02</span><br><span class="line">// t值比较小</span><br><span class="line">time of using binary search: 0.011</span><br><span class="line">time of using times increase: 0.006</span><br></pre></td></tr></table></figure><p>由此可见，一般情况下，二分方法和倍增的时间复杂度接近；t比较小的情况小，倍增方法要优于二分查找。</p><h3 id="Genius-ACM"><a href="#Genius-ACM" class="headerlink" title="Genius ACM"></a>Genius ACM</h3><p><a href="https://www.acwing.com/problem/content/description/111/">原题</a></p><blockquote><p>给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:</p><p>从集合 S 中取出 M 对数（即 2*M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M对，则取到不能取为止），使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。</p><p>现在给定一个长度为 N 的数列 A 以及一个整数 T。</p><p>我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。</p><p>求最少需要分成几段。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 K，代表有 K 组测试数据。</p><p>对于每组测试数据，第一行包含三个整数 N,M,T。</p><p>第二行包含 N 个整数，表示数列A1,A2…AN。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组测试数据，输出其答案，每个答案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤12,<br>1≤N,M≤500000,<br>0≤T≤10^18,<br>0≤Ai≤2^20</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 1 49</span><br><span class="line">8 2 1 7 9</span><br><span class="line">5 1 64</span><br><span class="line">8 2 1 7 9</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></blockquote><p>首先，我们需要一个结论：求集合S的检验值，就是将S排序，每次取最大值和最小值构成一对，这样求出来的“每对数的差的平方和”最大。可以用只有四个数的情况证明：</p><script type="math/tex; mode=display">\begin{aligned}假&设A<B<C<D，\\&[(D-A)^2+(C-B)^2]-[(D-B)^2+(C-A)^2]\\=&-2AD-2BC+2BD+2AC\\=&2B(D-C)-2A(D-C)\\=&2(B-A)(D-C) >0\\故&(D-A)^2+(C-B)^2>(D-B)^2+(C-A)^2\end{aligned}</script><p>更多数也是类似的，就不证明了。因此，可以用贪心，让每一段尽量长，就能得到最少得分段数了。于是，我们要解决的问题变为，确定左端点L之后，求最大的右端点R，使得A[l]~A[r]的校验值不超过t。当然可以使用二分思想，每次取一个可能范围的中间点mid，对A[l]~A[mid]排序，然后求校验值，与t比较后缩小范围。然而，与第一个例子类似，右端点r应该在比较靠近左端点l的位置，使用倍增可能要优于二分。故可以采用与上例类似的算法：</p><ol><li>初始化 p = 1，R = L；</li><li>求出 [L, R + p] 这一段区间的“校验值”,若“校验值” ≤ T，则 R += p,p *= 2，否则 p /= 2；</li><li>重复上一步，直到 p 的值变为0，此时 R 即为所求。</li></ol><p>下面是代码，其中有一个优化：每次求校验值不需要对整个数组排序，只需要对新增部分长度排序，然后与前面已排序部分合并即可。这样数组的每一段都只经过一次排序，时间复杂度为O(N*logN)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> A[<span class="number">500000</span>];</span><br><span class="line"><span class="type">int</span> B[<span class="number">500000</span>];</span><br><span class="line"><span class="type">int</span> C[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = begin, r = mid, pt = begin;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; mid &amp;&amp; r &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (B[l] &lt; B[r]) &#123;</span><br><span class="line">      C[pt++] = B[l++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      C[pt++] = B[r++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; mid) &#123;</span><br><span class="line">    C[pt++] = B[l++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; end) &#123;</span><br><span class="line">    C[pt++] = B[r++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数组B[mid, end)排序，后将B[begin, mid)与B[mid, end)归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">single_sort</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(B + mid, B + end);</span><br><span class="line">  <span class="built_in">merge</span>(begin, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算排好序后的数组C在[begin, end)范围的校验值</span></span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = begin, r = end - <span class="number">1</span>;</span><br><span class="line">  LL ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r &amp;&amp; m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ret += ((LL)C[r] - C[l]) * ((LL)C[r] - C[l]);</span><br><span class="line">    m--, l++, r--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> begin, <span class="type">int</span> m, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, p = begin;</span><br><span class="line">  LL sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p + l &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt; p + l; i++) B[i] = A[i];</span><br><span class="line">      <span class="built_in">single_sort</span>(begin, p, p + l);</span><br><span class="line">      sum = <span class="built_in">cal</span>(begin, p + l, m);</span><br><span class="line">      <span class="keyword">if</span> (sum &lt;= t) &#123;</span><br><span class="line">        p += l;</span><br><span class="line">        l *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; p; i++) B[i] = C[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l /= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sum == <span class="number">0</span>) p = n;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, LL t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p &lt; n) &#123;</span><br><span class="line">    p = forward(n, p, m, t);</span><br><span class="line">    ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    LL t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">partition</span>(n, m, t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h3><p>ST算法也是倍增思想的一个应用，参考之前的文章：<a href="http://sprooc.github.io/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/">Sparse Table(稀疏表) | Sprooc</a></p><p>参考资料：</p><ol><li>算法竞赛进阶指南.李煜东.0x06节。</li><li><a href="https://www.acwing.com/solution/content/15458/">AcWing 109. 天才ACM - AcWing</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网计算-名词解释</title>
      <link href="/2024/01/05/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2024/01/05/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网计算-名词解释"><a href="#互联网计算-名词解释" class="headerlink" title="互联网计算-名词解释"></a>互联网计算-名词解释</h2><span id="more"></span><hr><div class="table-container"><table><thead><tr><th>英文简称</th><th>英文全称</th><th>中文</th><th>解释</th></tr></thead><tbody><tr><td>ABR</td><td>area border routers</td><td>区域边界路由器</td><td>在使用OSPF的网络中，拥有连接不同区域的接口的路由器，通常是Area 0 和其他区域。</td></tr><tr><td>Access links</td><td></td><td>接入链路</td><td>交换机上的链路，只属于一个VLAN</td></tr><tr><td>ACK</td><td>acknowledgement</td><td>确认字符</td><td>在有确认的传输中，接收方发送给发送方的一种控制字符，表示发来的数据与收到</td></tr><tr><td>ACL</td><td>access control list</td><td>访问控制列表</td><td>路由器或交换机接口的指令列表，控制端口进出数据包。</td></tr><tr><td>ad-hoc Network</td><td></td><td>自组网络</td><td>属于一次对话的各帧</td></tr><tr><td>Administrative  Distance</td><td>管理距离</td><td>⼀个0-255的值，提供路由可靠性的⼀个可选参数</td><td></td></tr><tr><td>ADSL</td><td>asymmetric digital subscriber line</td><td>非对称数字用户线</td><td>上行和下行宽带不对称，利用频分服用，用电话线提供宽带服务</td></tr><tr><td>AMI</td><td>alternate mark inversion</td><td>双极性传号交替反转码</td><td>n零电平表示“0”，正负电平的跃迁表示“1”，实现对“1”电平的交替反转。</td></tr><tr><td>AP</td><td>access point</td><td>接入点</td><td>允许无线设备（如笔记本电脑、智能手机、平板电脑等）通过Wi-Fi连接到有线局域网络</td></tr><tr><td>ARP</td><td>address resolution protocol</td><td>地址解析协议</td><td>根据IP地址查询MAC地址的协议。</td></tr><tr><td>ARQ</td><td>automatic repeat request</td><td>自动重传请求</td><td>重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</td></tr><tr><td>ASP</td><td>AppleTalk session protocol</td><td>AppleTalk会话协议</td><td></td></tr><tr><td>Asymmetric Switching</td><td></td><td>非对称交换</td><td>交换机不同端口宽带不同</td></tr><tr><td>ATM</td><td>Asynchronous transfer mode</td><td>异步传输模式</td><td>ATM是以信元为基础的一种分组交换和复用技术。</td></tr><tr><td>ATU</td><td>Access Termination Unit</td><td>接入端接单元</td><td>在用户端与数字通信网络之间充当接入终端的角色。</td></tr><tr><td>ATU-C</td><td>Access Termination Unit-Central Office</td><td>端局接入端接单元</td><td>电话端局所用的ADSL调制解</td></tr><tr><td>ATU-R</td><td>Access Termination Unit-Remote</td><td>远端接入端接单元</td><td>用户端所用的ADSL调制解</td></tr><tr><td>axial</td><td></td><td></td><td></td></tr><tr><td>backbone</td><td></td><td>主干</td><td>用于vlan间通信</td></tr><tr><td>bandwidth</td><td></td><td>带宽</td><td></td></tr><tr><td>baud</td><td></td><td>波特率</td><td>信号每秒变化的次数</td></tr><tr><td>BDR</td><td>backup designated router</td><td>备份指定路由器</td><td>对DR的备份，DR失效时，BDR成为DR</td></tr><tr><td>BID</td><td>bridge ID</td><td>网桥ID</td><td>两字节的优先级加上6字节的MAC地址，用于选举root bridge 和root port</td></tr><tr><td>bit</td><td></td><td>比特率</td><td>每秒传送的二进制位数</td></tr><tr><td>BOOTP</td><td>bootrap protocol</td><td>引导程序协议</td><td>向BOOTP服务器请求分配IP</td></tr><tr><td>BPDU</td><td>bridge protocol data unit</td><td>桥接数据单元</td><td>STP帧，用于确定生成树拓扑</td></tr><tr><td>BRI</td><td>basic rate interface</td><td>基本速率接口</td><td>2B + 1D</td></tr><tr><td>bridge</td><td></td><td>网桥</td><td>对收到的帧根据其MAC 帧的目的地址进行转发和过滤</td></tr><tr><td>broadcast</td><td></td><td>广播</td><td>一个数据报从源站发送到网络上所有节点</td></tr><tr><td>BS</td><td>basic station</td><td>基站</td><td>用于提供与移动设备（如手机）之间的通信。</td></tr><tr><td>BSS</td><td>basic service set</td><td>基本服务集</td><td>一组互相有联系的无线设备</td></tr><tr><td>CDM</td><td>code division multiplexing</td><td>码分复用</td><td>靠不同编码来区分各路原始信号源的复用方式</td></tr><tr><td>CDMA</td><td>code division multiplex access</td><td>码分多址</td><td></td></tr><tr><td>CHAP</td><td>challenge handshake authentication protocol</td><td>挑战握手认证协议</td><td>链路建⽴阶段结 束之后，认证者向对端点发送“challenge”消息;对端点⽤经过单向哈希函数 计算出来的值做应答;  认证者根据它⾃⼰计算的哈希值来检查应答，如果值匹配，认证得到承认， 否则连接应该终⽌; 经过⼀定的随机间隔，认证者发送⼀个新 challenge  给端点，重复步骤 1- 3</td></tr><tr><td>CIDR</td><td>classless inter domain routing</td><td>无类域间路由</td><td>使用IP地址和子网掩码来确定网络范围，消除了ABC类地址的划分</td></tr><tr><td>collision domain</td><td></td><td>冲突域</td><td>局域网（LAN）上，当两个或多个设备同时发送数据帧（数据包）时，可能发生冲突的区域。</td></tr><tr><td>CPE</td><td>Customer Premises Equipment</td><td>用户驻地设备</td><td>位于用户驻地的设备和内部布线，用户驻地设备连接到运营商的电信信道。用户可以从服务提供商处购买 CPE 或租用 CPE。这里的用户是指从服务提供商或运营商订购  WAN 服务的公司。</td></tr><tr><td>CRC</td><td>cyclic redundancy check</td><td>循环冗余校验</td><td>选取一个合适的除数，要进行校验的数据是被除数，然后做模2除法，得到的余数就是CRC校验值。</td></tr><tr><td>crossover cable</td><td></td><td>交叉线</td><td>一端T568A一端T568B，连接同层设备（思科认为PC网卡是第三层，所以PC连路由器用交叉线）</td></tr><tr><td>CSMA/CA</td><td>carrier sense multiple access with collision avoid</td><td>带碰撞避免的载波监听多路复用</td><td>发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围 的站点监听到该帧，从⽽在⼀定时间内避免数据发送。⽤于⽆线局域⽹⽐较多</td></tr><tr><td>CSMA/CD</td><td>carrier sense multiple access with collision detection</td><td>带碰撞检测的载波监听多路复用</td><td>先监听线路，如果发现空闲，则发送数据，否则等待。 在传输过程中，仍然监听线  路，如果冲突检测到，⽴即停⽌传输，则先⼴播拥塞信号，退避算法决定哪个设备再次接⼊介 质。⽤于以太⽹⽐较多</td></tr><tr><td>CSU/DSU</td><td>channel service unit/data service unit</td><td>信道服务单元/数据服务单元</td><td></td></tr><tr><td>Cut-through</td><td></td><td>直通交换</td><td>不校验就转发</td></tr><tr><td>DBD</td><td>Database Description</td><td>数据库描述</td><td>OSPF中，描述本地LSDB中每一条LSA的摘要信息。</td></tr><tr><td>DCE</td><td>Data Circuit-Terminating Equipment</td><td>数据电路终端设备</td><td>DCE 由将数据放入本地环路的设备组成。DCE 主要提供一个接口，用于将用户连接到 WAN 网云上的通信链路。</td></tr><tr><td>default gateway</td><td></td><td>默认网关</td><td>指在一个子网内，用于转发数据包到其他网络或子网的设备。</td></tr><tr><td>DHCP</td><td>dynamic host configuration protocol</td><td>动态主机配置协议</td><td>是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</td></tr><tr><td>DIFS</td><td>distributed inter-frame space</td><td>分布协调功能帧间间隔</td><td>CSMA/CA中，如果在DIFS时间间隔内信道保持空闲，设备可以发送数据。</td></tr><tr><td>DMT</td><td>Discrete Multi-Tone</td><td>离散多音调调制技术</td><td>实现ADSL的技术，DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25  个子信道用于上行信道，而 249 个子信道用于下行信道。</td></tr><tr><td>DNS</td><td>domain name system</td><td>域名系统</td><td>域名系统（DNS）是网络上的一项服务，负责管理域名并响应来自客户端的请求，将域名翻译成相应的IP地址。</td></tr><tr><td>Domain Name</td><td></td><td>域名</td><td>由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称</td></tr><tr><td>DR</td><td>designated router</td><td>指定路由器</td><td>在使用OSPF的多路复用网络中，被选举作为代表网络内所有路由器的路由器。</td></tr><tr><td>DS</td><td>distribution system</td><td>分配系统</td><td>一组相互连接的无线局域网，它们通过一个或多个接入点（Access Point，AP）连接到有线局域网（Local Area  Network，LAN）或其他网络。</td></tr><tr><td>DSLAM</td><td>Digital Subscriber Line Access Multiplexer</td><td>数字用户线接入复用器</td><td>DSLAM是各种DSL系统的局端设备，属于最后一公里接入设备（the last  mile），其功能是接纳所有的DSL线路，汇聚流量，相当于一个二层交换机。其在ADSL系统中的位置。</td></tr><tr><td>DSSS</td><td>Direct Sequence Spread Spectrum</td><td>直接序列扩频</td><td>直接序列扩频通过利用高速率的扩频序列在发射端扩展信号的频谱，而在接收端用相同的扩频码序列进行解扩，把展开的扩频信号还原成原来的信号。</td></tr><tr><td>DTE</td><td>Data Terminal Equipment</td><td>数据终端设备</td><td>传送来自客户网络或主机计算机的数据以便在 WAN 上传输的客户设备。DTE 通过 DCE 连接到本地环路</td></tr><tr><td>DVP</td><td>distance vector protocol</td><td>距离向量协议</td><td>通过计算⽬标路由器与源路由器之间的距离 ⽮量和来选择最佳路径，有频繁和周期性的更新，每次更新都将整张路由表发给周围的路由器，</td></tr><tr><td>dynamic routes</td><td></td><td>动态路由</td><td>使用路由协议动态更新路由信息。</td></tr><tr><td>Dynamic VLAN</td><td></td><td>动态VLAN</td><td>当新的站点连接到一个端口时，交换机通过查表来动态设置端口所属的VLAN</td></tr><tr><td>EGP</td><td>exterior gateway protocol</td><td>外部网关协议</td><td>用于在不同自治系统（AS，Autonomous System）之间进行路由选择的协议。</td></tr><tr><td>EIGRP</td><td>enhance interior gateway route protocol</td><td>增强的内部网关路由协议</td><td>Cisco的LSP和DVP的混合协议</td></tr><tr><td>ESS</td><td>extended service set</td><td>扩展服务集</td><td>由多个使用相同SSID的BSS组成，目的是扩展无线网络覆盖范围。</td></tr><tr><td>Fast  Forward Switching</td><td>快速转发交换</td><td>只检查帧的目的MAC，然后立即转发此帧。</td><td></td></tr><tr><td>FCS</td><td>frame check sequence</td><td>帧校验序列</td><td>用于对帧进行校验的字段。</td></tr><tr><td>FDDI</td><td>fiber distributed data inteface</td><td>光纤分布式数据接口</td><td>一种局域网数据传输标准，以光纤为主要介质。</td></tr><tr><td>FDM</td><td>frequency division multiplexing</td><td>频分服用</td><td>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</td></tr><tr><td>Flow control</td><td></td><td>流控制</td><td>一种保证不在缓冲区已满的情况下发送端继续传输数据的机制。</td></tr><tr><td>Fragment Free</td><td></td><td>免碎片</td><td>只读取前64个字节来检测错误，然后转发</td></tr><tr><td>Frame Filtering</td><td></td><td>帧过滤</td><td></td></tr><tr><td>Frame Relay</td><td></td><td>帧中继</td><td>帧中继（Frame  Relay）是一种在计算机网络中用于在广域网（WAN）上进行数据传输的数据链路层协议。它提供了一种简单而高效的方法，允许在不同地理位置的网络设备之间进行数据通信。</td></tr><tr><td>Frame Tagging</td><td></td><td>帧标记</td><td></td></tr><tr><td>FTP</td><td>file transfer protocol</td><td>文件传输协议</td><td>用于在网络上进行文件传输的一套标准协议，它工作在  OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程，  保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。</td></tr><tr><td>FTTx</td><td>Fiber to the x</td><td>光纤到x</td><td>HTTH,光纤到家 HTTB光纤到大楼, HTTC光纤到路边</td></tr><tr><td>full-duplex  transmission</td><td></td><td>全双工</td><td>信号可以同时双向传输</td></tr><tr><td>GIF</td><td>graphic interchange format</td><td>图形交换格式</td><td>一种公用的图像文件格式标准</td></tr><tr><td>half-duplex  transmission</td><td></td><td>半双工</td><td>信号双向传输，但不能同时传输</td></tr><tr><td>HDLC</td><td>high-level data link control</td><td>高级数据链路控制</td><td>在同步⽹上传输数据、⾯向⽐特的数 据链路层协议。思科路由器上的默认WAN接⼝封装协议。</td></tr><tr><td>HDSL</td><td>High Speed DSL</td><td>高速数字用户线</td><td></td></tr><tr><td>HFC</td><td>Hybird Fiber Coax</td><td>光线同轴混合网</td><td>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</td></tr><tr><td>hold-dowm timer</td><td></td><td>挂起计时器</td><td>路由器需要将某些可能导致路由环路的网络状态的变化保留一段时间，在这段时间内，路由器将视情况对这些网络状态的变化所产生的路由信息进行更改。</td></tr><tr><td>HTML</td><td>hyper-text mark language</td><td>超文本标记语言</td><td>一种用于创建网页的标准标记语言。</td></tr><tr><td>HTTP</td><td>hyper-text transfer protocol</td><td>超文本传输协议</td><td>客户端和服务端进行数据传输的一种规则</td></tr><tr><td>HTTPD</td><td>HTTP daemon</td><td>超文本传输协议守护程序</td><td>在万维网服务器等待 HTTP 请求的进程</td></tr><tr><td>hub</td><td></td><td>集线器</td><td>对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</td></tr><tr><td>Hybird Protocol</td><td></td><td>混合协议</td><td>DVP和LSP的混合协议。</td></tr><tr><td>ICMP</td><td>Internet control message protocol</td><td>网际控制报文协议</td><td>是为了提⾼IP数据报交付成功的机会，允许主机或路由器报告差错情况和提供有关异常情况报告的协议，运⾏在IP层</td></tr><tr><td>IDSL</td><td>ISDN DSL</td><td>ISDN数字用户线</td><td></td></tr><tr><td>IEEE</td><td>institute of electrical and electronic engineers</td><td>电气和电子工程师协会</td><td></td></tr><tr><td>IGP</td><td>interior gateway protocol</td><td>内部网关协议</td><td>用于在单一自治系统（AS，Autonomous System）内部进行路由选择的协议。</td></tr><tr><td>IGRP</td><td>Interior gateway routing protocol</td><td>内部网关路由协议</td><td>思科的一种DVP</td></tr><tr><td>infrared</td><td></td><td>红外线</td><td></td></tr><tr><td>ISDN</td><td>integrated service digital network</td><td>混合业务数字网络</td><td>一种电路交换技术，能够让 PSTN 本地环路传输数字信号，从而实现更高容量的交换连接。</td></tr><tr><td>IS-IS</td><td>intermediate-system to intermediate-system</td><td>中间系统到中间系统</td><td>LSP和DVP的混合协议</td></tr><tr><td>ISL</td><td>Inter-Switch Link</td><td>交换机间链路</td><td>思科专利，封装帧，加上VLAN信息</td></tr><tr><td>ISO</td><td></td><td></td><td></td></tr><tr><td>ISP</td><td>internet service provider</td><td>互联网服务提供商</td><td>向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。</td></tr><tr><td>JPEG</td><td>joint photographic experts group</td><td>联合图像专家组</td><td>一种针对照片影像而广泛使用的有损压缩标准方法</td></tr><tr><td>LAPB</td><td>Link Access Procedure Balanced</td><td>链路接入规程，平衡式</td><td>链路访问过程平衡（LAPB）是数据链路层协议，负责管理在 X.25 中 DTE 设备与 DCE 设备之间的通信和数据包帧的组织过程。</td></tr><tr><td>LAPD</td><td>Link Access Procedure On the D-Channel</td><td>D信道链路接入规程</td><td>一种面向连接、可靠的数据链路层协议，通常用于数字通信网络，特别是在 ISDN（Integrated Services Digital  Network）和 X.25 等环境中。它负责在 D  通道上建立、维护和释放连接，并处理信令、控制信息，以及错误检测，以确保在用户设备和网络交换设备之间的数据传输的可靠性和有序性。</td></tr><tr><td>laser</td><td></td><td>激光</td><td></td></tr><tr><td>late collision</td><td></td><td>迟冲突</td><td>64byte帧发送后发生的错冲突，它将影响网络性能。在一个健康的网络中极少发生此类冲突。</td></tr><tr><td>LCP</td><td>link control protocol</td><td>链路控制协议</td><td>在PPP协议中，用于建立连接，配置连接选项，测试链路质量</td></tr><tr><td>line coding</td><td></td><td>线路编码</td><td>把二进制信息转化为可以在物理介质上传输的形式。</td></tr><tr><td>link</td><td></td><td>链路</td><td>连接两个网络设备的物理连接</td></tr><tr><td>LLC</td><td>logical link control</td><td>逻辑链路控制</td><td>与网络层交互，标识不同的协议类型并封装它们</td></tr><tr><td>LSA</td><td>link-state advertisements</td><td>链路状态通告</td><td>装载和传输链路状态信息的报文</td></tr><tr><td>LSAck</td><td>Link-State Acknowledgement</td><td>链路状态确认</td><td>OSPF中，对收到的LSA进行确认</td></tr><tr><td>LSP</td><td>link state protocol</td><td>链路状态协议</td><td>每个路由器都了解整个⽹络的拓扑结构，利⽤算法 计算两个路由之间的最短路径，更新由事件触发，每次更新都只向周围的路由器传递路由表的更  新信息，包括OSPF等</td></tr><tr><td>LSR</td><td>Link-State Request</td><td>链路状态请求</td><td>OSPF中，两个路由器交换DBD后，发送LSR请求所有LSA</td></tr><tr><td>LSU</td><td>Link-State Update</td><td>链路状态更新</td><td>OSPF中，向对方发送所需要的LSA</td></tr><tr><td>MAC</td><td>madia access control</td><td>介质访问控制</td><td>与物理层交互，定义如何在物理层上传输帧</td></tr><tr><td>MIME</td><td>Multipurpose Internet Mail Extension</td><td>通用互联网邮件扩充</td><td>MIME 在其邮件首部中说明了邮件的数据类型（如文本、声音、图像、视像等）。在MIME 邮件中可同时传送多种类型的数据。</td></tr><tr><td>Modems</td><td></td><td>调制解调器</td><td>负责模拟信号和数字信号之间的转化</td></tr><tr><td>MSL</td><td>max segment lifetime</td><td>最长报文段生存时间</td><td></td></tr><tr><td>MSS</td><td>maximun segment size</td><td>最长报文段长度</td><td>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</td></tr><tr><td>MTU</td><td>maximum transmission unit</td><td>最大传送单元</td><td>指网络能够传输的最大数据包大小，以字节为单位。一般由数据链路层规定。（以太网1500）</td></tr><tr><td>multicast</td><td></td><td>组播</td><td>一个数据报从源站发送到特定的一组目的站</td></tr><tr><td>NAT</td><td>network address translation</td><td>网络地址转换</td><td>是⼀种把内部私有⽹络地址（IP地址）翻译成外部⽹络IP地址的技术</td></tr><tr><td>native VLAN</td><td></td><td>本征VLAN</td><td>用于未标记帧的默认VLAN</td></tr><tr><td>NAV</td><td>network allocation vector</td><td>网络分配向量</td><td>CSMA/CA中，指出了信道处于忙状态的持续时间。</td></tr><tr><td>NCP</td><td>network control protocol</td><td>网络控制协议</td><td>PPP协议中，选择和配置第三层协议</td></tr><tr><td>NFS</td><td>netword file system</td><td>网络文件系统</td><td>一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样</td></tr><tr><td>NIC</td><td>netword interface card</td><td>网卡</td><td>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。由于其拥有MAC地址，因此属于OSI模型的第1层和2层之间。它使得用户可以通过电缆或无线相互连接。</td></tr><tr><td>NRZ</td><td>non return to zero</td><td>不归零制码</td><td></td></tr><tr><td>NVRAM</td><td>non-volatile RAM</td><td>非易失随机存取存储器</td><td></td></tr><tr><td>OC</td><td>Optical Carrier</td><td>光载波</td><td></td></tr><tr><td>ODN</td><td>Optical Distribution Node</td><td>光纤分配节点</td><td>HFC网中，在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</td></tr><tr><td>OSI reference model</td><td>open system interconnection reference model</td><td>开放系统互联参考模型</td><td>国际标准化组织（ISO）提出的网络模型，有助于网络构建者实现可以相互通信和协同工作的网络。描述了信息或数据如何从一个计算机通过网络传输到另一台计算机的过程，采用分层通信的方法，每个层次执行特定任务。</td></tr><tr><td>OSPF</td><td>open shortest path first</td><td>开放最短路径优先</td><td>LSP的一种实现，每个路由器维护一个描述整个自治系统链路状态的数据库， 通过最短路径算法求出最短路径树，从而决定最优路由。</td></tr><tr><td>OUI</td><td>organizational unique identifier</td><td>组织唯一标识符</td><td>生产局域网适配器的厂家都必须向IEEE 购买由这三个字节构成的这个号，用于标识其生产商</td></tr><tr><td>PAP</td><td>password authentication protocol</td><td>口令鉴别协议</td><td>远程节点不停的在链路上反复发送⽤ 户名/密码，直到验证通过或者连接终⽌。不健壮的身份认证协议，使⽤明⽂发送密码。连接建 ⽴前只有⼀次认证</td></tr><tr><td>PAT</td><td>port address translation</td><td>端口地址转换</td><td>是对⽹络地址转换（NAT）的扩展，它允许局域⽹（LAN）上的多个设备映射到⼀个单⼀的公共IP地址的不同端口。</td></tr><tr><td>PDU</td><td>protocol data unit</td><td>协议数据单元</td><td>对等层次之间传递的数据单位</td></tr><tr><td>PID</td><td>Port ID</td><td>端口ID</td><td></td></tr><tr><td>ping</td><td>packet internet groper</td><td></td><td>使用ICMP的会送请求和应答报文来测试两个主机之间的联通性的应用。</td></tr><tr><td>POP</td><td>post office protool</td><td>邮局协议</td><td>用于支持使用客户端远程管理在服务器上的电子邮件</td></tr><tr><td>POST</td><td>Power On Self Test</td><td>开机自检软件</td><td>储存在路由器的ROM，开机时运行，用于检查硬件。</td></tr><tr><td>PPP</td><td>point to point protocol</td><td>点对点协议</td><td>通过拨号或专线⽅式在两个⽹络节点之间建⽴连 接、发送数据。提供对多种⽹络层协议的⽀持。</td></tr><tr><td>preamble</td><td></td><td>前同步码</td><td>以太网帧前用于实现位同步的8个字节同步码，交替的1和0</td></tr><tr><td>PRI</td><td>primary rate interface</td><td>主速率接口</td><td>T1:: 23B + D; E1: 30B + D</td></tr><tr><td>Proxy ARP</td><td></td><td>代理ARP</td><td></td></tr><tr><td>PS</td><td>POTS Splitter</td><td>电话分离器</td><td></td></tr><tr><td>PSTN</td><td>Public Switch Telephone Network</td><td>公共交换电话网</td><td>日常生活中的电话网</td></tr><tr><td>PVC</td><td>Permanent Virtual Circuits</td><td>永久虚电路</td><td>信双方的电路在用户看来是永久连接的虚电路。</td></tr><tr><td>radio</td><td></td><td>无线电</td><td></td></tr><tr><td>RADSL</td><td>Rate Adaptive DSL</td><td>速率自适应DSL</td><td>ADSL 的一个子集，可自动调节线路速率</td></tr><tr><td>RAM</td><td>random access memory</td><td>随机存取存储器</td><td></td></tr><tr><td>RARP</td><td>reverse address resolution protocol</td><td>逆向地址解析协议</td><td>ARP为IP到MAC的转换，而RARP为MAC到IP的转换，向RARP服务器请求分配IP。</td></tr><tr><td>repeater</td><td></td><td>中继器</td><td>适用于完全相同的两个网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。  中继器是对信号进行再生和还原的网络设备：OSI模型的物理层设备。</td></tr><tr><td>RIP</td><td>router information protocol</td><td>路由信息协议</td><td>一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。</td></tr><tr><td>rollover cable</td><td></td><td>反转线</td><td>控制台电缆，全部插脚相反，用于将工作台连接到路由器或交换机进行配置。</td></tr><tr><td>route aggregation</td><td></td><td>路由聚合</td><td>路由聚合（也叫汇总）是让路由选择协议能够用一个地址通告众多网络，旨在缩小路由器中路由选择表的规模，以节省内存，并缩短IP对路由选择表进行分析以找出前往远程网络的路径所需的时间。</td></tr><tr><td>Route poisoning</td><td></td><td>路由毒害</td><td>防止路由环路的一种技术，当路由器发现一个网络不可达，不是将路由条目删除，而是将距离设为无穷大，让其它路由器直到这一网络不可达。</td></tr><tr><td>router</td><td></td><td>路由器</td><td>工作在第三层的网络设备，对不同网络之间的数据报进行路径选择、分组交换</td></tr><tr><td>routing protocol</td><td></td><td>主动路由协议</td><td>主动路由协议确定被动路由协议到达目的地的路径。</td></tr><tr><td>RPC</td><td>remote procedual call</td><td>远程过程调用</td><td>一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</td></tr><tr><td>RTS</td><td>request to send</td><td>请求传输帧</td><td>RTS  是一种用于协调无线网络中节点之间数据传输的信号。当一个节点准备发送数据时，它发送 RTS 信号以请求发送数据的权限。</td></tr><tr><td>RZ</td><td>return to zero</td><td>归零制码</td><td></td></tr><tr><td>SCP</td><td>DNA secion control protocol</td><td>会话控制协议</td><td></td></tr><tr><td>ScTP</td><td>screened twisted pair</td><td>网屏式双绞线</td><td></td></tr><tr><td>SDH</td><td>Synchronous Digital Hierarchy</td><td>同步数字系列</td><td>ITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH</td></tr><tr><td>SDSL</td><td>Single-line DSL</td><td>一对线的数字用户线</td><td></td></tr><tr><td>SIFS</td><td>short inter-frame space</td><td>短(Short)帧间间隔</td><td>分隔开属于一次对话的各帧</td></tr><tr><td>simplex transmission</td><td></td><td>单工</td><td>信号单向传输</td></tr><tr><td>SLIP</td><td>serial line internet protocol</td><td>串线网际协议</td><td>广域网第二层协议，一种在串行线路上对IP数据报进行封装的简单形式</td></tr><tr><td>SMTP</td><td>simple mail transfer protocol</td><td>简单邮件传输协议</td><td>可用在发送和接收电子邮件的信息</td></tr><tr><td>SNMP</td><td>simple network management protocol</td><td>简单网络管理协议</td><td>一种应用层协议，用于在不同网络设备之间交换管理信息。</td></tr><tr><td>socket</td><td></td><td>套接字</td><td>对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。包括IP地址和端口号</td></tr><tr><td>SONET</td><td>Synchronous Optical Network</td><td>同步光纤网</td><td>美国定义的数字传输标准，各级时钟都来自一个非常精确的主时钟</td></tr><tr><td>Source routing Bridge</td><td></td><td>源路由网桥</td><td>在发送帧时将详细的路由信息放在帧的首部中</td></tr><tr><td>SPF</td><td>shortest path first</td><td>最短路径优先</td><td></td></tr><tr><td>split horizen</td><td></td><td>水平分割</td><td>解决路由环路的方法之一，路由器从某个端口接收到的更新信息不再从这个端口发出去。</td></tr><tr><td>SQL</td><td>structrued query language</td><td>结构化查询语言</td><td>一种特定目的编程语言，用于管理关系数据库管理系统</td></tr><tr><td>SRA</td><td>Seamless Rate Adaption</td><td>无缝速率自适应技术</td><td>ADSL2使用的技术。在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</td></tr><tr><td>SSID</td><td>service set identifier</td><td>服务集标识符</td><td>对BSS的标识</td></tr><tr><td>static routes</td><td></td><td>静态路由</td><td>网络管理员手工输入路由信息。</td></tr><tr><td>Static VLAN</td><td></td><td>静态VLAN</td><td>直接指派端口所属的VLAN</td></tr><tr><td>STDM</td><td>static time division mulplexing</td><td>统计时分复用</td><td>但每一个STDM 帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM 帧中。对没有数据的缓存就跳过去。当一个帧的数据放满了，就发送出去。因此，  STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。</td></tr><tr><td>STM-1</td><td>Synchronous Transfer Mudule</td><td>同步传递模块</td><td>SDH 的基本速率为 155.52 Mb/s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即  STM-1，相当于 SONET 体系中的 OC-3 速率。</td></tr><tr><td>Store-and-forward</td><td></td><td>存储转发</td><td>交换机存下整个帧，校验CRC，然后再转发该帧</td></tr><tr><td>STP</td><td>shielded twisted pair</td><td>屏蔽双绞线</td><td></td></tr><tr><td>STP</td><td>spanning tree protocol</td><td>生成树协议</td><td>通过计算稳定的生成树网络拓扑来防止环路</td></tr><tr><td>straight cable</td><td></td><td>直通线</td><td>两端均是T568A或均是T568B，用于连接跨层设备。</td></tr><tr><td>STS-1</td><td>Synchronous Transport Signal</td><td>第一级同步传送信号</td><td>SONET 为光纤传输系统定义了同步传输的线路速率等级结构，其传输速率51.84Mbit/s 为基础，大约对应于T3/E3 的传输速率</td></tr><tr><td>stub network</td><td></td><td>末节网络</td><td>仅有一单个通路通过路由器连接到其他子网，或者仅有一个通路连接到其他网络。</td></tr><tr><td>SVCs</td><td>Switched Virtual Circuits</td><td>交换虚电路</td><td>按需建立和终止的WAN路径</td></tr><tr><td>switch</td><td></td><td>交换机</td><td></td></tr><tr><td>Symmetric Switching</td><td></td><td>对称交换</td><td></td></tr><tr><td>TCP</td><td>transmission control protocol</td><td>传输控制协议</td><td>是⼀种⾯向连接的、可靠的、基于字节 流的传输层通信协议</td></tr><tr><td>TDM</td><td>time division multiplexing</td><td>时分复用</td><td>将时间划分为一段段等长的时分复用（TDM ）帧，每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。</td></tr><tr><td>Telnet</td><td></td><td>远程登录服务</td><td></td></tr><tr><td>TFTP</td><td>trivial file transfer protocol</td><td>一般文件传输协议</td><td></td></tr><tr><td>throuput</td><td></td><td>吞吐量</td><td></td></tr><tr><td>TLD</td><td>top level domain</td><td>顶级域名</td><td>一级域名，最高层</td></tr><tr><td>Transparent Bridge</td><td></td><td>透明网桥</td><td></td></tr><tr><td>Trunk links</td><td></td><td>主干链路</td><td>支持多个VLAN通信，用于连接交换机或路由器</td></tr><tr><td>UDP</td><td>user datagram protocol</td><td>用户数据报协议</td><td>OSI参考模型中⼀种⽆连接的传输层协 议，提供⾯向事务的简单不可靠信息传送服务。</td></tr><tr><td>UIB</td><td>User Interface Box</td><td>用户接口盒</td><td>HFC网中，每个家庭要安装一个用户接口盒用户接口盒 要提供三种连接，即：使用同轴电缆连接到机顶盒(set-top  box)，然后再连接到用户的电视机；使用双绞线连接到用户的电话机；使用电缆调制解调器连接到用户的计算机。</td></tr><tr><td>unicast</td><td></td><td>单播</td><td>一个数据报从源站发送到单一目的站</td></tr><tr><td>URL</td><td>uniform resource locator</td><td>统一资源定位符</td><td>对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</td></tr><tr><td>UTP</td><td>unshielded twisted pair</td><td>无屏蔽双绞线</td><td></td></tr><tr><td>VDSL</td><td>Very high speed DSL</td><td>甚高速用户数字线</td><td></td></tr><tr><td>VLAN</td><td>virtual local area network</td><td>虚拟局域网</td><td>是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。用于划分逻辑子网。工作在第二层和第三层。可以分割广播域</td></tr><tr><td>VLSM</td><td>variable length subnet mask</td><td>可变长子网掩码</td><td>允许一个自治系统内有不同子网掩码的网络。</td></tr><tr><td>WAN</td><td>Wide Area Network</td><td>广域网</td><td>通过WAN服务提供商连接LAN的通信网络。</td></tr><tr><td>WDM</td><td>wavelength division mulplexing</td><td>波分复用</td><td>波分复用就是光的频分复用。</td></tr><tr><td>Wi-Fi</td><td>Wireless-Fidelity</td><td>无线保真度</td><td></td></tr><tr><td>xDSL</td><td>x Digital Subscriber Line</td><td></td><td>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20240104小记</title>
      <link href="/2024/01/04/20240104%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/01/04/20240104%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>现在是2024年1月4日，期末周第三天的晚上，下午考完了第一门必修课毛概，后天将要考计网。目前的精神状态一言难尽。</p><span id="more"></span><p>下午考完毛概走出考场，考的题目基本都会做，心情本应该是不错的，但莫名有种怅然若失的感觉。我一时间竟然不知道接下来应该干什么。回到宿舍，随意刷了一个小时的B站，然后下楼吃饭，又在学校里漫无目的地逛了半个钟。又回到宿舍，听了一个小时的歌，然后为了打发时间刷了两道力扣。然而，干什么都提不起劲，陷入了一种百无聊赖的状态，只想早点上床睡觉。按理说吧，现在应该抓紧时间复习，但感觉意义不大，该复习的基本都复习好了，完全找不到前几天拼了老命地复习那种感觉。回想起来，去年期末周我也差不多是这种状态。或许是我想太多？可能只是把自己逼太紧了。想一想这一个学期，尤其是学期末，基本没有出过校门，一直憋在宿舍学习。可能确实是我给自己太大压力了，以后还是多点放松，这种精神状态属实很糟糕。</p><hr><p>最近偶然染上了陶喆。最开始是因为他的抽象了解到的，但听了几首歌之后完全被他的才华所折服。听97年的《David Tao》，让我重新感受到当初第一次听《Jay》时所受到的震撼。看来我还是喜欢哪个年代的R&amp;B啊。</p><div align="center"><iframe src="//player.bilibili.com/player.html?aid=843880220&bvid=BV1654y1p7TN&cid=290595174&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="500" height="300"> </iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231224周记</title>
      <link href="/2023/12/24/20231224%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/24/20231224%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>期末复习的一周，时间真的很紧，所以这周的周记也会写得比较仓促。。。这周把计组和计网复习了一遍，接下来就剩数据结构与算法了。</p><span id="more"></span><p>刚刚复习的时候看到一个不错的算法，简单记录一下</p><blockquote><p>2010年全国考研统考题（13 分）设将 n(n&gt;1) 个整数存放到一维数组 R 中，试设计一个在时间和空间两<br>方面尽可能有效的算法，将 R 中保有的序列循环左移 P (0&lt; P&lt; n )个位置，即<br>将 R 中的数据由（ X0 X1 ……Xn-1 ）变换为( Xp Xp+1 ……Xn-1 X0 X1…Xp-1)。</p></blockquote><p>算法的思想是做两次翻转，先将（ X0 X1 ……Xp-1 ）翻转，把( Xp Xp+1 ……Xn-1)，最后把整个数组翻转。时间复杂度O(n)，无需额外空间。</p><h4 id="Leetcode第-377-场周赛"><a href="#Leetcode第-377-场周赛" class="headerlink" title="Leetcode第 377 场周赛"></a>Leetcode第 377 场周赛</h4><p>时隔两个星期终于有空打一次周赛了。还是ac三题，最后一题没时间做了，而且也不会。简单总结一下：</p><ul><li>第一题送分题</li><li>第二题超时了3次才ac。关键是没想起学过的一个点：先建堆后排序要比动态建堆快。</li><li>第三题Floyd算法，秒了，一次错误提交是因为有重边。</li><li>第四题，跳了。</li></ul><div align="center"><img src="92ec2449ac56d1c0d613070dec3c076.png" alt="92ec2449ac56d1c0d613070dec3c076" style="zoom:80%;" /><img src="bdc545fe0baafc30f6f58c013cef8b9.png" alt="bdc545fe0baafc30f6f58c013cef8b9" style="zoom:80%;" /></div>下一周是这个学期最后一周，也是今年的最后一周了，继续加油吧！最后，在人生中经历的最冷冬天里，放一首歌。<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=186331&auto=0&height=66"> </iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第17讲-输入输出</title>
      <link href="/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第17讲-输入输出"><a href="#第17讲-输入输出" class="headerlink" title="第17讲-输入输出"></a>第17讲-输入输出</h2><span id="more"></span><h3 id="外围设备"><a href="#外围设备" class="headerlink" title="外围设备"></a>外围设备</h3><ol><li>输入输出操作通过连接到输入输出模块的各种外部设备完成，这些外部设备提供了在外部环境和计算机系统之间的数据交换，通常被称为外围设备（peripheral device），简称为外设（peripheral）</li><li>类型<ul><li>人可读设备：适用于与计算机用户通信<ul><li>显示器，打印机</li></ul></li><li>机器可读设备：适用于与设备通信<ul><li>磁盘，磁带</li></ul></li><li>通信设备：适用于与远程设备通信</li></ul></li><li>不能把外设直接连接到系统总线上<ul><li>外设种类繁多，操作方法多种多样</li><li>外设的数据传送速度一般比存储器或处理器的慢得多</li><li>某些外设的数据传送速度比存储器或处理器要快</li><li>外设使用的数据格式和字长度通常与处理器不同</li></ul></li></ol><h3 id="I-O模块"><a href="#I-O模块" class="headerlink" title="I/O模块"></a>I/O模块</h3><ol><li><p>通过系统总线或中央交换器和存储器连接；通过专用数据线与一个或多个外设连接。<br>I/O模块是计算机内部系统和外设之间的桥梁</p> <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220222712734.png" alt="image-20231220222712734" style="zoom:80%;" /> </div></li><li><p>外围设备的接口</p><ul><li>输入输出模块的接口以控制、状态和数据信号的形式出现</li><li>与设备相关的控制逻辑控制外设的操作，以响应来自输入输出模块的命令</li><li>缓冲器用于缓存输入输出模块和外设之间传送的数据<ul><li>缓冲器的大小一般为8 位或16 位<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220223343684.png" alt="image-20231220223343684" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>I/O模块的功能</p><ul><li>处理器通信<ul><li>命令译码：输入输出模块接收来自处理器的命令，这些命令一般作为信号发送到控制总线</li><li>状态报告：由于外设速度很慢, 所以知道输入 输出模块的状态很重要</li><li>数据：数据是在处理器和输入输出模块之间经由数据总线来交换的</li><li>地址识别：输入输出模块必须能识别它所控制的每个外设的唯一地址</li></ul></li><li>设备通信<ul><li>通信内容包含命令、状态信息和数据</li></ul></li><li>数据缓冲<ul><li>外设的数据传送速度一般比存储器或处理器的慢得多</li><li>某些外设的数据传送速度比存储器或处理器要快</li></ul></li><li>控制和定时<ul><li>处理器会非预期的与一个或几个外设进行通信</li><li>一些内部资源，如主存和系统总线，是被共享的</li><li>例如：控制从外设到处理器的数据传送包括以下几个步骤<ul><li>处理器查询输入 输出模块以检验所连接设备的状态</li><li>输入输出模块返回设备状态</li><li>如果设备运转并准备就绪，则处理器通过向输入 输出模块发出一条命令 请求数据传送</li><li>经输入输出模块传送数据到处理器</li></ul></li></ul></li><li>检错<ul><li>检错并把差错信息报告给处理器</li><li>差错类型<ul><li>设备报告的机械和电路故障</li><li>传输过程中数据位的变化</li></ul></li></ul></li></ul></li><li><p>I/O模块的结构</p><div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220224938555.png" alt="image-20231220224938555" style="zoom:80%;" /></div></li><li><p>外部接口</p><ul><li>接口类型<ul><li>并行接口：多根线连接输入 输出模块和外设，同时传送多位数据</li><li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li></ul></li><li>由于并行接口要求每次同时传送，当传输速度和总线长度增加时，总线的时钟频率会受到限制</li></ul></li></ol><h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I/O操作技术"></a>I/O操作技术</h3><ol><li>分类<ul><li>编程式I/O：处理器通过执行程序来直接控制I/O 操作，当处理器发送一条命令到I/O 模块时，它必须等待，直到I/O 操作完成</li><li>中断驱动式I/O：处理器发送一条I/O 命令后，继续执行其他指令；并且当I/O 模块完成其工作后，才去中断处理器工作</li><li>直接存储器读取（Direct Memory Access，DMA）：I/O 模块与主存直接交换数据，而不需要处理器的干涉<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220225832049.png" alt="image-20231220225832049"  /></div></li></ul></li><li>编程式I/O<ul><li>当处理器在执行过程中遇到一条与I/O 操作有关的指令时，它通过发送指令到适当的I/O 模块来执行这条指令</li><li>I/O模块将执行所要求的动作，然后在I/O 状态寄存器中设置一些适当的位</li><li>I/O不会中断处理器，因此处理器需要周期性地检查I/O模块的状态，直到发现该操作完成<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220230340632.png"  /></div></li><li>I/O 命令：为了执行I/O 操作，处理器发送一个指定具体I/O 模块和外设的地址，并发送一条I/O 命令<ul><li>类型<ul><li>控制命令：激活外设并告诉它要做什么</li><li>测试命令：测试I/O 模块及其外设相关的各种状态条件</li><li>读命令：使I/O 模块从外设获得一个数据，把它存入内部缓冲区</li><li>写命令：使I/O 模块从数据总线获得一个数据，把它传入外设</li></ul></li></ul></li><li>I/O 指令<ul><li>I/O指令很容易映射为I/O 命令, 并且两者之间通常是简单的一一对应关系<ul><li>指令的形式取决于外设寻址的方式</li></ul></li><li>编址方式<ul><li>存储器映射式I/O：存储单元和I/O 设备有统一的地址空间，即每一个地址对应一个内存地址或一个IO地址。能使用大的指令系统，可进行更有效的编程。但是I/O设备会占用地址空间。</li><li>分离式I/O：让总线既有存储器的读线和写线，同时也有输入和输出命令线。命令线指定地址指向内存地址还是IO设备。IO和内存都可以使用全部地址空间。</li></ul></li></ul></li></ul></li><li>中断驱动式I/O<ul><li>处理器发送一个I/O 命令到模块，然后去处理其它有用的工作</li><li>当I/O 模块准备和处理器交换数据时，它中断处理器以请求服务</li><li>处理器执行数据传送，最后恢复它原先的处理工作 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231220231826050.png" alt="image-20231220231826050"  /> </div></li><li>从I/O 模块的角度来看<ul><li>I/O模块接收来自处理器的读命令</li><li>I/O模块从相关的外设中读入数据</li><li>一旦数据进入I/O 模块的数据寄存器后，该模块通过控制总线给处理器发送中断信号</li><li>I/O模块等待直到处理器请求该数据时为止</li><li>当处理器有数据请求时，I/O 模块把数据传送到数据总线上，并准备另一个I/O 操作</li></ul></li><li>从处理器的角度来看<ul><li>处理器发送一个读命令</li><li>处理器离开去做其它的事情，并在每个指令周期结束时检查中断</li><li>当来自I/O 模块的中断出现时，处理器保存当前程序的现场</li><li>处理器从I/O 模块读取数据字并保存到主存中</li><li>处理器恢复刚才正在运行的程序的现场，并继续运行原来的程序</li></ul></li><li>中断允许和中断禁止 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/18187e1805ee18e290626e3093abf5f.png" alt="18187e1805ee18e290626e3093abf5f" style="zoom:75%;" /> </div></li><li>响应优先级和处理优先级<ul><li>例子：假设中断系统中有4 个中断源，其响应优先级为L 1 &gt;L 2 &gt;L 3 &gt;L 44，处理优先级为L 1 &gt;L 4 &gt;L 3 &gt;L 2 。如果在主程序执行时同时发生L 1 、L 3 和L 4 中断，并且在处理L 3 中断的过程中发生L 2 中断，写出掩码字和所有中断服务程序的过程。 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/2e7130b7a0fa6de0477e56fcf4b3e74.png" alt="2e7130b7a0fa6de0477e56fcf4b3e74" style="zoom:75%;" /></div></li></ul></li><li>设备识别<ul><li>多条中断线：处理器仅仅挑选具有最高优先级的中断线<ul><li>即使有多条中断线可用，每条线上也需要采用其它三种技术中的一种</li></ul></li><li>软件轮询：模块的轮询次序就决定了模块的优先级<ul><li>轮询每一个I/O 模块来确定是哪个模块发生的中断</li></ul></li><li>菊花链：链接模块次序就决定了模块的优先级<ul><li>所有的I/O 模块共享一条中断请求线，中断应答线采用菊花链穿过这些中断模块</li></ul></li><li>独立请求：中断控制器决定<ul><li>特定的中断控制器用于解码和分析优先级</li></ul></li></ul></li></ul></li><li><p>直接存储器存取（DMA）</p><ul><li>前两种技术的不足<ul><li>I/O传送速度受处理器测试和服务设备速度的限制•</li><li>处理器负责管理I/O 传送，对于每一次I/O 传送，处理器必须执行很多指令</li></ul></li><li>直接存储器存取<ul><li>无需经过处理器即可直接访问内存的模块</li></ul></li><li>工作流程<ul><li>处理器通过发送以下信息向DMA 模块发出命令：读写、I/O 设备地址、内存中的起始位置、字数</li><li>处理器继续进行其他工作</li><li>DMA模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出，而无需经过处理器</li><li>当传输完成时，DMA 模块向处理器发送一个中断信号<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221100741641.png" alt="image-20231221100741641"  /></div></li></ul></li><li>三种DMA内存访问方式<ol><li>CPU 停止法。DMA传输时，由DMA控制器发一个停止信号给CPU，使CPU脱离总线，停止访问主存，直到DMA传送一块数据结束。<ul><li>优点：控制简单 </li><li>缺点：影响CPU，没有充分利用内存</li><li>适用：高速I/O 设备的块传输  <div align="center"> <img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/a84370ae45e6e88013ce7b4d8624272.png" alt="a84370ae45e6e88013ce7b4d8624272" style="zoom:70%;" />  </div></li></ul></li><li>周期窃取。DMA传输时，CPU让出一个总线事务周期，让DMA控制器挪用一个主存周期来访问主存，传送完一个数据后立即释放总线。<ul><li>I/O设备要求DMA传送时可能遇到两种情况：<br>(1)此时CPU不需要访内，如CPU正在执行乘法指令。由于乘法指令执行时间较长，此时I/O访内与CPU访内没有冲突，即I/O设备挪用一二个内存周期对CPU执行程序没有任何影响。<br>(2)I/O设备要求访内时CPU也要求访内，这就产生了访内冲突，在这种情况下I/O设备访内优先，因为I/O访内有时间要求，前一个I/O数据必须在下一个访问请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一二个内存周期，意味着CPU延缓了对指令的执行，或者更明确地说，在CPU执行访内指令的过程中插入DMA请求，挪用了一二个内存周期。 与停止CPU访内的DMA方法比较，周期挪用的方法既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采用的方法。但是I/O设备每一次周期挪用都有申请总线控制权、建立线控制权和归还总线控制权的过程，所以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2—5个内存周期(视逻辑线路的延迟而定)。因此，周期挪用的方法适用于I/O设备读写周期大于内存存储周期的情况。</li><li>优点：充分利用CPU 和内存，及时响应I/O 请求</li><li>缺点：DMA 每次都请求总线</li><li>适用：I/O 周期大于存储周期<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/8fb767730efd92b2472c33b63b133c6.png" alt="8fb767730efd92b2472c33b63b133c6" style="zoom:70%;" /></div></li></ul></li><li>交替分时访问。每个存储周期分成两个时间片，一个给CPU，另一个给DMA控制器，止痒子啊每个存储周期内，CPU和DMA控制器都可以访问存储器。<ul><li>假设CPU工作周期为1.2us，内存存取周期小于0.6us，那么一个CPU周期可分为C1和C2两个分周期，其中C1专供DMA控制器访内，C2专供CPU访内。<br>这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时制的。CPU和DMA控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控制寄存器。在C1周期中，如果DMA控制器有访内请求，可将地址、数据等信号送到总线上。在C2周期中，如CPU有访内请求，同样传送地址、数据等信号。事实上，对于总线，这是用C1，C2控制的一个多路<a href="https://baike.baidu.com/item/转换器">转换器</a>，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。<br>这种传送方式又称为“透明的DMA”方式，其来由是这种DMA传送对CPU来说，如同透明的玻璃一般，没有任何感觉或影响。在透明的DMA方式下工作，CPU既不停止主程序的运行，也不进入等待状态，是一种高效率的工作方式。当然，相应的硬件逻辑也就更加复杂。</li><li>优点：CPU 未停止或等待，DMA 不请求总线</li><li>缺点：CPU 周期大于存储周期</li><li>参考文章： <a href="https://baike.baidu.com/item/DMA方式/8666476#:~:text=DMA传送方式有,fly传送方式。">DMA方式_百度百科 (baidu.com)</a><div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/298786ce446f461744b3f5093827592.png" alt="298786ce446f461744b3f5093827592" style="zoom:80%;" /></div></li></ul></li></ol></li><li><p>DMA配置机制</p><ol><li>单总线分离DMA<ul><li>所有模块共享相同的系统总线</li><li>DMA模块使用编程式I/O，通过DMA 模块在存储器和I/O 模块之间交换数据</li><li>便宜但低效 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104048369.png" alt="image-20231221104048369" style="zoom:100%;" /> </div></li></ul></li><li><p>单总线集合的DMA I/O</p><ul><li>DMA逻辑实际上可能是I/O 模块的一部分，也可能是控制一个或多个I/O 模块的单独模块</li><li>减少总线周期数 <div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104155508.png" alt="image-20231221104155508" style="zoom:100%;" /> </div></li></ul></li><li>I/O 总线<ul><li>使用I/O 总线将I/O 模块连接到DMA 模块</li><li>多个I/O 模块共享DMADMA，且易于扩展<div align="center"><img src="https://sprooc.github.io/2023/12/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC17%E8%AE%B2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/image-20231221104241900.png" alt="image-20231221104241900" style="zoom:100%;" /></div></li></ul></li></ol></li></ul></li></ol><h3 id="I-O模块的演变"><a href="#I-O模块的演变" class="headerlink" title="I/O模块的演变"></a>I/O模块的演变</h3><ol><li>CPU直接控制外设</li><li>增加控制器或I/O 模块，CPU 使用编程式I/O，将CPU 与外围设备的细节分离</li><li>采用中断，CPU 无需花费时间等待外围设备就绪</li><li>I/O模块可通过DMA 直接存取存储器，无需CPU 负责存储器和I/O 模块之间的数据传递</li><li>I/O通道（I/O channel）：I/O 模块有自己的处理器，带有专门为I/O 操作定制的指令集<ul><li>CPU指示I/O 通道执行存储器中的I/O 指令，只有在执行完成后才会中断CPU</li></ul></li><li>I/O处理器（I/O processor）：I/O 模块有一个局部存储器，I/O 模块成为一个自治的计算机，常用于与交互式终端进行通信<ul><li>只需最少的CPU 参与即可控制大量I/O 设备</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第16讲-控制器</title>
      <link href="/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第16讲-控制器"><a href="#第16讲-控制器" class="headerlink" title="第16讲-控制器"></a>第16讲-控制器</h2><span id="more"></span><h3 id="处理器的结构"><a href="#处理器的结构" class="headerlink" title="处理器的结构"></a>处理器的结构</h3> <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/159d2db376dcaf898b1ffee596422de.png" alt="159d2db376dcaf898b1ffee596422de" style="zoom:80%;" /> </div><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ol><li>寄存器分类<ul><li>用户可见寄存器（user visible register）<ul><li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li></ul></li><li>控制和状态寄存器（control and status register）<ul><li>由控制器来控制CPU 的操作，并由拥有特权的操作系统程序来控制程序的执行</li><li>大多数控制和状态寄存器在大多数机器上是用户不可见的<ul><li>某些在控制或操作系统模式下执行的机器指令是用户可见的（如程序计数器，在x86上是用户可见的）</li></ul></li></ul></li><li>两者的区分并不严格</li></ul></li><li>用户可见寄存器<ul><li>通用寄存器（general purpose register，简称GPR）<ul><li>可被程序员指派各种用途</li></ul></li><li>数据寄存器（data register）<ul><li>仅可用于保持数据而不能用于操作数地址的计算</li></ul></li><li>地址寄存器（address register）<ul><li>可以是自身有某些通用性，或是专用于某种具体的寻址方式</li><li>例如：段指针、变址寄存器、栈指针</li></ul></li><li>条件码寄存器（condition codes register）/ 标志（flag）寄存器<ul><li>CPU硬件设置这些条件位作为操作的结果</li><li>至少是部分用户可见的，但程序员不可修改 </li></ul></li><li>设计出发点<ul><li>使用完全通用的寄存器还是规定各寄存器的用途<ul><li>影响指令集的设计</li></ul></li><li>寄存器数量<ul><li>太少的寄存器会导致更多的存储器访问</li><li>太多的寄存器又不能进一步减少存储器访问</li></ul></li><li>寄存器长度<ul><li>应能保存大多数数据类型的值</li><li>某些机器允许两个相邻的寄存器作为一个寄存器来保持两倍长度的值<br>保存和恢复</li></ul></li></ul></li><li>子程序调用会导致自动保存所有用户可见的寄存器，并在返回时自动取回<ul><li>这些保存和恢复是作为调用和返回指令执行功能的一部分，由CPU 完成</li><li>这允许各个子程序独立地使用用户可见寄存器</li></ul></li><li>子程序调用之外保存用户可见寄存器的相关内容是程序员的责任，需要在程序中为此编写专门的指令</li></ul></li><li>控制和状态寄存器<ul><li>程序计数器（Program counter，PC）<ul><li>存有待取指令的地址</li><li>通常在每次取指令之后，PC 的内容即被CPU 更改，转移或跳步指令也会修改PC 的内容，因此总指向将被执行的下一条指令</li></ul></li><li>指令寄存器（Instruction register，IR）<ul><li>存有最近取来的指令，在其中分析操作码和操作数</li></ul></li><li>存储器地址寄存器（Memory address register，MAR）<ul><li>直接与地址总线相连，存有存储器位置的地址</li></ul></li><li>存储器缓冲寄存器（Memory buffer register，MBR）<ul><li>直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字，用户可见寄存器再与MBR 交换数据</li><li>ALU可对MBR 和用户可见寄存器直接存取</li></ul></li><li>程序状态字（Program status word，PSW）<ul><li>一个或一组包含状态信息的寄存器，包含条件码加上其他状态信息</li><li>包含的字段或标志<ul><li>符号（Sign）：容纳算术运算结果的符号位</li><li>零（Zero）：当结果是0 时被置位</li><li>进位（Carry）：若操作导致最高位有向上的进位（加法）或借位（减法）时被置位，用于多字算数运算</li><li>等于（Equal）：若逻辑比较的结果相等，则置位</li><li>溢出（Overflow）：用于表示算术溢出</li><li>中断允许、禁止：用于允许或禁止中断</li><li>监管（Supervisor）：指出CPU 是执行在监管模式中还是在用户模式中</li></ul></li></ul></li><li>一个指向含有附加状态信息的<strong>存储器块的指针寄存器</strong></li><li>在使用向量式中断的机器中，可能提供有一个<strong>中断向量寄存</strong>器</li><li>若栈用于实现某些功能，需要有一个<strong>系统栈指针</strong></li><li>对于虚拟存储器系统，会有一个<strong>页表指针寄存器</strong></li><li>设计出发点<ul><li>对操作系统的支持<ul><li>某些类型的控制信息是专门为操作系统使用的</li><li>若CPU 设计者对将要使用的操作系统有基本的了解，则寄存器的组织可能在一定程度上为该操作系统定制</li></ul></li><li>控制信息在寄存器和存储器之间的分配<ul><li>一种普遍的做法是将存储器最前面（最低地址）的几百或几千个字用于控制目的</li><li>在成本和速度之间进行权衡</li></ul></li></ul></li></ul></li><li><p>X86体系结构：8086 的寄存器<br><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132120995.png" alt="image-20231220132120995" style="zoom:80%;" /></div></p><ul><li>数据寄存器<ul><li>均为16 位寄存器</li><li>均可分为2 个8 位寄存器使用</li><li>AX：存放乘除等指令的操作数</li><li>BX：存放存储单元的偏移地址</li><li>CX：存放计数值</li><li>DX：乘法运算产生的部分积、除法运算的部分被除数</li></ul></li><li>地址寄存器<ul><li>均为16 位寄存器</li><li>SP和BP：用于堆栈操作</li><li>SI和DI：用于串操作</li><li>均可以作为数据寄存器使用</li></ul></li></ul><p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132333535.png" alt="image-20231220132333535" style="zoom:80%;" /> </div></p><ul><li>段寄存器<ul><li>与其他寄存器联合生成物理地址</li><li>CS：代码段寄存器</li><li>DS：数据段寄存器</li><li>SS：堆栈段寄存器</li><li>ES：附加段寄存器</li></ul></li></ul><p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220132529694.png" alt="image-20231220132529694" style="zoom:80%;" /></div><br><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/a98267b33b6de82524a46699609271c.png" alt="a98267b33b6de82524a46699609271c" style="zoom:75%;" /> </div></p><ul><li>标志寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/879813df371ed8f7a172acb422b3377.png" alt="879813df371ed8f7a172acb422b3377" style="zoom:60%;" /></div></li><li>指令寄存器<ul><li>保存一个内存地址，指向当前需要取出的指令</li><li>当CPU 从内存中取出一个指令后，IP 会自增，指向下一个地址</li><li>程序员不能直接对IP 进行存取操作</li><li>转移指令、过程调用指令等会改变IP 中的内容</li><li>IP寄存器有16 位，但8086 的寻址范围是2<sup>20</sup></li></ul></li></ul></li><li>X86体系结构：IA-32 的寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/84cbee4bf7fca2f59ecf2c290687b9b.png" alt="84cbee4bf7fca2f59ecf2c290687b9b" style="zoom:75%;" /></div></li><li>X86体系结构：X86-64 的寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/1bf804873e92d9966e394d43dadfb6e.png" alt="1bf804873e92d9966e394d43dadfb6e" style="zoom:55%;" /></div></li></ol><h3 id="微操作（micro-operation）"><a href="#微操作（micro-operation）" class="headerlink" title="微操作（micro operation）"></a>微操作（micro operation）</h3><p>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令。<br>每个指令周期又可以看作是由几个更小的子周期组成，包括：取指、间址、执行、中断。<br>每个子周期由一系列涉及CPU 寄存器操作的更小步骤组成，这些步骤称为微操作。<br> <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220133317380.png" alt="image-20231220133317380" style="zoom:80%;" /> </div></p><ol><li>微操作分组的原则<ul><li>事件的流动顺序必须是恰当的<ul><li>例：MAR &lt;- (PC） 必须先于MBR &lt;- 内存，因为内存读操作要使用MAR 中的地址</li></ul></li><li>必须避免冲突<ul><li>例：MBR &lt;- 内存 和 IR &lt;- MBR 这两个微操作不应出现在同一时间单位里</li></ul></li><li>满足上述条件下，所用的时间单位尽可能少<ul><li>例：PC &lt;- (PC）+ I 不能放在一个单独的时间单位里</li></ul></li></ul></li><li><p>取指周期：出现在每个指令周期的开始，将指令从存储器中取出</p><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/8170971f8956fa2ab32ed61f66e85f1.png" alt="8170971f8956fa2ab32ed61f66e85f1" style="zoom:75%;" /></div></li><li><p>间址周期</p><ul><li>如果指令采用间接寻址，则在指令执行前有一个间址周期</li><li>完成间址周期后，IR 的状态与不使用间接寻址方式的状态是相同的，已经为执行周期准备就绪<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134053680.png" alt="image-20231220134053680" style="zoom:80%;" /></div></li></ul></li><li><p>执行周期</p><ul><li>对于不同的操作码，会出现不同的微操作序列<ul><li>例：加法指令 ADD R1， X<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134400626.png" alt="image-20231220134400626" style="zoom:50%;" /></div></li><li>例：“转移并保存地址”指令 BSA X<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134431005.png" alt="image-20231220134431005" style="zoom:50%;" /></div></li></ul></li></ul></li><li><p>中断周期</p><ul><li>在完成执行周期时，要确定是否有允许的中断产生。如果有，则出现一个中断周期。<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/c41b7b0c19abbce5b6ec9238e867795.png" alt="c41b7b0c19abbce5b6ec9238e867795" style="zoom:75%;" /></div></li></ul></li></ol><h3 id="指令周期代码（Instruction-Cycle-Code，ICC）"><a href="#指令周期代码（Instruction-Cycle-Code，ICC）" class="headerlink" title="指令周期代码（Instruction Cycle Code，ICC）"></a>指令周期代码（Instruction Cycle Code，ICC）</h3><p>取指、间址、中断周期各有一个微操作序列，执行周期则对于每个操作码有一个微操作序列<br>指令周期代码：假设一个2 位的ICC 寄存器，明确CPU 处于指令周期哪个阶段</p><ul><li>00：取指</li><li>01：间址</li><li>10：执行</li><li>11：中断<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220134822899.png" alt="image-20231220134822899" style="zoom:67%;" /></div></li></ul><h3 id="处理器的控制"><a href="#处理器的控制" class="headerlink" title="处理器的控制"></a>处理器的控制</h3><ol><li>控制CPU 的功能需求<ul><li>CPU的基本元素：ALU，寄存器组，内部数据通路，控制器，外部数据通路</li><li>CPU需要完成的四类微操作<ul><li>在寄存器之间传送数据</li><li>将数据由寄存器传送到外部接口（如系统总线）</li><li>将数据由外部接口传送到寄存器</li><li>将寄存器作为输入和输出，完成算术和逻辑运算</li></ul></li><li>控制器的两个基本任务<ul><li>定序（sequencing）：根据正被执行的程序，控制器使CPU 以正确的顺序通过一系列微操作</li><li>执行（execution）：控制器使每个微操作得以完成</li></ul></li></ul></li><li>控制器的输入<ul><li>指令寄存器：当前指令的寻址方式和操作码</li><li>标志：确定CPU 的状态和前一个ALU 操作的结果</li><li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li><li>来自控制总线的控制信号：向控制器提供控制信号<ul><li>例：中断请求</li></ul></li></ul></li><li><p>控制器的输出(所有的控制信号最终作为二进制输入量直接输入到各个逻辑门上)</p><ul><li>CPU内的控制信号：<ul><li>用于寄存器之间传送数据</li><li>用于启动特定的ALU 功能</li></ul></li><li>到控制总线的控制信号：<ul><li>到存储器的控制信号</li><li>到I/O 模块的控制信号<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220135810119.png" alt="image-20231220135810119" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>控制信号示例：取指周期</p><ul><li>传送PC 的内容到MAR<ul><li>打开C<sub>2</sub>：PC 传到MAR</li></ul></li><li>由存储器读一条指令装入MBR，并且递增PC<ul><li>打开C<sub>0</sub>：MAR 的内容送到地址总线上</li><li>存储器读控制信号C<sub>R</sub> 送到控制总线上</li><li>打开C<sub>5</sub>：数据总线上的内容存入MBR</li><li>控制信号对PC 内容加1（指令长度）并把结果存回PC</li></ul></li><li>传送MBR 的内容到IR<ul><li>打开C<sub>4</sub>：MBR 的内容送到IR<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140501106.png" alt="image-20231220140501106" style="zoom:80%;" /></div><div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140046430.png" alt="image-20231220140046430" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>控制器的最小特性</p><ul><li>它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出等），而不需要知道正被处理的数据或得到的实际结果具体是什么</li><li>它只是以少量的送到CPU 内的和送到系统总线上的控制信号来实现控制</li></ul></li><li>CPU内部总线<ul><li>ALU和寄存器都连接到CPU 内部总线上</li><li>为了数据在该内部总线和各寄存器之间传递，内部总线和寄存器之间有门和控制信号</li><li>控制线控制着数据和系统总线（外部）的交换以及ALU 的操作<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220140649190.png" alt="image-20231220140649190" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="控制器实现"><a href="#控制器实现" class="headerlink" title="控制器实现"></a>控制器实现</h3><ol><li>硬布线实现（hardwired implementation）：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号。<ol><li>控制器输入<ul><li>标志和控制总线信号<ul><li>每位都有特定的意义</li></ul></li><li>指令寄存器<ul><li>通过译码，使每一操作码有一个唯一的逻辑输入</li><li>译码器有n 个输入和2<sup>n</sup> 个输出<ul><li>控制器要考虑变长的操作码，译码器会更复杂些<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/c9fb6a931cd3ffe6bbc2b4378740242.png" alt="c9fb6a931cd3ffe6bbc2b4378740242" style="zoom:75%;" /></div></li></ul></li></ul></li><li>时钟<ul><li>在一个指令周期内，控制器要在不同时间单位发送不同的控制信号</li><li>使用一个定时器作为控制器的输入，并且控制器在指令周期（或子周期）结束时必须通知定时器以使其重新开始计数  <div align="center"> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220141820407.png" alt="image-20231220141820407" style="zoom:80%;" />  </div></li></ul></li></ul></li><li>控制器逻辑<ul><li>为每个输出的控制信号设计一个关于控制器输入的布尔表达式</li><li>定义两个新的控制信号P 和Q<ul><li>PQ=00：取指周期，</li><li>PQ=01：间址周期，</li><li>PQ=10：执行周期，</li><li>PQ=11：中断周期</li><li>示例：控制信号C5：使外部数据总线上的数据读入MBRC5<ul><li>在取指和间址周期的第二个时间单位（T<sub>2</sub>）有效<script type="math/tex; mode=display">C_{5} = \overline{P} \cdot \overline{Q} \cdot T_2 +  \overline{P} \cdot Q \cdot T_2</script></li><li>C5在执行周期也需要<script type="math/tex; mode=display">C_{5} = \overline{P} \cdot \overline{Q} \cdot T_2 +  \overline{P} \cdot Q \cdot T_2+P \cdot \overline{Q} \cdot (LDA + ADD+AND) \cdot T_2</script></li></ul></li></ul></li></ul></li></ol></li><li>微程序实现（microprogrammed implementation）：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号<ol><li>基本概念和思路<ul><li>微程序（固件）介于硬件与软件之间<ul><li>设计固件比设计硬件容易，但写固件程序比软件程序困难</li><li>微指令序列</li></ul></li><li>微指令：每行描述同一个时间内出现的一组微操作</li><li>基本思路<ul><li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）</li><li>构造一个控制字，每位代表一根控制线，这样每个微操作能用控制字中的不同的0 和1 的样式来表示</li><li>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</li><li>由于微操作序列不是固定的，把控制字放入一个存储器单元中，每个字有自己唯一的地址<ul><li>添加少数几位用于指示条件的真假<ul><li>若条件位指示的条件为假，则顺序执行下一条指令</li><li>若条件位指示的条件为真，则地址字段指向的微指令是将被执行的下一条微指令</li></ul></li><li>给每个控制字添加一个地址字段，以指示某种条件为真时，将要执行的下一控制字的位置<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220143136049.png" alt="image-20231220143136049" style="zoom:80%;" /></div></li></ul></li></ul></li></ul></li><li>微程序执行<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220144027678.png" alt="image-20231220144027678" style="zoom:80%;" /></div></li><li>微程序控制器：任务<ul><li>微指令定序（microinstruction sequencing）<ul><li>根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器地址</li><li>设计考虑<ul><li>微指令的大小：减小微指令的大小就能节省控制存储器的成本</li><li>地址生成时间：尽可能快地执行微指令</li></ul></li></ul></li><li>微指令执行（microinstruction execution）<ul><li>产生控制信号：发往CPU 内部，送往外部控制总线或其他外部接口<ul><li>根据微指令中的二进制序列，设置控制线</li></ul></li></ul></li></ul></li><li>微程序控制器：构成<ul><li>定序逻辑：向控制地址寄存器装入地址，并发出读命令</li><li>控制地址寄存器：含有下面即将被读取的微指令地址</li><li>控制存储器：存有一组微指令</li><li>控制缓冲寄存器：存放被读出的微指令<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220144608050.png" alt="image-20231220144608050" style="zoom:67%;" /></div></li></ul></li><li>微程序控制器：定序<ul><li>双地址字段：在每条微指令中提供两个地址字段，选择并发送其中某一个地址或操作码到控制地址寄存器<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150149393.png" alt="image-20231220150149393" style="zoom:80%;" /></div></li><li>单地址字段：下一个地址的选择可以是地址字段或下一个顺序地址<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150218707.png" alt="image-20231220150218707" style="zoom:80%;" /></div></li><li>可变格式：提供两种完全不同的指令格式，一位字段用于指定哪种格式被使用 <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220150243984.png" alt="image-20231220150243984" style="zoom:80%;" /> </div></li></ul></li><li>微程序控制器：工作流程<ul><li>执行一条指令，定序逻辑发出一个读命令给控制存储器</li><li>当一条微指令由控制存储器读出后，即被传送到控制缓冲寄存器</li><li>控制缓冲寄存器的内容生成控制信号，并为定序逻辑提供下一条地址信息<ul><li>控制缓冲寄存器的左半部分与控制器发出的控制线相连</li><li>由控制存储器读一条微指令等同于执行这条微指令</li></ul></li><li>定序逻辑根据这个地址信息和ALU 标志，将新的地址装入到控制地址寄存器</li><li>生成新地址的三个选择<ul><li>取顺序下一条微指令：加1 到控制地址寄存器</li><li>基于跳转微指令转移到一个新的例程：将控制缓冲寄存器的地址字段装入控制地址寄存器</li><li>转移到一个机器指令例程：根据IR 中的操作码向控制地址寄存器装入机器指令例程的第一条微指令<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC16%E8%AE%B2-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20231220145030079.png" alt="image-20231220145030079" style="zoom:80%;" /></div></li></ul></li></ul></li><li>优点<ul><li>简化了控制器的设计任务</li><li>实现起来既成本较低，也能减少出错机会</li><li>便于更新</li></ul></li><li>缺点<ul><li>要比采用相同或相近半导体工艺的硬布线控制器慢一些</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第15讲-指令周期和指令流水线</title>
      <link href="/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第15讲-指令周期和指令流水线"><a href="#第15讲-指令周期和指令流水线" class="headerlink" title="第15讲-指令周期和指令流水线"></a>第15讲-指令周期和指令流水线</h2><span id="more"></span><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><ol><li>指令周期：处理单个指令的过程（时间）<ul><li>取指周期：从内存中提取一条指令</li><li>执行周期：执行所提取的指令</li></ul></li><li>只有当机器关闭、发生某种不可恢复的错误或遇到停止计算机的程序指令时，程序执行才会停止 <div align="center"> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/48592052bac3099b3b2b6a6bc730825.png" alt="48592052bac3099b3b2b6a6bc730825" style="zoom:80%;" /> <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219140509286.png" alt="image-20231219140509286" style="zoom:80%;" /> </div></li><li>间址周期<ul><li>指令的执行可能涉及一个或多个存储器中的操作数，它们每个都要求一次存储器访问</li><li>使用间接寻址，还需要额外的存储器访问</li><li>间址周期：把间接地址的读取看成是一个额外的指令子周期<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/80fffef1906b6d92b4b7840982879dc.png" alt="80fffef1906b6d92b4b7840982879dc" style="zoom:80%;" />     </div></li><li>取操作数发生了2次</li></ul></li><li>CPU的任务<ul><li>取指令：CPU 必须从存储器（寄存器、cache 、主存）读取指令</li><li>解释指令：必须对指令进行译码，以确定所要求的动作</li><li>取数据：指令的执行可能要求从存储器或输入/输出（I/O）模块中读取数据</li><li>处理数据：指令的执行可能要求对数据完成某些算术或逻辑运算</li><li>写数据：执行的结果可能要求写数据到存储器或I/O 模块</li></ul></li><li>CPU需求：寄存器<ul><li>CPU需要在指令周期中临时保存指令和数据</li><li>CPU需要记录当前所执行指令的位置，以便知道从何处得到下一条指令</li><li>CPU需要一些小容量的内部存储器<ul><li>假定CPU 有：<ul><li>1个存储地址寄存器（MAR）</li><li>1个存储缓冲寄存器（MBR）/ 存储数据寄存器（MDR）</li><li>1个程序计数器（PC）</li><li>1个指令寄存器（IR）</li></ul></li></ul></li></ul></li></ol><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ol><li>流水处理（pipelining）：如果一个产品要经过几个制作步骤，通过把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</li><li>指令流水线：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/715d9b03a17c0ee53abc1a1de3ef71b.png" alt="715d9b03a17c0ee53abc1a1de3ef71b" style="zoom: 80%;" /></div></li><li>两阶段方法<ul><li>将指令处理分成两个阶段：取指令和执行指令</li><li>在当前指令的执行期间取下一条指令</li><li>问题：执行时间一般要长于取指时间</li><li>更多问题<ul><li>主存访问冲突</li><li>条件分支指令使得待取的下一条指令的地址是未知的<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219142441603.png" alt="image-20231219142441603" style="zoom:80%;" /></div></li></ul></li></ul><ol><li>六阶段方法<ul><li>为了进一步的加速，流水线必须有更多的阶段<ul><li>取指令（Fetch instruction，FI）：读下一条预期的指令到缓冲器</li><li>译码指令（Decode instruction，DI）：确定操作码和操作数指定符</li><li>计算操作数（Calculate operands，CO）：计算每个源操作数的有效地址</li><li>取操作数（Fetch operands，FO）：从存储器取出每个操作数，寄存器中的操作数不需要取</li><li>执行指令（Execute instruction，EI）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li><li>写操作数（Write operand，WO）：将结果存入存储器</li></ul></li><li>各个阶段所需要的时间几乎是相等的 </li><li>例：将9 条指令的执行时间由54 个时间单位减少到14 个时间单位 <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219142859800.png" alt="image-20231219142859800" style="zoom:80%;" />   </div></li><li>问题：   <ul><li>不是所有指令都包含6 个阶段<ul><li>例：一条LOAD 指令不需要WO 阶段</li><li>为了简化流水线硬件设计，在假定每条指令都要求这6 个阶段的基础上来建立时序</li></ul></li><li>不是所有的阶段都能并行完成<ul><li>例：FI 、FO 和WO 都涉及存储器访问</li></ul></li><li>若6 个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待   </li></ul></li><li>限制：条件转移指令能使若干指令的读取变为无效   </li><li>限制：中断，提前处理到一半的过程都需要被清除   <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219143134538.png" alt="image-20231219143134538" style="zoom:80%;" /></div></li></ul></li></ol></li><li>超流水线（Super pipelining）<ul><li>将六级流水线细分为更多的阶段，增加流水线的深度</li><li>提升时钟频率，从而提高指令吞吐率</li></ul></li></ol><div align="center">   <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219143425956.png" alt="image-20231219143425956" style="zoom:50%; align:center" /></div>5. 流水线性能   - 假设     - 𝑡<sub>𝑖</sub> : 流水线第𝑖 段的电路延迟时间     - 𝑡<sub>𝑚</sub> : 最大段延迟（通过耗时最长段的延迟）     - 𝑘: 指令流水线段数     - 𝑑: 锁存延时（数据和信号从上一段送到下一段所需的段间锁存接收时间）   - 周期时间𝑡 = max[𝑡<sub> 𝑖</sub>] + 𝑑 = 𝑡<sub>𝑚</sub> + 𝑑   - 令𝑇<sub>𝑘,𝑛</sub> 为k 阶段流水线执行所有n 条指令所需的总时间       𝑇<sub>𝑘,n</sub> = [𝑘 + (𝑛 - 1)] 𝑡   - 加速比       $$       S_{k}=\frac{T_{1,n}}{T_{k,n}}=\frac{nkt}{[k+(n-1)]t}=\frac{nk}{k+(n-1)}=\frac{n}{1 + \frac{n-1}{k}}>1       $$   - 超标量流水线（Superscalar）   - 超标量结构：具有两条或两条以上并行工作的流水线结构   - 单周期→标量流水线： 时间并行性的优化， 主要是对现有硬件的分段   - 标量流水线→超标量流水线： 空间并行性的优化， 需成倍增加硬件资源   - 多核CPU：一个CPU 芯片中集成多个超标量处理器核<div align="center">   <img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219151828703.png" alt="image-20231219151828703" style="zoom:80%;" /></div><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ol><li>在某些情况下，指令流水线会阻塞或停顿（stall），导致后续指令无法正确执行</li><li><p>类型</p><ul><li>结构冒险（Structure hazard）/ 硬件资源冲突<ul><li>不同指令同时使用相同的硬件资源，比如访存</li></ul></li><li>数据冒险（Data hazard）/ 数据依赖性<ul><li>有些数据要等前序计算完成</li></ul></li><li>控制冒险（Control hazard）<ul><li>比如条件转移</li></ul></li></ul></li><li><p>结构冒险</p><ul><li>原因：已进入流水线的不同指令在同一时刻访问相同的硬件资源<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152258334.png" alt="image-20231219152258334" style="zoom:80%;" /></div>- 解决方案1：流水线停顿（stall），插入空泡（bubble）<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152427936.png" alt="image-20231219152427936" style="zoom:67%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219152432931.png" alt="image-20231219152432931" style="zoom:67%;" /></div>- 解决方案2：使用不同用途的多个存储器  - 例如：指令和数据放在不同的Cache 中- 解决方案3：同一个存储器提供分时处理  - 例如：寄存器时钟上升沿写，时钟下降沿读<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/fc45d97588adcaeda9c26bafb53be84.png" alt="fc45d97588adcaeda9c26bafb53be84" style="zoom:67%;" /></div></li></ul></li><li><p>数据冒险</p><ul><li>原因：未生成指令所需要的数据</li><li>例如：一条指令需要使用之前指令的运算结果，但是结果还没有写回   <div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153222041.png" alt="image-20231219153222041" style="zoom:67%;" /></div>   </li><li>解决方案1：插入nop 指令（软件）<ul><li>问题：如果计算机的结构发生了变化，需要更新软件<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153644429.png" alt="image-20231219153644429" style="zoom:67%;" /></div></li></ul></li><li>解决方案2：插入bubble（硬件）   <ul><li>问题：效率低下，流水线失去意义<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219153957794.png" alt="image-20231219153957794" style="zoom:67%;" /></div></li></ul></li><li>解决方案3：前递（forwarding）/ 旁路（bypassing）   <ul><li>无法解决：一条指令需要使用之前指令的访存结果 Load Use Harzard )（下面第二张图）<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154410789.png" alt="image-20231219154410789" style="zoom:67%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154654582.png" alt="image-20231219154654582" style="zoom:67%;" /></div>   </li></ul></li><li>解决方案4：交换指令顺序<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219154940755.png" alt="image-20231219154940755" style="zoom:80%;" /></div></li></ul></li><li>控制冒险<ul><li>原因：指令的执行顺序被更改<ul><li>转移（Transfer）: 分支（branch）, 循环（loop）,</li><li>中断（Interrupt）</li><li>异常（Exception）</li><li>调用/ 返回（Call / return）</li></ul></li><li>影响：<ul><li>转移指令占比15%～25%（平均每隔4～7 条指令）</li><li>转移平均损失10 个周期</li><li>流水线越深，超标量数越多，转移指令的影响越大</li></ul></li><li>解决方案1：取多条指令<ul><li>多个指令流：复制流水线的开始部分，并允许流水线同时取这两条指令，使用两个指令流</li><li>预取分支目标：识别出一个条件分支指令时，除了取此分支指令之后的指令外，分支目标处的指令也被取来</li><li>循环缓冲器：由流水线指令取指阶段维护的一个小的但极高速的存储器，含有n 条最近顺序取来的指令</li></ul></li><li>解决方案2：分支预测<ul><li>静态预测（规则不变）<ul><li>预测绝不发生跳转</li><li>预测总是发生跳转</li><li>依操作码预测</li></ul></li><li>动态预测（规则变化）<ul><li>发生/ 不发生切换</li><li>转移历史表</li><li>仅在连续发生两次错误时改变状态<ul><li>例如：有一个双层循环，当内循环进行时，总是预测不跳转，最后一次预测错误。如果一次预测错误就切换，那么下一次进入内循环时会预测跳转，然而实际发生跳转，导致两次预测错误。如果一次错误不切换，只有两次错误才切换，那么内循环结束时仍是预测不跳转，下一次进入内循环将会预测正确，总共只有一个错误预测。<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219161159576.png" alt="image-20231219161159576" style="zoom:50%;" /><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219161210117.png" alt="image-20231219161210117" style="zoom:50%;" /></div></li></ul></li><li>转移历史表<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219162033073.png" alt="image-20231219162033073" style="zoom:80%;" /></div></li></ul></li></ul></li><li>解决方案3：提前判断<ul><li>直接无条件转移：例如j Target<ul><li>在取指阶段即可获得转移目标地址（流水线不停顿）</li></ul></li><li>间接无条件转移：例如 jr \$r1<ul><li>在译码阶段才能获得转移目标地址（流水线停顿1 周期）</li></ul></li><li>直接有条件转移：例如 beq \$r1, \$r2, Target<ul><li>在执行阶段才能获得转移目标地址（流水线停顿2 周期）</li><li>在寄存器堆输出端增加额外的比较电路（流水线停顿1 周期）</li></ul></li></ul></li><li>解决方案4：交换指令顺序<div align="center"><img src="https://sprooc.github.io/2023/12/19/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC15%E8%AE%B2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20231219163122385.png" alt="image-20231219163122385" style="zoom:50%;" /></div></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20231217周记</title>
      <link href="/2023/12/17/20231217%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/17/20231217%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>期末周临近，最近也开始复习了。而且越复习越发现不懂的东西还有很多。。。所以期末考试之前算法的学习应该会暂时放一放啦。但是每天刷三道题还要继续保持。</p><span id="more"></span><p>本来想着为了计组机考，这周复习一下Java的，结果发现用Java刷力扣还是有点难受，主要是自己不熟悉库。以后再花点时间深入学习一下Java吧。虽然没有复习Java，但应付计组机考还是挺轻松的。</p><p>CSP的成绩出来了。作为第一次考的成绩，虽然没到预期，也算还行吧。</p><p><img src="03280f37bdedeefd8c2c6f91b864a95.png" alt="03280f37bdedeefd8c2c6f91b864a95"></p><p>这周没什么好记录的了，下周也要努力复习啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第14讲-指令系统</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="第14讲-指令系统"><a href="#第14讲-指令系统" class="headerlink" title="第14讲-指令系统"></a>第14讲-指令系统</h2><span id="more"></span><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li>指令的要素<ul><li>操作码：指定将要完成的操作</li><li>源操作数引用：操作会涉及一个或多个源操作数，这是操作所需的输入</li><li>结果操作数引用：操作可能会产生一个结果</li><li>下一指令引用：告诉处理器这条指令执行完成后到哪儿去取下一条指令</li></ul></li><li>指令表示<ul><li>在计算机内部，指令由一个位串来表示</li><li>指令格式：对应于指令的各要素，这个位串划分成几个字段<ul><li>大多数指令集使用不止一种指令格式</li></ul></li><li>机器指令符号表示法：<ul><li>操作码被缩写成助记符来表示<ul><li>MUL：乘，DIVDIV：除，LOAD：由存储器装入，STOR：保存到存储器</li></ul></li><li>操作数也可以用符号表示<ul><li>用寄存器编号或内存地址替换操作数<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215224433079.png" /></div></li></ul></li></ul></li></ul></li><li>指令格式<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/651034a6bb34e059875eb0098f8a0bd.png" alt="651034a6bb34e059875eb0098f8a0bd" style="zoom:70%;" /></div><ul><li>定长操作码：𝒏位操作码字段的指令系统最大能够表示𝟐 <sup>𝒏</sup> 条指令</li><li>可变长操作码<ul><li>扩展操作码：不同地址数的指令具有不同长度的操作码<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/31163908f89f4a44c5f0ff6053d7b3d.png" /></div><br>15条三地址指令操作码：0 0 0 0 ~ 1 1 1 0<br>15条二地址指令操作码：1 1 1 1 0 0 0 0 ~ 1 1 1 1 1 1 1 0<br>15条一地址指令操作码：1 1 1 1 1 1 1 1 0 0 0 0 ~ 1 1 1 1 1 1 1 1 1 1 1 0</li></ul></li><li>指令格式通过它的各个构成部分来定义指令的位安排</li><li>一个指令格式必须包含一个操作码，以及隐式或显式的、零个或多个操作数</li><li>指令格式必须显式或隐式地为每个操作数指定其寻址方式</li><li>大多数指令集使用不止一种指令格式 </li><li>例题：假设指令字长为16 位，操作数的地址码为6 位，指令有零地址、一地址、二地址3 种格式。<ul><li>设操作码固定，若零地址指令有M 种，一地址指令有N 种，则二地址指令最多有几种？<br>操作码位数：16 - 6 - 6 = 4<br>总指令条数：2^4 = 16<br>二地址指令最多：16 - M - N</li><li>采用扩展操作码技术，二地址指令最多有几种？<br>0000 ~ 1110</li><li>采用扩展操作码技术，若二地址指令有P 条，零地址指令有Q 条，则一地址指令最多有几种？<br>$𝑄=[(2^4-𝑃) × 2^6-𝑅] × 2^6$</li></ul></li></ul></li><li>操作码<ul><li>差异：不同的计算机上操作码的数目变动是很大的</li><li>共性：所有计算机上都会存在相同的常用操作类型</li><li>数据传送<ul><li>指明源和目标操作数的位置</li><li>指明将要传送数据的长度</li><li>指明每个操作数的寻址方式<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225455850.png" alt="image-20231215225455850" style="zoom:80%;" /></div></li></ul></li><li>算术运算<ul><li>一条算术指令的执行会涉及数据传送操作，来为算术和逻辑单元准备输入，并传送逻辑单元的输出<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225551293.png" alt="image-20231215225551293" style="zoom:80%;" /></div></li></ul></li><li>逻辑运算</li><li>位操作：操作一个字或其它可寻址单元的中的个别位</li><li>移位和旋转<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225656478.png" alt="image-20231215225656478" style="zoom:80%;" /></div></li><li>输入/输出<ul><li>各种输入/输出方法仅有少数输入/输出指令实现，具体操作由参数、代码或命令字指定<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225740670.png" alt="image-20231215225740670" style="zoom:80%;" /></div></li></ul></li><li>控制转移<ul><li>分支指令（亦称为跳转指令）：把将要执行的下一条指令的地址作为它的操作数之一</li><li>跳步指令：包含一个隐含地址，该隐含地址等于下一指令地址加上该指令长度之和</li><li>过程调用指令：涉及由目前位置转移到过程的调用指令和由过程返回到调用发生位置的返回指令<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/image-20231215225810362.png" alt="image-20231215225810362" style="zoom:70%;" /></div></li></ul></li></ul></li><li>操作数<ul><li>常见类型：地址、数值、字符、逻辑数据</li><li>地址<ul><li>一个指令需要有4 个地址引用：2 个源操作数，1 个目的操作数，以及下一指令地址<ul><li>下一指令地址可以是隐含的</li><li>源操作数可以和目的操作数是相同的</li></ul></li><li>地址数量<ul><li>每条指令中的地址数目越少<ul><li>指令的长度越短，不需要复杂的CPU</li><li>使程序总的指令条数更多，导致执行时间更长，程序也更长更复杂 </li></ul></li><li>对于多地址指令，普遍具有多个通用寄存器可用，允许某些运算只使用寄存器即可完成，从而使执行加快 </li></ul></li></ul></li><li>数值<ul><li>计算机存储的数值是受限的<ul><li>机器可表示数值的幅值是有限的</li><li>浮点数情况下数值精度是有限的</li></ul></li><li>数值数据的类型<ul><li>二进制整数或定点数</li><li>二进制浮点数</li><li>十进制数</li></ul></li></ul></li><li>字符<ul><li>国际参考字母表（IRA）/ 美国信息交换标准码（ASCII）：每个字符被表示成唯一的7 位二进制串</li><li>扩展的二进制编码的十进制交换码（EBCDIC）：8 位编码</li><li>统一码（Unicode）：16 位/ 32 位</li></ul></li><li>逻辑数据<ul><li>将一个n 位单元看成是由n 个1 位项组成，每项有值0 或1<ul><li>存储一个布尔或者二进制数据项序列，序列中的每个值只能取值1（真）或0（假）</li><li>有利于实现对数据项的具体位进行操纵</li></ul></li></ul></li><li>大端序和小端序<ul><li>假设有32 位的十六进制值1234567812345678，将它存储在可字节寻址的存储器地址184 处<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/521f09061e51fd9fb6ac72c325b2545.png" alt="521f09061e51fd9fb6ac72c325b2545" style="zoom:75%;" /></div></li><li>在两种策略中每个数据项有同样地址（范围）</li><li>在任何一个给定的多字节值中，小端的字节排序是大端的反序，反之亦然</li><li>端序不影响结构中数据项的次序</li></ul></li></ul></li><li>寻址方式<ul><li>立即寻址<ul><li>方式：操作数实际值出现在指令中</li><li>用法：定义和使用常数或设置变量的初始值</li><li>算法：操作数= A</li><li>优点：快，除了取指令之外，获得操作数不要求另外的存储器访问</li><li>缺点：数的大小受限于地址字段的长度</li></ul></li><li>直接寻址<ul><li>方式：地址字段含有操作数的有效地址</li><li>用法：早期计算机常用，在当代计算机体系结构中不多见</li><li>算法：EA = A</li><li>优点：只要求1 次存储器访问，且无需为生成地址而专门计算</li><li>缺点：有限的地址空间<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/bd7ded68154fce663598c44ebafe185.png" alt="bd7ded68154fce663598c44ebafe185" style="zoom:75%;" /></div></li></ul></li><li>间接寻址<ul><li>方式：地址字段指示一个存储器字地址, 而此地址出保存有操作数的全长度地址</li><li>算法：EA = (A)</li><li>优点：扩大了地址空间</li><li>缺点：取操作数需要2 次访问存储器</li><li>解释：地址引用的数量限制可能是有益的<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/eeda2a141f785936e4bb0bcb8d753a3.png" alt="eeda2a141f785936e4bb0bcb8d753a3" style="zoom:75%;" /></div></li></ul></li><li>寄存器寻址<ul><li>方式：地址字段指示的是寄存器</li><li>算法：EA = R</li><li>优点：指令中仅需要一个较小的地址字段, 且不需要存储器访问</li><li>缺点：地址空间十分有限</li><li>解释：寄存器寻址只有在被有效使用的时候才有意义<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/7ba579c2a8dcf17e84bb69ea3c44ef4.png" alt="7ba579c2a8dcf17e84bb69ea3c44ef4" style="zoom:75%;" /></div></li></ul></li><li>寄存器间接寻址<ul><li>方式：地址字段指示寄存器</li><li>算法：EA = (R)</li><li>优点：扩大了地址空间，比间接寻址少1 次存储器访问</li><li>缺点：相对于寄存器寻址，需要多1 次存储器访问<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/b4e7fe96b05afc5716beeebe605ea5d.png" alt="b4e7fe96b05afc5716beeebe605ea5d" style="zoom:75%;" /> </div></li></ul></li><li>偏移寻址<ul><li>方式：结合直接寻址和寄存器间接寻址能力</li><li>算法：EA = (R) + A</li><li>类型<ul><li>相对寻址<ul><li>方式：隐含引用的寄存器是程序计数器（PC）</li><li>此指令后续的下一条指令的地址加上地址字段的值产生有效地址</li><li>用法：大多数存储器访问都相对靠近正在执行的指令，相对寻址可节省指令中的地址位数；可用于转移控制指令。</li><li>算法：EA = (PC) + A</li><li>优点：利用程序局部性原理，节省指令中地址的位数<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/5631d9890ccaab93238948c8af96873.png" alt="5631d9890ccaab93238948c8af96873" style="zoom:75%;" /></div></li></ul></li><li>基址寄存器寻址<ul><li>方式：被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地址的偏移量（通常是无符号整数表示）</li><li>寄存器引用可以是显式的，也可以是隐式的</li><li>算法：EA = (B) + A</li><li>用法：虚拟内存空间中的程序重定位<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/c8d29de812d20e07ed79cab5deca558.png" alt="c8d29de812d20e07ed79cab5deca558" style="zoom:75%;" /></div></li></ul></li><li>变址寻址<ul><li>方式：指令地址字段引用一个主存地址，被引用的寄存器含有对于该地址的一个正的偏移量</li><li>算法：EA = A + (IX)</li><li>用法：为完成重复操作提供一种高效机制</li><li>扩展：结合间接寻址和变址寻址<ul><li>前变址：EA = (A + IX ))；后变址：EA = (A) + IX<div align="center"> <img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/58df44c9b28ef764dbaf9d242d94406.png" alt="58df44c9b28ef764dbaf9d242d94406" style="zoom:75%;" /></div></li></ul></li></ul></li><li>栈寻址<ul><li>方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li><li>解释：与栈相关的是一个指针，它的值是栈顶地址，或者当栈顶的两个元素已在CPU 寄存器内，此时栈顶指针指向栈顶的第三个元素<br><div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac13%e8%ae%b2-%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f/ad44b934e146b4ccb0694ef4faec0b0.png" alt="ad44b934e146b4ccb0694ef4faec0b0" style="zoom:75%;" /></div><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3></li></ul></li></ul></li></ul></li></ul></li><li>指令格式的设计原则<ul><li>指令尽量短<ul><li>程序占用存储空间小</li></ul></li><li>有足够的操作码位数<ul><li>要为操作类型不断增加预留</li></ul></li><li>操作码的编码必须有唯一的解释<ul><li>操作码译码时要么是唯一的合法编码，要么是不合法的</li></ul></li><li>指令长度是字节的整数倍<ul><li>与内存按照字节寻址相对应，便于指令的读取和地址计算</li></ul></li><li>合理选择地址字段的个数<ul><li>涉及到指令长度和规整性，是空间和时间开销权衡的结果</li></ul></li><li>指令尽量规整<ul><li>简化硬件的实现</li></ul></li></ul></li><li>指令长度<ul><li>最明显的权衡考虑是在强有力的指令清单和节省空间之间进行</li><li>编程人员希望更多的操作码、更多的操作数、更多的寻址方式和更大的地址范围</li><li>指令长度变短可以节省存储空间和减少数据传送时间</li><li>指令长度应该是字符长度或定点数长度的整数倍（比如n 个字节）</li><li>指令长度应该等于存储器的传送长度（即数据总线宽度），或者这两个值其中之一是另一个的整数倍</li></ul></li><li>位的分配<ul><li>对于给定的指令长度，在操作码数目和寻址能力之间存在着权衡考虑</li><li>使用变长的操作码<ul><li>使用一个最小操作码长度，但是对于某些操作码，可通过使用指令附加位的方法来指定附加的操作</li></ul></li><li>使用寻址位的考虑因素<ul><li>支持的寻址方式的种数</li><li>操作数的数量：数量多，则操作数的位数短</li><li>寄存器与存储器比较：能用于操作数引用的寄存器越多，指令需要的位数越少</li><li>寄存器组的数目：对于固定数目的寄存器 功能上的分开将使指令只需较少的位数</li><li>地址范围：比如间接寻址可以增大范围</li><li>寻址粒度：同样大的寻址空间，使用较大的字时，需要的地址位更少</li></ul></li></ul></li><li>变长指令<ul><li>提供不同长度的各种指令格式</li><li>优点<ul><li>易于提供大的操作码清单，而操作码具有不同的长度</li><li>寻址方式能更灵活，指令格式能将各种寄存器和存储器引用加上寻址方式予以组合</li></ul></li><li>缺点<ul><li>增加了CPU 的复杂程度（效率也会降低）</li></ul></li><li>取至少等于最长指令长度的几个字节或几个字</li></ul></li></ol><h3 id="指令集设计"><a href="#指令集设计" class="headerlink" title="指令集设计"></a>指令集设计</h3><ol><li>指令集的设计是件很复杂的事情，影响计算机系统的诸多方面<ul><li>指令集定义了处理器应完成的多数功能，对处理器的实现有着显著的影响</li><li>指令集是程序员控制处理器的方式，设计时必须考虑程序员的要求</li></ul></li><li>设计的基本原则<ul><li>完备性/完整性：操作类型应当尽可能完备，但太复杂了也会给硬件实现增加困难</li><li>兼容性：应当兼容以前的指令系统，为软件重复利用带来方便</li><li>均匀性：应当能对多种类型的数据进行处理</li><li>可扩充性：操作码要预留一定的编码空间</li></ul></li><li>设计的基本问题<ul><li>操作指令表：应提供多少和什么样的操作，操作有多复杂</li><li>数据类型：对哪几种数据类型完成操作</li><li>指令格式：指令的位长度、地址数目、各个字段的大小等</li><li>寄存器：能被指令访问的寄存器数目以及它们的用途</li><li>寻址：寻址方式的种类以及有效地址的计算</li><li>下一条指令地址的确定：通常通过PC 寄存器实现</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第13讲-总线</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%80%BB%E7%BA%BF/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC13%E8%AE%B2-%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第13讲-总线"><a href="#第13讲-总线" class="headerlink" title="第13讲-总线"></a>第13讲-总线</h2><span id="more"></span><h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><ol><li><p>类型</p><ul><li>芯片内部总线：连接芯片内部的各个部分<ul><li>例：CPU 中连接寄存器、ALU 等部分</li></ul></li><li>系统总线：连接CPU 、存储器、IO 控制器和其他功能设备</li><li>通信总线：连接主机和I/O 设备，或连接不同的计算机系统</li></ul></li><li><p>总线结构</p><ul><li>数据线：在系统组件之间传输数据<ul><li>数据线的数量决定了一次可以传输的数据的大小</li></ul></li><li>地址线：在数据线和地址I/O 端口上指定数据的来源和去向<ul><li>地址线的数量决定了寻址空间的大小</li></ul></li><li>控制线：控制对数据线和地址线的存取和使用<ul><li>时钟（clock）：用于总线同步操作</li><li>总线请求（bus request）：表示模块需要获得对总线的控制</li><li>总线允许（bus grant）：发出请求的设备已经被允许控制总线</li><li>中断请求（interrupt request）：表示某个中断正在悬而未决</li><li>中断响应（interrupt ACK）：未决的终端请求被响应</li><li>存储器读（memory read）：从存储器读数据到总线</li><li>存储器写（memory write）：将数据从总线写入存储器</li><li>I/O读（I/O read）：从I/O 端口读数据到总线</li><li>I/O写（I/O write）：将数据从总线写入I/O 端口<br><img src="image-20231215210246332.png" alt="image-20231215210246332" style="zoom:70%;" /></li></ul></li></ul></li><li>总线上数据传输的特点<ul><li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据<ul><li>如果同一时刻多个设备同时发送数据，会造成数据之间的混淆</li><li>使用总线进行数据传输<ul><li>如果连在总线上的某个设备希望向另一个设备发送数据，需要：<ul><li>获得总线的使用权</li><li>通过总线传送数据</li></ul></li><li>如果连在总线上的某个设备希望向另一个组件请求数据，需要：<ul><li>获得总线的使用权</li><li>通过总线向另一个设备发送请求，等待另一个设备发送数据</li></ul></li></ul></li></ul></li><li>当总线在被使用过程中，其它设备不可以抢占</li></ul></li></ol><h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ol><li><p>用途：专用总线，复用总线</p><ul><li>专用（dedicated）总线：始终只负责一项功能，或始终分配给特定的计算机组件<ul><li>优点：高吞吐量，减少总线冲突</li><li>缺点：增加了系统的规模和成本</li></ul></li><li>复用（multiplexed）总线：将同一线路用于多种用途<ul><li>优点：使用的布线数量少，节省空间和成本</li><li>缺点：每个模块需要更复杂的控制电路，且共享可能会降低性能</li></ul></li></ul></li><li><p>仲裁（arbitration）：当多个设备需要与总线通信时，通过某种策略选择一个设备</p><ul><li>平衡因素<ul><li>优先级：优先级高的设备优先被服务</li><li>公平性：优先级最低的设备不能一直被延迟</li></ul></li><li>仲裁方案<ul><li>集中式（centralized）：由仲裁器（arbiter）或总线控制器（bus controller）负责分配总线使用权<ul><li>链式查询/菊花链（daisy chain）</li><li>计数器查询（query by a counter）</li><li>独立请求（independently request）</li></ul></li><li>分布式（distributed）：每个设备都包含访问控制逻辑，各设备共同作用分享总线<ul><li>自举式（self selection）</li><li>冲突检测（collision detection）</li></ul></li></ul></li><li>链式查询<ul><li>所有的设备都是串行连接的，并将允许信号从优先级最高的设备下发到优先级最低的设备。</li><li>总线仲裁器收到请求后，在总线不忙的前提下，发起允许信号。</li><li>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递。</li><li>优点：确定优先级很简单；可以很灵活地添加设备。</li><li>缺点：不能保证公平性；对电路故障敏感；限制总线的速度。<br><img src="ee7ff247291e6eb2fe3605d298a6306.png" alt="ee7ff247291e6eb2fe3605d298a6306" style="zoom:80%;" /></li></ul></li><li>计数器查询 <ul><li>将总线允许线替换为设备ID（地址）线 </li><li>当总线仲裁器收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备ID 线发向各个部件</li><li>如果当前发送请求的设备ID 等于裁决器当前的计数，裁决器将停止计数，设备将总线设置为繁忙 </li><li>优点<ul><li>通过使用不同的初始计数，可以灵活地确定设备优先级<ul><li>强调优先级：从1 开始</li><li>强调公平性：从下一个设备的ID 开始 </li><li>对电路故障不敏感 </li></ul></li></ul></li><li>缺点<ul><li>需要添加设备ID 线</li><li>需要解码和比较设备ID 信号</li><li>限制总线的速<br><img src="7b58c5908dbf8d0490b1137f3f1369f.png" alt="7b58c5908dbf8d0490b1137f3f1369f" style="zoom: 90%;" /></li></ul></li></ul></li><li>独立请求<ul><li>每个设备都有自己的总线请求线和总线允许线</li><li>当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器</li><li>总线仲裁器决定哪个设备可以使用总线<ul><li>确定策略：固定优先级，公平链式，LRU，FIFO</li></ul></li><li>优点：快速响应；可编程的优先级</li><li>缺点：复杂的控制逻辑；更多的控制线路<br><img src="a45b0f7154ac47e6ea3bd4ea0b74939.png" alt="a45b0f7154ac47e6ea3bd4ea0b74939" style="zoom:85%;" /></li></ul></li><li><p>自举式</p><ul><li><p>固定优先级</p></li><li><p>每个设备在其总线请求线上发送请求</p><ul><li>最低优先级的设备没有请求线</li></ul></li><li><p>每个设备自行判断自己是否在请求总线的设备中优先级最高<br><img src="862036a6fe5287ef6b619355bd58ab3.png" alt="862036a6fe5287ef6b619355bd58ab3" style="zoom:75%;" /></p></li></ul></li><li><p>冲突检测</p><ul><li><p>当一个设备想要使用总线时，它会检查总线是否繁忙</p><ul><li>如果总线空闲，设备使用总线</li></ul></li><li><p>冲突：如果两个设备发现总线空闲，它们可能同时使用总线</p><ul><li>在传输数据时，设备会监听总线，检查是否存在冲突</li><li>如果发生冲突，所有使用总线的设备将停止数据传输，并分别在随机时间间隔后再次请求总线</li></ul></li></ul></li></ul></li><li><p>时序（timing）</p><ul><li>确定每个总线事务的开始和结束时间</li><li>总线事务：地址+ 数据+ … + 数据</li><li>同步时序：事件的发生由时钟决定<ul><li>优点：更容易实现和测试</li><li>缺点：所有设备共享同一个时钟；总线长度受到时钟偏差的限制 </li></ul></li><li>异步时序：一个事件的发生取决于前一个事件的发生（顺序）<ul><li>握手策略<br><img src="99abe6d1946854ea2c3d21c573b4ad3.png" alt="99abe6d1946854ea2c3d21c573b4ad3"> </li><li>异步数据传输     <ol><li>CPU设置地址并设置 ReadReq 线</li><li>存储器读取相应地址并设置Ack 线</li><li>CPU释放地址线和ReadReq 线</li><li>存储器释放Ack 线</li><li>存储器将数据传到数据线并设置DataRdy 线</li><li>CPU读取数据并设置Ack 线</li><li>存储器释放数据线和dataRdy 线</li><li>CPU 释放Ack 线<br> <img src="8008a65b2bba709b69858ae51276bf4.png" alt="8008a65b2bba709b69858ae51276bf4" style="zoom:80%;" />     </li></ol></li><li>优点：可以灵活地协调速度不同的设备</li><li>缺点：接口逻辑复杂；对噪声敏感（被误认为信号）     </li></ul></li><li>半同步：同步时序和异步时序相结合     <ul><li>为了减少噪声的影响，在异步计时中使用时钟     </li><li>准备和响应信号在时钟上升沿有效     </li><li>半同步通信集同步与异步通信之优点，既保留了同步通信的基本特点     <ul><li>所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别。</li><li>同时又像异步通信那样，允许不同速度的模块和谐地工作。为此增设了一条“等待”( )响应信号线。     </li></ul></li><li>半同步时序的读命令     <ul><li>主模块在T1发出地址，T2发出命令       </li><li>从模块工作速度较慢，无法在下一时钟周期时刻提供数据，则必须在T3之前通知主模块，使其进入等待状态，此刻，从模块置$\overline{\text{WAIT}}$为低电平有效。主模块在测得$\overline{\text{WAIT}}$有效，则不立即从数据线上取数。       </li><li>主模块等待，直到测得$\overline{\text{WAIT}}$为高电平即等待无效时，主模块即把此刻的下一周期当作正常周期T3，即时获取数据，T4结束传输。<br><img src="446d584b9e1f4c178ab54809754e0cf.png" alt="img" style="zoom:80%;" /></li></ul></li><li>参考文章：<a href="https://blog.csdn.net/iteye_21199/article/details/82200294">总线的半同步通信-CSDN博客</a>            </li></ul></li><li>分离事务：设备准备数据期间释放总线   <ul><li>将一个总线事件分离为两个过程</li><li>优点：增加总线利用率</li><li>缺点：增加每个总线事件的持续时间和系统复杂度<br><img src="e5dc9f1eaeedae7136286233700c9c2.png" alt="e5dc9f1eaeedae7136286233700c9c2" style="zoom:85%;" /></li></ul></li></ul></li><li><p>总线带宽（bandwidth）：总线的最大数据传输速率。不要考虑总线仲裁、地址传输等因素。 </p></li><li>数据传输速率（data transfer rate）：考虑地址传输、握手等因素。<ul><li>例题1：假设同步总线的时钟周期为50 ns，每次传输需要一个时钟周期，异步总线每次握手需要40 ns 。两个总线都是32 位宽，内存的数据准备时间为200 ns 。当从存储器中读出一个32 位的字时，计算两个总线的数据传输速率。<ul><li>同步总线<ul><li>发送指令和地址到内存：50ns</li><li>内存准备数据：200ns</li><li>将数据传输到CPU：50ns</li><li>数据传输速率= 32bit / (50 + 200 + 50)ns = 106.7Mbps</li></ul></li><li>异步总线<ul><li>步骤1：40 ns</li><li>步骤2 、3 、4 / 数据准备：max(40ns* 3,200ns) = 200ns</li><li>步骤5 、6 、7：40ns * 3 = 120ns</li><li>数据传输速率= 32bit / (40 + 200 + 120)ns = 88.9Mbps<br><img src="d7157e052b62e7d824e1d4dfaf3089d.png" alt="d7157e052b62e7d824e1d4dfaf3089d"></li></ul></li></ul></li><li>例题2：假设同步总线的时钟周期为50 ns，每次传输需要一个时钟周期，异步总线每次握手需要40 ns 。两个总线都是32 位宽，存储器的数据准备时间为230 ns 。当从存储器中读出一个32 位的字时，计算两个总线的数据传输速率。<ul><li>同步总线：数据传输速率= 32bit / (50 + <strong>250</strong> + 50)ns = 91.4Mbps<ul><li>数据准备时间是250，因为必须必须是完整的时钟周期</li></ul></li><li>异步总线：数据传输速率= 32bit / (40 + 230 + 120)ns = 82.1Mbps</li></ul></li><li>例题3：假设系统具有以下特征<br>1.它支持访问大小为4 到16 个字（每个字32 位）的块<br>2.同步总线具有64 位宽和200MHz 时钟频率，需要1 个时钟周期来传输地址或64 位数据<br>3.在两个总线事务之间有2 个空闲时钟周期<br>4.内存访问时准备前4 个字需要200ns，后面每4 个字准备需要20ns<br>5.当前面的数据在总线上传输时，内存可以同时读取后面的数据<br>如果读取256 个字，分别计算每次传输4 个字和16 个字时的数据传输速率、传输时间和每秒总线事务数<ul><li>每次传输4 个字<ul><li>总线事务：地址+ 4 个字<ul><li>地址传输：1 个时钟周期</li><li>数据准备：200ns (40 个时钟周期）</li><li>数据传输：2 个时钟周期</li><li>空闲：2 个时钟周期</li></ul></li><li>总共：256 / 4 * (1 + 40 + 2 + 2) = 2880 个时钟周期</li><li>传输时间= 2880 * 5ns = 14400ns</li><li>每秒总线事务数= (256 / 4) * (1s / 14400ns) = 4.44M</li><li>数据传输速率= 256 * 32bit / 14400ns = 568.9Mbps</li></ul></li><li>每次传输16 个字<ul><li>总线事务：地址+ 16 个字<ul><li>地址传输：1 个时钟周期</li><li>数据准备（前4 个字）：200ns（40 个时钟周期）</li><li>数据传输：2 个时钟周期（同时读取后4 个字：20ns）</li><li>空闲：2 个时钟周期</li></ul></li><li>总共：256 / 16 <em> (1 + 40 + 3</em>max(2, 4)+ 2 + 2) = 912 个时钟周期</li><li>传输时间= 912 * 5ns = 4560ns</li><li>每秒总线事务数= 16 * 1s / 4560ns = 3.51M</li><li>数据传输速率= 256 * 32bit / 4560ns = 1796.5Mbps</li></ul></li></ul></li><li>提高总线的数据传输率<ul><li>提高时钟频率（时钟周期数不变的情况下）</li><li>增加数据总线宽度<ul><li>每次传输更多的数据（成本：更多的总线线路）</li></ul></li><li>块传输<ul><li>传输一次地址就传输一块数据（成本：高复杂性）</li></ul></li><li>分离总线事务<ul><li>减少总线空闲时间（成本：复杂性高，增加每个事务的持续时间）</li></ul></li><li>分离地址线和数据线<ul><li>同时传输地址和数据（成本：更多的总线线路）</li></ul></li></ul></li></ul></li><li>总线层次结构<ul><li>单总线结构：CPU、存储器和I/O 模块都连接到一条系统总线<ul><li>优点：简单，易于扩展</li><li>缺点：连接的设备越多，总线长度越大，传输延迟也就越大；聚集的传输请求接近总线容量时，总线成为瓶颈<br><img src="40ff86dbaedcc381a249137d805f48c.png" alt="40ff86dbaedcc381a249137d805f48c"></li></ul></li><li>双总线结构I   <ul><li>在CPU 和存储器中间增加一个存储器总线   </li><li>优点：增加CPU 和存储器之间的传输效率，同时降低系统总线的负担<br><img src="9194fe1c796dde6aa125281c54a038c.png" alt="9194fe1c796dde6aa125281c54a038c" style="zoom:75%;" /></li></ul></li><li>双总线结构II<ul><li>将系统总线分为存储器总线、I/O 总线和IOP (input/output）</li><li>优点：降低I/O 对总线的负担<br><img src="a4017a70126bfc3ae01d13b8c418ac4.png" alt="a4017a70126bfc3ae01d13b8c418ac4" style="zoom:80%;" /></li></ul></li><li>多总线结构I<ul><li>增加一个本地总线（local bus bus）来连接CPU 和cache</li><li>优点：分离了CPU 和I/O 的交互<br><img src="8ba12b322f24cb25b416dee800eb747.png" alt="8ba12b322f24cb25b416dee800eb747" style="zoom:80%;" /></li></ul></li><li>多总线结构II<ul><li>将系统总线分为存储器总线、I/O 总线和DMA 总线</li><li>优点：增加I/O 效率<br><img src="9a3f8dc17b40122e261822c986ab632.png" alt="9a3f8dc17b40122e261822c986ab632"></li></ul></li><li>多总线结构III<ul><li>增加一个高速I/O 总线来连接高速设备</li><li>优点：增加I/O 交互效率</li></ul></li></ul></li></ol><p><img src="d43da1decbed8bba82ae3b3f586a29d.png" alt="d43da1decbed8bba82ae3b3f586a29d" style="zoom:75%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第12讲-虚拟存储器</title>
      <link href="/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC12%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/15/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC12%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第12讲-虚拟存储器"><a href="#第12讲-虚拟存储器" class="headerlink" title="第12讲-虚拟存储器"></a>第12讲-虚拟存储器</h2><span id="more"></span><h3 id="操作系统的出现"><a href="#操作系统的出现" class="headerlink" title="操作系统的出现"></a>操作系统的出现</h3><ol><li>第一台计算机诞生时，采用手工操作的方式<ul><li>一个用户独占全机：不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低</li><li>CPU等待手工操作：CPU 的利用不充分</li></ul></li><li>批处理系统：加载在计算机上的一个系统软件，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（包括程序、数据和命令）<ul><li>联机批处理系统，脱机批处理系统</li></ul></li><li>操作系统：一种控制应用程序运行和在计算机用户与计算机硬件之间提供接口的程序</li><li>目标：使计算机使用起来更方便；允许计算机系统的资源以有效的方式使用</li></ol><h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><ol><li>早期计算机的主存中仅包含系统软件和一个用户程序<ul><li>单道程序设计</li></ul></li><li>现在计算机的主存中包含操作系统和若干个用户程序<ul><li>当所有任务都需要等待I/O 时，为了避免处理器处于空闲状态，需要尽可能让更多的任务进入主存</li><li>多道程序设计：让处理器一次处理多个任务，提高处理器的利用率</li></ul></li><li>存储器管理<ul><li>在多道程序系统中，主存需要进一步划分给多个任务，划分的任务由操作系统动态执行</li><li>本门课不区分“进程”和“任务”这个更抽象的概念</li></ul></li></ol><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ol><li>如何将更多更大的任务装入主存<ul><li>增大主存容量</li><li>使用交换（exchange）技术<ul><li>当主存中没有处于就绪的任务时，操作系统调入其他任务来执行</li><li>区（partitioning）和分页（paging）</li></ul></li></ul></li><li>虚拟存储器<ul><li>请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上</li><li>虚拟地址</li></ul></li><li>分区方式<ul><li>分区方式将主存分为两大区域<ul><li>系统区：固定的地址范围内，存放操作系统</li><li>用户区：存放所有用户程序</li></ul></li><li>简单固定分区<ul><li>用户区划分成长度不等的固定长的分区</li><li>当一个任务调入主存时，分配一个可用的、能容纳它的、最小的分区</li><li>优点：简单</li><li>缺点：浪费主存空间</li></ul></li><li>可变长分区<ul><li>用户区按每个任务所需要的内存大小进行分配</li><li>优点：提高了主存的利用率</li><li>缺点：时间越长，存储器中的碎片就会越多</li></ul></li></ul></li><li>分页方式<ul><li>目的：减少碎片的产生</li><li>基本思想<ul><li>把主存分成固定长且比较小的存储块，称为页框（page frame），每个任务也被划分成固定长的程序块，称为页（page）</li><li>将页装入页框中，且无需采用连续的页框来存放一个任务中所有的页</li></ul></li><li>逻辑地</li><li>物理地址：实际主存地址</li></ul></li></ol><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ol><li>问题：内存的大小是有限的，但对内存的需求不断增加</li><li>基本思想<ul><li>请求分页：仅将当前需要的的页调入主存<ul><li>通过硬件将逻辑地址转换为物理地址</li><li>未命中时在主存和硬盘之间交换信息</li></ul></li></ul></li><li>优点<ul><li>在不扩大物理内存的前提下，可以载入更多的任务</li><li>编写程序时不需要考虑可用物理内存的状态</li><li>程序员认为可以独享一个连续的、很大的内存</li><li>可以在大于物理内存的逻辑地址空间中编程</li></ul></li><li>设计要素<ul><li>页大小：4KB, 8KB, …</li><li>映射算法：全相联映射</li><li>写策略：写回</li><li>Cache比主存快10 倍，主存比硬盘快100000 多，故需要减少硬盘访问，尽可能提高主存命中率</li></ul></li><li>类型<ul><li>分页式虚拟存储器</li><li>分段式虚拟存储器</li><li>段页式虚拟存储器</li></ul></li><li>分页式虚拟存储器<ul><li>主存储器和虚拟地址空间都被划分为大小相等的页面<ul><li>虚拟页（virtual page，VP） / 逻辑页（logical page）：虚拟地址空间中的页面</li><li>物理页（physical page，PP） / 页框（page frame）：主存空间中的页面</li></ul></li><li>页表<ul><li>页表中包含了所有虚拟页的信息，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等等</li><li>保存在主存中</li><li>虚拟地址：虚拟页号 + 页内偏移量</li><li>根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址<br>虚拟页号 + 页内偏移量 -&gt; 物理页号 + 页内偏移量</li></ul></li><li>快表（Translation Lookaside Buffer，TLB）<ul><li>页表的使用增加了主存的访问次数</li><li>为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li><li>后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中<ul><li>映射：关联映射，组关联映射</li><li>替换：随机替换</li></ul></li><li>主存中的页表相应地称之为“慢表”</li></ul></li><li>CPU访存<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac12%e8%ae%b2-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8/image-20231215203705409.png" alt="image-20231215203705409" style="zoom:67%;" /></div></li><li>TLB、页表、Cache 的缺失组合<div align="center"><img src="https://sprooc.github.io/2023/12/15/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac12%e8%ae%b2-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8/image-20231215204207927.png" alt="image-20231215204207927" style="zoom:45%;" /></div></li></ul></li></ol><h3 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h3><ol><li>将程序和数据分成不同长度的段，将所需的段加载到主存中</li><li>虚拟地址：段号+ 段内偏移量</li><li>与分页式虚拟存储器相比<ul><li>分页式虚拟存储器（页对程序员不可见）<ul><li>优点：实现简单、开销少</li><li>缺点：一个数据或一条指令可能会分跨在两个页面</li></ul></li><li>分段式虚拟存储器（段对程序员可见）<ul><li>优点：段的分界与程序的自然分界相对应，易于编译、管理、修改和保护</li><li>缺点：段的长度不固定（引起碎片）</li></ul></li></ul></li></ol><h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><ol><li>将程序和数据分段，段内再进行分页<ul><li>每个分段都有一个页表</li></ul></li><li>虚拟地址：段号+ 页号+ 页内偏移量</li><li>优点：程序按段实现共享与保护</li><li>缺点：需要多次查表</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第11讲-冗余磁盘阵列</title>
      <link href="/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC11%E8%AE%B2-%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
      <url>/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC11%E8%AE%B2-%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="第11讲-冗余磁盘阵列"><a href="#第11讲-冗余磁盘阵列" class="headerlink" title="第11讲-冗余磁盘阵列"></a>第11讲-冗余磁盘阵列</h2><span id="more"></span><h3 id="RAID简介"><a href="#RAID简介" class="headerlink" title="RAID简介"></a>RAID简介</h3><ol><li>冗余磁盘阵列/独立磁盘冗余阵列：Redundant Arrays of Independent Disks (RAID)</li><li>基本思想<ul><li>将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量</li><li>将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率</li><li>采用数据冗余来进行错误恢复以提高系统可靠性</li></ul></li><li>特性<ul><li>由一组物理磁盘驱动器组成，被视为单个逻辑驱动器。</li><li>数据是分布在多个物理磁盘上，分布方案称为条带。</li><li>冗余磁盘容量用于存储奇偶校验信息，保证磁盘万一损坏时能恢复数据。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214210403441.png" alt="image-20231214210403441" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><ol><li>数据以条带的形式在可用的磁盘上分布</li><li>不采用冗余来改善性能（不是RAID 家族中的真正成员）</li><li>用途<ul><li>高数据传输率</li><li>高速响应I/O 请求：两个I/O 请求所需要的数据块可能在不同的磁盘上.如果条的大小相对较大，那么单个IO请求只涉及单个磁盘访问，则多个等待的IO请求就可以被并行处理，减少了每个请求的排队时间。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211106615.png" alt="image-20231214211106615" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><ol><li>采用了数据条带，采用简单地备份所有数据的方法来实现冗余。</li><li>优点<ul><li>高速响应I/O 请求：即便是同一个磁盘上的数据块，也可以由两组硬盘分别响应。</li><li>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以选择寻道时间较小的那个。</li><li>写请求需要更新两个对应的条带：可以并行完成，但受限于写入较慢的磁盘。</li><li>单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单。</li></ul></li><li>缺点<ul><li>价格昂贵（一半的容量）。</li></ul></li><li><p>用途</p><ul><li>只限于用在存储系统软件、数据和其他关键文件的驱动器中</li><li>与RAID 0 相比<ul><li>如果有大批的读请求，则RAID 1 能实现高速的I/O 速率，性能可以达到RAID 0<br>的两倍</li><li>如果I/O 请求有相当大的部分是写请求，则它不比RAID 0 的性能好多少<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211547297.png" alt="image-20231214211547297" style="zoom:80%;" /></div></li></ul></li></ul></li><li><p>RAID 01 vs. RAID 10</p><ul><li>RAID 01= RAID 0+1：先做RAID 0，再做RAID 1</li><li>RAID 10= RAID 1+0：先做RAID 1，再做RAID 0</li><li>两者在数据传输率和磁盘利用率上没有明显区别，主要区别是对磁盘损坏的容错能力</li><li>若Disk 0 和Disk 1 坏掉<ul><li>RAID 01：两个RAID 0均无法工作，整个体统无法工作。</li><li>RAID 10：两个RAID 1失去了校验功能，但仍可读写信息，系统可以正常工作。<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214211853938.png" alt="image-20231214211853938" style="zoom:67%;" /></div></li></ul></li></ul></li></ol><h3 id="RDIA-2"><a href="#RDIA-2" class="headerlink" title="RDIA 2"></a>RDIA 2</h3><ol><li>采用并行存取技术</li><li>目标:所有磁盘都参与每个I/O 请求的执行</li><li>特点<ul><li>各个驱动器的轴是同步旋转的，因此每个磁盘上的每个磁头在任何时刻都位于同一位置</li><li>采用数据条带：条带非常小，经常只有一个字节或一个字</li></ul></li><li>纠错：对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码），校验码存储在该条带中多个校验盘的对应位置</li><li>访问<ul><li>读取：获取请求的数据和对应的校验码</li><li>写入：所有数据盘和校验盘都被访问</li></ul></li><li>缺点<ul><li>冗余盘依然比较多，价格较贵</li><li>适用于多磁盘易出错环境，对于单个磁盘和磁盘驱动器已经具备高可靠性的情况没有意义（实际基本弃用）<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214213556398.png" /></div></li></ul></li></ol><h3 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h3><ol><li>采用并行存取技术<ul><li>各个驱动器的轴同步旋转</li><li>采用非常小的数据条带</li></ul></li><li>校验：对所有数据盘上同一位置的数据计算奇偶校验码<ul><li>当某一磁盘损坏时，可以用于重构数据𝑏<sub>0</sub>= 𝑃(𝑏) ⨁ 𝑏<sub>1</sub> ⨁ 𝑏<sub>2</sub> ⨁ 𝑏<sub>3</sub></li></ul></li><li>优点：能够获得非常高的数据传输率，对于大量读请求，性能改善特别明显</li><li>缺点：一次只能执行一个I/O 请求，在面向多个IO 请求时，性能将受损<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220525181.png" /></div></li></ol><h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h3><ol><li>采用独立存取技术<ul><li>每个磁盘成员的操作是独立的，各个I/O 请求能够并行处理</li><li>采用相对较大的数据条带（常见的是4KB） </li></ul></li><li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</li><li>性能<ul><li>当执行较小规模的I/O 写请求时，RAID 4 会遭遇写损失<ul><li>对于每一次写操作，阵列管理软件不仅要修改用户数据，而且要修改相应的校验位<br>𝑃’(𝐵) =  𝑃(𝐵)⨁𝐵<sub>0</sub>⨁ 𝐵’<sub>0</sub></li></ul></li><li>当涉及所有磁盘的数据条带的较大I/O 写操作时，只要用新的数据位来进行简单的计算即可得到奇偶校验位</li><li>每一次写操作必须涉及到唯一的校验盘，校验盘会成为瓶颈（实际基本弃用）<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220514240.png" alt="image-20231214220514240" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><ol><li>与RAID 4 组织方式相似（常用）</li><li>在所有磁盘上都分布了奇偶校验条带<ul><li>避免潜在的I/O 瓶颈问题</li></ul></li><li><p>访问时的“两读两写”：读在写前，读写不需要并行<br>  𝑃’(𝐵) =  𝑃(𝐵)⨁𝐵<sub>0</sub>⨁ 𝐵’<sub>0</sub></p><div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214220725519.png" alt="image-20231214220725519" style="zoom:80%;" /></div></li><li><p>RAID 50</p><ul><li>RAID 5 与RAID 0 的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5 彼此构成条带访问</li><li>RAID 50 在底层的任一组或多组RAID 5 中出现1 颗硬盘损坏时，仍能维持运作；如果任一组RAID 5 中出现2 颗或2 颗以上硬盘损毁，整组RAID 50 就会失效</li><li>RAID 50 由于在上层把多组RAID 5 进行条带化，性能比起单纯的RAID 5 高，但容量利用率比RAID 5 要低<div align="center"><img src="https://sprooc.github.io/2023/12/14/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac11%e8%ae%b2-%e5%86%97%e4%bd%99%e7%a3%81%e7%9b%98%e9%98%b5%e5%88%97/image-20231214221752126.png" alt="image-20231214221752126" style="zoom:80%;" /></div></li></ul></li></ol><h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><ol><li>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</li><li>优点：提升数据可用性：只有在平均修复时间间隔内3 个磁盘都出了故障，才会造成数据丢失</li><li>缺点：写损失：每次写都要影响两个校验块（读3 个写3 个磁盘）</li></ol><h3 id="RAID比较"><a href="#RAID比较" class="headerlink" title="RAID比较"></a>RAID比较</h3><ol><li>RAID 0：提升I/O 响应能力，但数据可用性低</li><li>RAID 1：提升数据可用性，但容量利用率低</li><li>RAID 2和 RAID3：提升数据可用性和数据传输率，但一次只能处理一个I/O 请求</li><li>RAID 4和 RAID 5 和 RAID 6：提升数据可用性和读速率，但写速率受限</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第10讲-数据校验码</title>
      <link href="/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC10%E8%AE%B2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
      <url>/2023/12/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC10%E8%AE%B2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="第10讲-数据校验码"><a href="#第10讲-数据校验码" class="headerlink" title="第10讲-数据校验码"></a>第10讲-数据校验码</h2><span id="more"></span><h3 id="差错（Error）"><a href="#差错（Error）" class="headerlink" title="差错（Error）"></a>差错（Error）</h3><ol><li>数据在计算机内部进行计算、存取和传送过程中，由于元器件故障或噪音干扰等原因，会出现差错</li><li>以存储为例<ul><li>硬故障（hard failure）：永久性的物理故障，以至于受影响的存储单元不能可靠地存储数据，成为固定的“1”或“0”故障，或者在0 和1之间不稳定地跳变。由恶劣的环境、制造缺陷和旧损引起</li><li>软故障（soft error）：随机非破坏性事件，它改变了某个或某些存储单元的内容，但没有损坏机器。由电源问题或α 粒子引起</li></ul></li><li>解决方案<ul><li>从计算机硬件可靠性入手，在电路、电源、布线等方面采取必要的措施，提高计算机的抗干扰能力</li><li>采取数据检错和校正措施，自动发现并纠正错误</li></ul></li></ol><h3 id="纠错（Error-Correction）"><a href="#纠错（Error-Correction）" class="headerlink" title="纠错（Error Correction）"></a>纠错（Error Correction）</h3><ol><li>基本思想：存储额外的信息以进行检错和校正</li><li>处理过程<ul><li>数据输入：使用函数𝑓在𝑀位数据𝐷上生成𝐾位校验码𝐶</li><li>数据输出：使用函数𝑓在𝑀位数据𝐷 上生成新的𝐾位代码𝐶”，并与取出的𝐾位码𝐶 进行比较<ul><li>没有检测到差错：使用数据𝐷</li><li>检测到差错且可以校正：校正数据𝐷 来生成数据𝐷”，并用数据𝐷</li><li>检测到差错但无法纠正：报告</li></ul></li></ul></li></ol><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ol><li><p>基本思想：增加1 位校验码来表示数据中1 的数量是奇数还是偶数</p><ul><li>奇校验：使传输的数据（数据位 校验位）中有奇数个1</li><li>偶校验：使传输的数据（数据位 校验位）中有偶数个1</li></ul></li><li><p>处理过程</p><ul><li>假设数据为𝐷<sub>𝑀</sub> … 𝐷<sub>2</sub> 𝐷<sub>1</sub>     </li><li>数据输入<ul><li>奇校验：𝐶 = 𝐷<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷<sub>2</sub> $\bigoplus$  𝐷<sub>1</sub>$\bigoplus$1</li><li>偶校验：𝐶 = 𝐷<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷<sub>2</sub> $\bigoplus$  𝐷<sub>1</sub>       </li></ul></li><li>数据输出<ul><li>奇校验：𝐶’ = 𝐷’<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷’<sub>2</sub> $\bigoplus$  𝐷’<sub>1</sub>$\bigoplus$1</li><li>偶校验：𝐶’ = 𝐷’<sub>𝑀</sub> $\bigoplus$ … $\bigoplus$𝐷’<sub>2</sub> $\bigoplus$  𝐷’<sub>1</sub>       </li></ul></li><li>检错：S = 𝐶′$\bigoplus$′ 𝐶′       <ul><li>𝑆=0：正确/数据中出错的位数为偶数       </li><li>𝑆=1：数据中出错的位数为奇数       </li></ul></li><li>优点：代价低（只需要1 位额外数据，计算简单）</li><li>缺点：不能发现出错位数为偶数的情形；发现错误后不能校正。<ul><li>适用于对较短长度（如1 字节）的数据进行检错</li></ul></li></ul></li></ol><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><ol><li>基本思想：将数据分成几组，对每一组都使用奇偶校验码进行检错</li><li>处理过程<ul><li>将𝑀位数据分成𝐾组</li><li>数据输入：为数据𝐷中每组生成1 位校验码，合并得到𝐾位校验码𝐶</li><li>数据输出：为数据𝐷 中每组生成1 位校验码，合并得到新的𝐾位校验码𝐶</li><li>检错：将校验码𝐶 和取出的校验码C’ 按位进行异或，生成𝐾位故障字（syndrome word）</li></ul></li><li>校验码长度<ul><li>假设最多1 位发生错误</li><li>可能的差错<ul><li>数据中有1 位出现错误：𝑀</li><li>校验码中有1 位出现错误：𝐾</li><li>没有出现错误：1</li></ul></li><li>校验码的长度：2<sup>𝐾</sup> &gt;𝑀+ 𝐾+1<br><img src="image-20231214142811606.png" alt="image-20231214142811606" style="zoom:67%;" />   </li><li>故障字的作用<ul><li>每种取值都反映一种情形（数据出错/校验码出错/未出错）</li><li>规则<ul><li>全部是0：没有检测到错误</li><li>有且仅有1 位是1：错误发生在校验码中的某一位，不需要纠正</li><li>有多位为1：错误发生在数据中的某一位，将𝐷 中对应数据位取反即可纠正（得到𝐷”）</li></ul></li></ul></li><li>数据位划分<ul><li>假定数据位为8位𝐷 = 𝐷8 … 𝐷2𝐷1, 校验码为4位𝐶 = 𝐶4𝐶3𝐶2𝐶1</li><li>数据位/校验码与故障字的关系</li><li>数据位划分<br>𝐶1 = 𝐷1 ⊕ 𝐷2 ⊕ 𝐷4 ⊕ 𝐷5 ⊕ 𝐷7<br>𝐶2 = 𝐷1 ⊕ 𝐷3 ⊕ 𝐷4 ⊕ 𝐷6 ⊕ 𝐷7<br>𝐶3 = 𝐷2 ⊕ 𝐷3 ⊕ 𝐷4 ⊕ 𝐷8<br>𝐶4 = 𝐷5 ⊕ 𝐷6 ⊕ 𝐷7 ⊕ 𝐷8<br><img src="1349b08cd70575e934a3476e41fbb69.png" alt="1349b08cd70575e934a3476e41fbb69" style="zoom:50%;" /></li></ul></li></ul></li></ol><h3 id="码距和纠错理论"><a href="#码距和纠错理论" class="headerlink" title="码距和纠错理论"></a>码距和纠错理论</h3><ol><li>码距：同一编码中，任意两个合法编码之间不同二进制数位数的最小值<ul><li>{0000, 0001, 0010, 0011} 码距为1</li><li>{0000,0011} 码距为2 </li></ul></li><li>纠错理论：𝑳 - 𝟏 = 𝑫 + 𝑪 <ul><li>𝐿是码距，𝐷 是检错位数，𝐶 是纠错位数</li><li>奇偶校验的码距是2，1 位能检错，不能纠错</li><li>海明码的码距是3，1 位能检错和纠错</li></ul></li></ol><h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><ol><li>奇偶校验问题：额外成本很大；要求将数据分成字节</li><li>循环冗余校验（Cyclic Redundancy Check, CRC）<ul><li>适用于以流格式存储和传输大量数据</li><li>用数学函数生成数据和校验码之间的关系</li></ul></li><li>基本思想：假设数据有M 位，左移数据K 位（右侧补00），并用K+1 位生成多项式除它（模2 运算）<ul><li>采用K 位余数作为校验码</li><li>把校验码放在数据（不含补的00）后面，一同存储或传输。</li></ul></li><li>校错：如果M+K 位内容可以被生成多项式除尽，则没有检测到错误；否则，发生错误。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第9讲-外部存储器</title>
      <link href="/2023/12/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC9%E8%AE%B2-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC9%E8%AE%B2-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第9讲-外部存储器"><a href="#第9讲-外部存储器" class="headerlink" title="第9讲-外部存储器"></a>第9讲-外部存储器</h2><span id="more"></span><h4 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h4><ol><li>特性：用于存储不经常使用的、数据量较大的信息；非易失。</li><li>类型：<ul><li>磁盘存储器（magnetic disk disk）</li><li>光存储器（optical memory memory）</li><li>磁带（magnetic tape tape）</li><li>U盘（USB flash disk disk）</li><li>固态硬盘（solid state disk disk，SSD）</li></ul></li></ol><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><ol><li>磁盘是由涂有可磁化材料的非磁性材料（基材）构成的圆形盘片<ul><li>基材：铝、铝合金、玻璃</li><li>玻璃基材的优势（稳定可靠、为存储更多信息提供基础）<ul><li>改善磁膜表面的均匀性，提高磁盘的可靠性</li><li>显著减少整体表面瑕疵，以帮助减少读写错误</li><li>能够支持（磁头）较低的飞行高度</li><li>更高的硬度，使磁盘转动时更加稳定</li><li>更强的抗冲击和抗损伤能力</li></ul></li></ul></li><li>类型：硬盘、软盘</li><li>磁头：对盘片进行读写操作的装置<ul><li>磁盘存储器每个盘片表面有一个读写磁头，所有磁头通过机械方式固定在一起，同时移动。在任何时候，所有磁头都位于距磁盘中心等距离的磁道上。</li><li>磁头必须产生或感应足够大的电磁场，以便正确地读写</li><li>磁头越窄，电磁感应能力越弱，离盘片的距离就越近</li><li>更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</li><li>硬盘必须密封</li><li>温彻斯特磁头（Winchester head head）<ul><li>磁头实际上是一个空气动力箔片，当磁盘静止时，它轻轻地停留在盘片的表面上</li><li>旋转圆盘时产生的空气压力足以使箔片上升到盘片表面上方<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e20e1bd3a341940ab123750d324233a.png" alt="e20e1bd3a341940ab123750d324233a" style="zoom: 80%;" /></div></li></ul></li></ul></li><li>读写机制<ul><li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li><li>磁头的数量<ul><li>单磁头：读写公用同一个磁头（软盘、早期硬盘）</li><li>双磁头：使用一个单独的磁头进行读写（当代硬盘）</li></ul></li><li>写入机制<ul><li>电流脉冲被发送到写入磁头</li><li>变化的电流激发出磁场</li><li>产生的磁性图案被记录在下面的盘片表面上</li><li>反转电流方向，则记录介质上的磁化方向也会反转，由此区分0和1</li></ul></li><li>读取机制<ul><li>旧的磁盘系统使用单磁头，当磁盘在磁头下方旋转时，会产生与记录的磁极相同的电流，根据电流方向读取数据。</li><li>现代磁盘用单独的读磁头<ul><li>读取磁头是由一个部分屏蔽的磁阻（MRMR）敏感器组成，其电阻取决于在其下移动的介质的磁化方向</li><li>恒定电流通过MR 敏感器时，通过电压信号检测其电阻变化</li><li>MR传感器允许更高频率的操作，实现更高的存储密度和更快的操作速度<br><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/bcb749bfc52178b14ab2f9ae805d7f6.png" alt="bcb749bfc52178b14ab2f9ae805d7f6"></li></ul></li></ul></li></ul></li><li>数据组织<ul><li>盘片上的数据组织呈现为一组同心圆环，称为<strong>磁道</strong>（track）。</li><li>数据以<strong>扇区</strong>（sector）的形式传输到磁盘或从传出磁盘（一般为512字节）。</li><li>相邻磁道之间有间隙（gap），相邻的扇区之间也留有间隙，否则磁场容易相互影响。</li><li>磁道编号从外往里递增（0~N），磁头静止时停在磁道0 外侧。</li><li>扇区划分<ul><li>恒定角速度（Constant angular velocity, CAV)：增大记录在盘片区域上的信息位的间隔，使得磁盘能够以恒定的速度扫描信息，即恒定的数据传输率<ul><li>优点：能以磁道号和扇区号直接寻址各个数据块</li><li>缺点：磁盘存储容量受到了最内层磁道所能实现的最大记录密度的限制</li></ul></li><li>多带式记录 / 多重区域记录（Multiple zone recording）：将盘面划分为多个同心圆区域，每个区域中各磁道的扇区数量是相同的，距离中心较远的分区包含的扇区数多于距离中心较近的分区<ul><li>优点：提升存储容量</li><li>缺点：需要更复杂的电路<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/8d555856ec333a4a99944c32925294f.png" alt="8d555856ec333a4a99944c32925294f" style="zoom:80%;" /></div></li></ul></li></ul></li><li>所有盘片上处于相同的相对位置的一组磁道被称为柱面(cylinder)</li></ul></li><li>格式化<ul><li>磁道必须有一些起始点和辨别每个扇区起点及终点的方法</li><li>格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取的额外数据<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213204908276.png" alt="image-20231213204908276" style="zoom:40%;" /></div></li><li>低级格式化/物理格式化：创建硬盘扇区（sector）使硬盘具备存储能力的操作<ul><li>清除数据（如果硬盘分过区，所有区都会被清除）</li><li>有损：是一种损伤性操作，它对硬盘寿命有影响</li><li>建议场景：硬盘受到外部强磁体、强磁场的影响而受到物理性损伤的情况</li></ul></li><li>高级格式化 逻辑格式化：根据用户选定的文件系统（如FAT12 、FAT16 、FAT32 、exFAT 、NTFS 、EXT2 、EXT3 等），在磁盘的特定区域写入特定数据，以达到初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作<ul><li>快速格式化：会删除目标磁盘上原有的文件分配表和根目录，不检测坏道，不备份数据，它格式化的速度很快，但不是很稳定。</li><li>一般 完全格式化：会清除目标磁盘上的所有的数据（非物理的）。重新生成引导信息、初始化文件分配表、标注逻辑坏道，一样不备份数据。</li></ul></li></ul></li><li>I/O访问时间<ul><li>寻道时间（seek time time）：初始启动时间，以及当访问臂达到速度后，遍历需跨越的磁道所需花费的时间。不是线性函数，而是包含了建立时间（把磁头放置到目标磁道之后，直到确认磁道标识的时间）。</li><li>旋转延迟（rotational delay delay）：等待响应扇区的起始处到达磁头所需的时间<ul><li>通常是磁道旋转半周所需的时间</li></ul></li><li>传送时间（transfer time time）：数据传输所需的时间，取决于磁盘的旋转速度。<br>T = 传送时间，b = 传送字节数，N = 每磁道的字节数，r = 旋转速率，单位是转/秒。<script type="math/tex; mode=display">T=\frac{b}{r N}</script></li><li>平均访问时间(T<sub>s</sub>是平均寻道时间)<script type="math/tex; mode=display">T_{a}=T_{S} + \frac{1}{2r}+\frac{b}{rN}</script></li><li>当连续访问多个相邻的磁道时，跨越磁道：<ul><li>对于每个磁道都需要考虑旋转延迟</li><li>通常只需要考虑第一个磁道的寻道时间，但在明确知道跨越每个磁道需要的时间时需要考虑</li></ul></li></ul></li><li>磁头寻道/磁盘调度<ul><li>目标：当有多个访问磁盘任务时，使得平均寻道时间最小。</li><li>常见的磁头寻道 磁盘调度算法<ul><li>先来先服务（First Come First Service Service，FCFSFCFS）</li><li>最短寻道时间优先（Shortest Seek Time First First，SSTFSSTF）</li><li>扫描/电梯（SCANS）</li><li>LOOK</li><li>循环扫描（C-SCAN）</li><li>C-LOOK</li></ul></li><li>先来先服务（FCFSFCFS）<ul><li>按照请求访问磁盘的先后次序进行处理</li><li>优点：公平简单</li><li>缺点：如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性能上很差，寻道时间长</li></ul></li><li>最短寻道时间优先（SSTF）<ul><li>优先处理起始位置与当前磁头位置最接近的读写任务</li><li>优点：每次的寻道时间最短（局部最优），平均寻道时间缩短</li><li>缺点：可能产生饥饿现象，尤其是位于两端的磁道请求</li></ul></li><li>扫描/电梯（SCAN）<ul><li>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</li><li>优点：性能较好，平均寻道时间短，不会产生饥饿现象</li><li>缺点：只有到最边上的磁道才能改变磁头的移动方向，对于各个位置磁道响应频率不平均</li></ul></li><li>循环扫描（C-SCAN）<ul><li>只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不做任何处理</li><li>优点：与SCAN 算法相比，对于各位置磁道的响应频率平均</li><li>缺点：与SCAN 算法相比，平均寻道时间更长</li></ul></li><li>LOOK<ul><li>SCAN算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的方向</li></ul></li><li>C-LOOK<ul><li>C-SCAN 算法的改进，只要在磁头移动方向上不再有请求，就立即让磁头返回起</li></ul></li></ul></li></ol><h4 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h4><ol><li><p>光存储器产品</p><ul><li>光盘（Compact disk，CD）</li><li>光盘只读存储器（CD read only memory，CD-ROM）</li><li>可刻录光盘（CD recordable，CD-R）</li><li>可重写光盘（CD rewritable，CD-RW）</li><li>数字多功能光盘（digital versatile disk，DVD）</li><li>可刻录DVD（DVD recordable，DVD-R）</li><li>可重写DVD（DVD rewritable，DVD-RW）</li><li>高清晰视频光盘（High definition video disk，Blu Ray DVD）<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213212222255.png" alt="image-20231213212222255" style="zoom:67%;" /></div></li></ul></li><li><p>CD和CD-ROM</p><ul><li>CD和CD-ROM 采用类似的技术，但CD-ROM 更加耐用且有纠错功能</li><li>制造方法<ul><li>用精密聚焦的高强度激光束制造一个母盘</li><li>以母盘作为模板压印出聚碳酸酯的复制品</li><li>在凹坑表面上镀上一层高反射材料（一般采用铝，HQCD 采用银合金）</li><li>使用丙烯酸树脂保护高反射材料</li><li>在丙烯酸树脂层上用丝网印刷术印制标签</li></ul></li><li>通过安装在光盘播放器或驱动装置内的低强度激光束从CD 或CD ROM 处读取信息<ul><li>如果激光束照在凹坑（pit）上，由于凹坑表面有些不平，因此光被散射，反射回低强度的激光</li><li>如果激光束照在台 面（land）上，台的表面光滑平坦，反射回来的是高强度的激光</li><li>光电传感器检测凹坑和台之间的变化，凹坑的起点或终点代表“11”，没有高度变化则记为“00”。</li></ul></li><li>盘片上包含一条单螺旋的轨道，轨道上的所有扇区长度相同<ul><li>从内向外扫描，角速度逐渐变小</li><li>凹坑被激光以恒定线速度读出<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/3d2877d801e717f0a82870495705abe.png" alt="3d2877d801e717f0a82870495705abe" style="zoom:80%;" />    </div></li></ul></li><li>优点<ul><li>存储有信息的光盘可以廉价地进行大规模复制</li><li>光盘更换方便</li><li>寿命长       </li></ul></li><li>缺点<ul><li>它是只读的，不能更改</li><li>其存取时间比磁盘存储器慢得多</li></ul></li></ul></li><li>CD-R（写一次）<ul><li>包含了一个染色层，用于改变反射率，并且由高强度激光激活</li><li>生成的盘既能在 CD R 驱动器上也能在CD ROM 驱动器上读出</li></ul></li><li>CD-RW（写多次）<ul><li>使用了一种在两种不同相位状态下有两种显著不同反射率的材料，激光束能改变这种材料的相位状态</li><li>材料老化最终会永久失去相位可变的特性，当前的材料可用于50 万次到100 万次的擦除</li></ul></li><li>数字多功能光盘（DVD）<ul><li>DVD vs.CD<ul><li>DVD上的位组装更紧密：光道间隙，凹坑间距（容量达到4.7GB）</li><li>DVD采用双层结构：设有半反射层，可以通过调整焦距读取每一层（容量达到8.5GB）</li><li>DVD-ROM 可以用两面记录数据（容量达到17GB17GB）</li><li>DVD的激光束更细，所以能读DVD 的设备可以读CDCD，但反过来不行</li></ul></li><li>DVD-R 和DVD-RW</li></ul></li><li>高清晰光盘<ul><li>通过使用更短波长的激光（在蓝 紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li></ul></li></ol><h4 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h4><ol><li>使用与磁盘类似的记录和读取技术</li><li>记录：介质是柔韧的聚酯薄膜带，外涂磁性材料</li><li>读取<ul><li>磁带：顺序读取（sequential access）</li><li>磁盘：直接读取（direct access）</li><li>并行记录 vs. 串行记录（蛇形记录）</li><li>并行+串行<div align="center"><img src="https://sprooc.github.io/2023/12/13/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac9%e8%ae%b2-%e5%a4%96%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231213220640293.png" alt="image-20231213220640293" style="zoom:67%;" /></div></li></ul></li></ol><h4 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h4><ol><li>U盘（USB flash disk disk）<ul><li>采用了快闪存储器，属于非易失性半导体存储器</li><li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li></ul></li><li>固态硬盘（Solid State Disk/Drive Drive）<ul><li>与U 盘没有本质区别：容量更大，存储性能更好</li><li>与硬磁盘存储器相比：抗振性好，无噪声，能耗低，发热量低</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第8讲-高速缓冲存储器</title>
      <link href="/2023/12/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC8%E8%AE%B2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/12/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC8%E8%AE%B2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第8讲-高速缓冲存储器"><a href="#第8讲-高速缓冲存储器" class="headerlink" title="第8讲-高速缓冲存储器"></a>第8讲-高速缓冲存储器</h2><span id="more"></span><h3 id="Cache的目的和基本思路"><a href="#Cache的目的和基本思路" class="headerlink" title="Cache的目的和基本思路"></a>Cache的目的和基本思路</h3><ol><li>问题：CPU的速度比内存的速度快，且两者差距不断扩大—内存墙。</li><li>解决：CPU和内存之间增加Cache。<ul><li>解决内存墙带来的CPU和主存协作问题</li><li>在使用主存（相对大而慢）之余，添加一块小而快的cache</li><li>Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块</li><li>Cache中存放了主存中的部分信息的“副本”</li></ul></li></ol><p><img src="74050a5ff91819f99d4608f61d2be55.png" alt="74050a5ff91819f99d4608f61d2be55" style="zoom:75%;" /></p><h3 id="Cache的工作流程"><a href="#Cache的工作流程" class="headerlink" title="Cache的工作流程"></a>Cache的工作流程</h3><ol><li><p>检查（Check）：当CPU试图访问主存中的某个字时，首先检查这个字是否在cache中</p></li><li><p>检查后分两种情况处理：</p><ul><li>命中（Hit）：如果在cache中，则把这个字传送给CPU</li><li>未命中（Miss）：如果不在cache中, 则将主存中包含这个字固定大小的块（block）读入cache中，然后再从cache传送该字给CPU</li></ul></li><li><p>如何判断是命中还是未命中?</p><ul><li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li></ul></li><li><p>局部性原理</p><ul><li>定义：处理器频繁访问主存中相同位置或者相邻存储位置的现象。</li><li>时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同存储位置的信息）</li><li>空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据<ul><li>顺序局部性：当数据被线性排列和访问时，出现的空间局部性的一种<br>特殊情况</li><li>例如：遍历一维数组中的元素</li></ul></li><li>利用“时间局部性”：将未命中的数据在返回给CPU的同时存放在Cache中，以便再次访问时命中。</li><li>利用“空间局部性”：将包含所访问的字的块存储到Cache中，以便在访问相邻数据时命中。</li></ul></li><li><p>平均访问时间</p><ul><li>假设p是命中率， 𝑇<sub>c</sub> 是cache的访问时间， 𝑇<sub>M</sub> 是主存的访问时间，使用cache时的<br>平均访问时间𝑇<sub>A</sub>为<script type="math/tex; mode=display">𝑇_{A} = 𝑝×𝑇_{C} + (1 − 𝑝) × (𝑇_{C} + 𝑇_{M})= 𝑇_{C} + (1 − 𝑝)×𝑇_{M}</script></li><li>命中率p越大， 𝑇<sub>c</sub>越小， 效果越好。</li><li>如果想要𝑇<sub>A</sub>&lt; 𝑇<sub>M</sub>, 必须要求p&gt;𝑇<sub>C</sub> /𝑇<sub>M</sub>。</li><li>难点：cache的容量远远小于主存的容量（随机访问时𝑝 = Cache容量/主存容量）</li></ul></li><li><p>Cache未命中的原因</p><ol><li>义务失效（Compulsory Miss）/ 冷启动失效（Cold Start Miss）<ul><li>第一次访问一个块时</li><li>例如：第一次访问一个数组，会发生义务失效</li></ul></li><li>容量失效（Capacity Miss）<ul><li>Cache无法保存程序访问所需的所有数据块，则当某数据块被替换后，又重新被访问，则发生失效</li><li>例如： cache大小为8KB，如果需要重复访问一个16KB大小的数组，数组无法全部放入cache，会发生容量失效</li></ul></li><li>冲突失效（Conflict Miss）<ul><li>多个存储器位置映射到同一Cache位置</li><li>例如：有两个4KB大小的数组都映射到了相同的地址，需要来回访问，则发生冲突失效</li></ul></li></ol></li></ol><h3 id="Cache的设计要素"><a href="#Cache的设计要素" class="headerlink" title="Cache的设计要素"></a>Cache的设计要素</h3><h4 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h4><ol><li>实现主存块到cache行的映射</li><li>块号，块内地址</li><li>映射方式的选择会影响cache的组织结构<ul><li>直接映射</li><li>关联映射</li><li>组关联映射</li></ul></li><li>直接映射<ul><li>把每个主存块映射到唯一可能得高速缓存行。<script type="math/tex; mode=display">i = j\mod m</script>其中：i=高速缓存行号，j=主存块号，m=高速缓存行数</li><li>优点：简单且便宜</li><li>缺点：对任何给定的块都只有固定的高速缓存位置。因此，如果一个程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断地被交换到cache中，cache的命中率将会降低，即发生冲突失效。称为抖动现象。</li><li>适合大容量cache：行数变多，发生冲突失效的概率降低； 硬件电路简单，增大容量对𝑇<sub>c</sub>的影响不明显</li><li>地址计算：<ul><li>地址长度 =（s+w）位</li><li>块大小 =  行大小 = 2<sup>w</sup></li><li>主存中块的数量 = 2<sup>s</sup></li><li>Cache中的行数 = m = 2<sup>r</sup></li><li>Cache容量 = 行大小 * 行数 = 2<sup>w+r</sup></li><li>标记长度 = s - r</li><li>Cache行号长度 = r</li><li>块内地址长度 = w</li></ul></li></ul></li></ol><p><img src="eb4b064e6488289e1eafa9b63784dab-17023862155193.png" alt="eb4b064e6488289e1eafa9b63784dab"></p><ol><li>关联映射（全相联映射）<ul><li>允许每个主存块加载到任何高速缓存行</li><li>优点：避免抖动。</li><li>缺点：实现复杂；搜索代价大。</li><li>适合容量较小的Cache：小容量更容易发生冲突失效；小容量检查的时间短。</li><li>地址计算：<ul><li>地址长度 = （s + w）位</li><li>标记长度 = s</li><li>快内地址长度 = w</li></ul></li></ul></li></ol><p><img src="ccd0f4d2f8dd8ee56fa0a949f118f48.png" alt="ccd0f4d2f8dd8ee56fa0a949f118f48"></p><ol><li><p>组关联映射</p><ul><li>一种折中方案，结合了直接映射和关联映射的优点和缺点。</li><li>k路组相联映射<script type="math/tex; mode=display">m=v\times k</script><script type="math/tex; mode=display">i=j \mod v</script>其中，i=cache组号，j=主存块号，v=cache组数，m=cache行数，k=每组行数。</li><li>地址计算<ul><li>地址长度 = （s+w）位</li><li>组中行数 = k</li><li>组数 = v = 2<sup>d</sup></li><li>Cache中行数 = m = k*v</li><li>标记长度 = s - d</li><li>组号长度 = d </li><li>块内地址长度 = w<img src="《计算机组织结构》期末复习-第8讲-高速缓冲存储器/5ba3c5f66e0dde4ee4c57550709aa73.png" alt="5ba3c5f66e0dde4ee4c57550709aa73" style="zoom:67%;" /></li></ul></li></ul></li><li><p>三种映射方式比较</p><ul><li>关联度（Correlation）：一个主存块映射到cache中可能存放的位置个数<ul><li>直接映射：1</li><li>关联映射：m</li><li>组关联映射：k</li></ul></li><li>关联度越低，命中率越低，</li><li>关联度越低，判断是否命中的时间越短。</li><li>关联度越低，标记所占额外空间开销越小。</li></ul></li></ol><h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4><ol><li>一旦cache行被占用，当新的数据块装入cache中时，原先存放的数据块将会被替换掉。</li><li>对于直接映射，每个数据块都只有唯一对应的行可以放置，没有选择的机会。</li><li>对于关联映射和组关联映射，每个数据块被允许在多个行中选择一个进行放置，就需要替换算法来决定替换哪一行中的数据块</li><li>常用替换策略：<ul><li>最近最少使用算法（Least Recently Used, LRU）</li><li>先进先出算法（First In First Out, FIFO）</li><li>最不经常使用算法（Least Frequently Used, LFU）</li><li>随机替换算法（Random）</li></ul></li><li>最近最少使用算法（LRU）<ul><li>替换掉在cache中最长时间未被访问的数据块。</li><li>实现：每个cache行添加LRU位，长度为log<sub>2</sub>k位。<ul><li>命中时，被访问的行的计数器清零，比其低的计数器加 1，其余不变。</li><li>未命中且该组还有空闲行时，则新装入的行的计数器设为0，其余全加1。</li><li>未命中且该组无空闲行时，计数值最大的那一行中的主存块被淘汰新装入的行的计数器设为0，其余加1。从计数器变化规则可以看出，计数值越高的行中的主存块越是最近最少用。</li></ul></li><li>缺点：当程序中的分块局部化范围(即程序中某段时间集中访问的存储区)超过了 cache 组的大小时，命中率可能变得很低。例如，假设上述例子中的访存地址流是1，2，3，4，1，2，3，4，1，2，34而cache每组只有3行，那么命中率为0。这种现象称为颠簸(pingpong)或抖动(thrashing)</li></ul></li><li>先进先出算法（FIFO）<ul><li>策略：替换掉在Cache中停留时间最长的块。</li><li>实现：时间片轮转法或环形缓冲技术。<ul><li>每行包含<strong>一</strong>个标识位</li><li>当同一组中的某行被替换时，将其标识位设为1，同时将其下一行的标识位设为0</li><li>如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为0</li><li>当将新的数据块读入该组时，替换掉标识位为0的行中的数据块</li></ul></li></ul></li><li>最不经常使用算法（LFU）<ul><li>策略：替换掉cache中被访问次数最少的数据块。</li><li>实现：为每一行设置计数器</li></ul></li><li>随机替换算法（Random）<ul><li>策略：随机替换cache中的数据块</li><li>实现：随机替换</li><li>性能上只稍逊于其他算法，而且代价低。</li></ul></li></ol><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><ol><li><p>缓存命中时的写策略。当cache中的某个数据块被替换时，需要考虑该数据块是否被修改。</p><ul><li>如果没被修改，则该数据块可以直接被替换掉。</li><li>如果被修改，则在替换掉该数据块之前，必须将修改后的数据块写回到主存中对应位置。</li><li>写直达（Write Through）：所有写操作都同时对cache和主存进行。<ul><li>优点：确保主存中的数据总是和cache中的数据一致，总是最新的（例如多CPU同步的场景）。</li><li>缺点：产生大量的主存访问，减慢写操作。</li></ul></li><li>写回法（Write Back）：先更新cache中的数据，当cache中某个数据块被替换时，如果它被修改了，才被写回主存。<ul><li>利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改。</li><li>优点：减少了访问主存的次数。</li><li>缺点：部分主存数据可能不是最新的（例如未发生替换但需要读主存的场景）。</li></ul></li></ul></li><li><p>缓存未命中时的写策略。</p><ul><li>写不分配（Write Non-Allocate）：直接将数据写入主存，无需读入cache。<ul><li>优点：避免cache和主存中的数据不一致。</li><li>通常搭配：写直达。</li></ul></li><li>写分配（Write Allocate）：将数据所在的块读入cache后，在cache中更新内容。<ul><li>优点：利用了cache的高速特性，减少写内存次数。</li><li>通常搭配：写回法。</li></ul></li></ul></li></ol><h4 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h4><ol><li>假设从行的大小为一个字开始，随着行大小的逐步增大，则Cache命中率会增加<ul><li>数据块中包含了更多周围的数据，每次会有更多的数据作为一个块装入cache中</li><li>利用了空间局部性</li></ul></li><li>当行大小变得较大之后，继续增加行大小，则Cache命中率会下降<ul><li>当Cache容量一定的前提下，较大的行会导致Cache中的行数变少，导致装入cache中的数据块数量减少，进而造成数据块被频繁替换</li><li>每个数据块中包含的数据在主存中位置变远，被使用的可能性减小</li></ul></li><li>行大小与命中率之间的关系较为复杂<ul><li>行太小，行数太多反时间局部性</li><li>行太大，行数太少反空间局部性</li></ul></li></ol><h4 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h4><ol><li><p>一级v.s.多级</p><ul><li>一级<ul><li>将cache与处理器置于同一芯片（片内cache）</li><li>减少处理器在外部总线上的活动，从而减少了执行时间</li></ul></li><li>多级<ul><li>当L1未命中时，减少处理器对总线上DRAM或ROM的访问</li><li>使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2 cache结合到处理器芯片上</li></ul></li></ul></li><li><p>统一v.s.分立</p><ul><li>统一（指令数据混合式）<ul><li>更高的命中率，在获取指令和数据的负载之间自动进行平衡。</li><li>只需要设计和实现一个cache。</li></ul></li><li>分立（指令和数据分离）<ul><li>消除cache在指令的取值/译码单元和执行单元之间的竞争，在任何基于指令流水线的设计中都是重要的。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》期末复习-第7讲-内部存储器</title>
      <link href="/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第7讲-内部存储器"><a href="#第7讲-内部存储器" class="headerlink" title="第7讲-内部存储器"></a>第7讲-内部存储器</h2><span id="more"></span><h3 id="存储器（Memory）"><a href="#存储器（Memory）" class="headerlink" title="存储器（Memory）"></a>存储器（Memory）</h3><ol><li>定义：存储器（Memory）由一定数量的单元构成，每个单元可以被唯一标识，每个单元都<br>   有存储一个数值的能力<ul><li>地址：单元的唯一标识符（采用二进制）</li><li>地址空间：可唯一标识的单元总数</li><li>寻址能力：存储在每个单元中的信息的位数，即内存中能被单独识别并独立存放一个数据的最小内存空间<br>— 大多数存储器是字节（8bit）寻址的，32位计算机的最大寻址空间为4GB</li></ul></li><li>层次结构<ul><li>主板内存储器：寄存器，Cache，主存。</li><li>主板外存储器：磁盘，CD-ROM，CD-RW，DVD-RW，DVD-RAM。</li><li>离线存储器：磁带<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231211215347325.png" alt="image-20231211215347325" style="zoom:100%;" /></div></li></ul></li></ol><h3 id="AND-OR锁存器"><a href="#AND-OR锁存器" class="headerlink" title="AND-OR锁存器"></a>AND-OR锁存器</h3><p>参考文章：<a href="https://www.zhihu.com/question/373693400">谁能告诉我AND-OR锁存器原理？ - 知乎 (zhihu.com)</a><br>先解释OR锁<strong>OR锁：</strong></p><p><img src="v2-eea6e461a97e4273e93fcec13276ebba_720w-17030664435721.webp" alt="img"><br>OR门B输入和输出连接。<br>INIT为初始状态A=B=0；<br>当A=1，B=0时，OUTPUT变为1同时将B变为1；<br>此时，当A变回0，OUTPUT仍为1（被锁住）。</p><p><strong>AND锁：</strong></p><p><img src="v2-0cf2e34ec4c12654f5c11156192d7406_720w.webp" alt="img"></p><p>AND门B输入和输出连接。</p><p>INIT为初始状态A=B=1；</p><p>当A=0，B=1时，OUTPUT变为0同时将B变为0；</p><p>此时，当A变回1，OUTPUT仍为0（被锁住）。</p><p><strong>AND-OR锁存器：</strong></p><p><img src="v2-1995e8bd1afa8bd20bac2f4098ae6cce_720w.png" alt="img"></p><p>锁存器有两个输入SET和RESET，其<a href="https://www.zhihu.com/search?q=电路&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1093469618}">电路</a>如上图连接。</p><p>INIT为初始状态SET=RESET=0，最终输出OUTPUT=0；</p><p>当SET=1，RESET=0（SET激活、RESET未激活）时，将输出变为1，锁住（可看出SET变为0，结果不变）</p><p>此时RESET激活（SET=1，RESET=1），将输出重新变为0，即为重置。</p><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><ol><li>用半导体芯片作主存储器是目前的主流做法</li><li><p>位元（memory cell）</p><ul><li>半导体存储器的基本元件，用于存储1位数据</li><li>特性<ol><li>呈现两种稳态（或半稳态）：分别表示二进制的0和1</li><li>它们能够至少被写入（write）数据一次：用来设置状态</li><li>它们能够被读取（read）来获得状态信息  </li></ol></li><li>操作<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/03ce4ce3bddda304f78a7874c4fbc21.png" alt="03ce4ce3bddda304f78a7874c4fbc21" style="zoom:80%;" /></li></ul></li><li><p>半导体存储器类型</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">存储器类型</th><th style="text-align:center">种类</th><th style="text-align:center">可擦除性</th><th style="text-align:center">写机制</th><th style="text-align:center">易失性</th></tr></thead><tbody><tr><td style="text-align:center">随机存取存储器（RAM）</td><td style="text-align:center">读写存储器</td><td style="text-align:center">电可擦除，字节级</td><td style="text-align:center">电</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">只读存储器（ROM）</td><td style="text-align:center">只读存储器</td><td style="text-align:center">不可擦除</td><td style="text-align:center">掩膜</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">可编程ROM（PROM）</td><td style="text-align:center">只读存储器</td><td style="text-align:center">不可能</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">可擦除ROM（EPROM）</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">紫外线可擦除，芯片级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">电可擦除PROM（EEPROM）</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">电可擦除，字节级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr><tr><td style="text-align:center">快闪存储器</td><td style="text-align:center">主要进行读的存储器</td><td style="text-align:center">电可擦除，块级</td><td style="text-align:center">电</td><td style="text-align:center">非易失</td></tr></tbody></table></div><h4 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h4><ol><li>Random-Access Memory（RAM）<ul><li>随机访问：对存储器中任意数据的访问所花费的时间与数据所在位置无关</li></ul></li><li>特性<ul><li>可以简单快速地进行读/写操作</li><li>易失的（Volatile）</li></ul></li><li>类型<ul><li>静态RAM（SRAM）：Static RAM（1963年由Robert Norman在仙童发明）</li><li>动态RAM（DRAM）：Dynamic RAM（1967年由Robert Dennard在IBM发明）</li></ul></li><li>静态RAM（SRAM）<ol><li>用传统的触发器逻辑门结构来存储二进制。只要有电源供电，SRAM就会保存数据（断电信息丢失）。常用于Cache。      </li><li>典型结构：六管静态MOS管存储元件   <ol><li>状态   <ul><li>1状态：C1点为高电平，C2点为低电平，此时T2、T3导通，T1、T4截止。   </li><li>0状态：C1点为低电平，C2点为高电平，此时T2、T3截止，T1、T4导通。   </li></ul></li><li>信息保持：字选择线（地址线）加低电平，T5、T6截止，触发器与外界隔离，信息保持不变。</li><li>读出：首先在两根位线上加高电平，地址线加高电平，T5、T6导通。若为状态1，T2导通，所以有电流从位线$\overline{\text{B}}$经过T6、T2流入地，位线$\overline{\text{B}}$上产生负脉冲。反之，若为状态0，位线B上产生负脉冲。</li><li>写入：地址线加高电平，T5、T6导通。若写入1，位线$\overline{\text{B}}$加低电平，T3导通，T1截止，C1电位升高，完成写1.若写入，位线B加低电平，T4导通，T2截止，C2电位升高，完成写0.   </li><li>即使元件不读写时，保持状态1时，T2、T3导通，仍有电流经T3、T2流向地线，因此功耗大。<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/cpt7-4.png" alt="img" style="zoom:80%;" /></li></ol></li></ol></li><li>动态RAM（DRAM）<ol><li>DRAM的存储单元把数据存储为电容上的电荷。电容上的电荷存在或不存在被解释为状态1或0。   </li><li>写入：字选择线加高电平，T导通。若写1，位线加高电平，给电容充电；若写0，位线加低电平，给电容放点。   </li><li>读出：字选择线加高电平，T导通。若原存1，电容放点，位线产生电流；若原存0，则无电流流过。放电后，电容点位下降，需要重写，成为“再生”操作。由于电容放点产生的电流不会很大，需要放大器增大电流。</li><li>电容存在漏电效应，一段时间后电荷会流失，导致数据丢失。因此需要定时刷新。<br><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/6aee1147c0a2b1dcbb6aad2260ac01a.png" alt="6aee1147c0a2b1dcbb6aad2260ac01a" style="zoom:80%;" /></li></ol></li><li>SRAM与DRAM的对比<br>|              |     SRAM     | DRAM  |<br>| :—————: | :—————: | :—-: |<br>|  <strong>易失性</strong>  |     易失     | 易失  |<br>| <strong>存储单元</strong> | 双稳态触发器 | 电容  |<br>|  <strong>集成度</strong>  |      低      |  高   |<br>|   <strong>功耗</strong>   |      高      |  低   |<br>|   <strong>速度</strong>   |      快      |  慢   |<br>|   <strong>刷新</strong>   |      无      |  有   |<br>|   <strong>价格</strong>   |    $1/MB     | $1/GB |</li></ol><h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ol><li>只读存储器（ROM）<ol><li>Read-only memory（ROM），一种可以长期保存信息的存储器，具有断电后信息仍可继续保存的特点，在正常工作时只可读取数据，而不能写入数据。</li><li>特性<ul><li>非易失性：不要求供电来维持数据</li><li>可读，但不能写入新数据</li></ul></li><li>应用：微程序设计，常用函数的库子例程，系统程序，函数表</li><li>问题：<ul><li>数据插入步骤包含了相对较大的固定成本，不论制造的是特定ROM的一个还是几千个副本。</li><li>无出错处理机会：如果有一位出错，整批的ROM芯片只能报废。</li><li>用户无法写入数据：唯一的数据写入机会再出厂时完成。</li></ul></li></ol></li><li>可编程ROM（PROM）<ol><li>Programmable ROM（PROM），写处理的执行是电气化的，可以由供应商或客户在原始芯片制作出来后执行。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/c45a7bcd8f2fe3922ee186b9169abe8.png" alt="c45a7bcd8f2fe3922ee186b9169abe8" style="zoom:50%;" /></div></li><li>特性<ul><li>非易失的</li><li>只能被写入一次。写入过程使用电信号执行，需要特殊设备来完成写或编程过程。   </li></ul></li><li>与ROM的对比<ul><li>PROM提供了灵活性和方便性。</li><li>ROM在大批量生产领域仍具有吸引力。<h4 id="以读为主存储器"><a href="#以读为主存储器" class="headerlink" title="以读为主存储器"></a>以读为主存储器</h4></li></ul></li></ol></li><li>Read-Mostly Memory</li><li>特性<ul><li>非易失的</li><li>写操作与读操作相比，较为困难</li></ul></li><li>应用：读操作比写操作频繁地多且又需要非易失性存储器的场景</li><li>类型：EPROM、EEPROM、闪存</li><li>光可擦除可编程只读存储器（EPROM）<ol><li>Erasable programmable read-only memory（EPROM）</li><li>特性<ul><li>电写入（1- &gt;0）：漏极和选择栅加高压，电子温度上升变为热电子，上升穿过氧化层，进入浮栅。P型半导体的负电子被浮栅中的电子排斥，原理绝缘层，效应管不导通，数据被写入0。</li><li>光擦除（0-&gt;1)：将封装芯片暴露在紫外线下，照射使电子获得能量，逃出浮栅，场效应管导通，所有单元变回状态1。每次擦除需要约20分钟。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/95b95b545a8e205757cc1393d05ab4a.png" alt="95b95b545a8e205757cc1393d05ab4a" style="zoom: 50%;" /></div></li></ul></li></ol></li><li>电可擦除可编程只读存储器（EEPROM）<ol><li>Electrically erasable programmable read-only memory（EEPROM）。目前用于车载摄像头和传感器出厂设置、安全气囊的弹出记录以及需要长时间通电的工业自动化设备和服务器的数据记录系统等；在DDR SDRAM中也会使用EEPROM，用于保存内存的相关信息，计算机会在开机自检时会读取这些信息</li><li>特性<ul><li>可以随时写入而不删除之前的内容；只更新寻址到的一个或多个字节。</li><li>电写入（1-&gt;0）：源极和漏极接地，控制栅接高电平，电子进入浮栅。写操作每字节需要大约5ms，而读一个字节大约0.5微秒。</li><li>电擦除（0-&gt;1）：源极和控制栅接地，漏极接高电平，浮栅中电子进入衬底。每次擦除仅需4~6ms，可擦除百万次。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/b55108f28bef2e7de730bce977c3680.png" alt="b55108f28bef2e7de730bce977c3680" style="zoom:50%;" /></div></li></ul></li></ol></li><li>快闪存储器（Flash Memory）<ol><li>特性<ul><li>电可擦除：与EEPROM原理类似，优于EPROM。</li><li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM。</li><li>需要先擦除再写入。</li></ul></li><li>分类<ul><li>NOR Flash：数据线和地址线分开，可以读任意字节。</li><li>NAND Flash：数据线可地址线共用，只能按页读取。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/70d77704608eec0f638c9073f3ed293.png" alt="70d77704608eec0f638c9073f3ed293" style="zoom:50%;" /></div></li></ul></li></ol></li><li>各类ROM 对比<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/0f98bebd96a8cbcd7ee9b3b692a4aec.png" alt="0f98bebd96a8cbcd7ee9b3b692a4aec" style="zoom:67%;" /></div></li></ol><h3 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h3><h4 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h4><ol><li>寻址单元（Addressable unit）：由若干相同地址的位元组成。</li><li>寻址模式：字节（Byte）：常用；字（Word）：专门用途的计算机。</li></ol><h4 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h4><ol><li><p>芯片引脚</p><ul><li>Address：A0 - A19</li><li>Data：D0 - D7</li><li>Vcc：电源</li><li>Vss：地线</li><li>CE：芯片允许引脚</li><li>Vpp：程序电压</li><li>WE：写允许</li><li>OE：读允许</li><li>RAS：行地址选通</li><li>CAS：列地址选通<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/f94ea025cf9e0640b3c9ed1137bf7ba.png" alt="f94ea025cf9e0640b3c9ed1137bf7ba" style="zoom:70%;" /></div></li></ul></li><li><p>存储阵列（Memory Array）：由大量寻址单元组成</p><div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/image-20231212180159945.png" alt="image-20231212180159945" style="zoom: 50%;" /></div></li><li>如何寻址<ol><li>获得总线控制权。</li><li>CPU向存储阵列发送地址。</li><li>时序和控制单元将地址分解为行地址或列地址。</li><li>向行地址缓冲器发出行地址。</li><li>行译码器选中行。</li><li>数据进入行放大器。</li><li>向列地址缓冲区发出列地址。</li><li>列译码器选出对应列。</li><li>数据进入数据输入缓冲区。</li></ol></li><li>如何刷新<ol><li>约束：刷新会占用片选线、地址线、地址译码器</li><li>刷新时只给各芯片送行地址和RAS信号，这样一行的所有元素被选中并进行读出操作。因此刷新按行进行，一次可刷新一行。2048x2038x4位的芯片只要2048次刷新。</li><li>三种刷新方式<ul><li>集中式刷新<ul><li>停止读写操作，并逐行刷新</li><li>刷新时无法操作内存（死区）</li></ul></li><li>分散式刷新<ul><li>在每个存储周期中，当读写操作完成时进行刷新</li><li>一次读写刷新一行，逐行刷新</li><li>会增加每个存储周期的时间</li></ul></li><li>异步刷新<ul><li>每一行各自以固定间隔（小于最大刷新周期，毫秒级）刷新</li><li>将DRAM的刷新安排在CPU对指令的译码阶段，可有效避免死区</li><li>效率高：常用<h4 id="DDR-DRAM"><a href="#DDR-DRAM" class="headerlink" title="DDR DRAM"></a>DDR DRAM</h4></li></ul></li></ul></li></ol></li><li>异步DRAM与同步DRAM<ul><li>异步DRAM：传统DRAM是异步的。读写操作时，处理器向内存提供地址和控制电平。接着进入访问延迟时间，这段时间内DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，处理器只能等待这段延迟，即存取时间，从而降低了系统性能。</li><li>同步DRAM：SDRAM在系统时钟控制下移入和移出数据。处理器或其他主机发出指令和地址信息，并有SDRAM锁存。然后SDRAM在一定的时钟周期后响应。同时，当SDRAM处理请求时，主设备可以安全地执行其他任务。</li></ul></li><li>DRAM读写周期<ol><li>读周期<br>（1）行地址必须在$\overline{\text{RAS}}$信号有效之前送到芯片的地址输入端。<br>（2）$\overline{\text{CAS}}$信号应滞后$\overline{\text{RAS}}$一段时间,并滞后列地址送到芯片地址输入端的时间。<br>（3）$\overline{\text{RAS}}$、$\overline{\text{CAS}}$的时延分别为 t<sub>RAS</sub>和 <sub>CAS</sub>，它们应有足够的宽度。<br>（4）$\overline{\text{WE}}$信号为高电平，并在$\overline{\text{CAS}}$有效之前建立。<br>（5）每次读后要再生，即重新写人一次。<ol><li>写周期：在写周期中,$\overline{\text{RAS}}$与$\overline{\text{CAS}}$之间的关系以及与地址信息间的关系和读周期相同但还有两点不同。<br>（1）$\overline{\text{WE}}$信号为低电平，并在$\overline{\text{CAS}}$信号有效之前建立。（$\overline{\text{WE}}$上有一条上划线，表示取反，$\overline{\text{WE}}$=0时，表示写使能有效）<br>（2）写数据必须在$\overline{\text{CAS}}$有效之前出现在D端。    <div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e95c8b405fbb5f2f6a13581cd132445.png" alt="e95c8b405fbb5f2f6a13581cd132445" style="zoom:60%;" /></div></li></ol></li></ol></li><li>SDRAM读写<br> SDRAM的每一步操作都在外部系统时钟CLK 的控制下进行支持突发(burst)传输方式。只要在第一次存取时给出首地址，以后按地址顺序读写即可，而不再需要地址建立时间和行列预充电时间就能快速连续地从行缓冲器(row buffer)中输出一连串数据。行缓冲器用来缓存指定行中每一行的数据，通常用SRAM 元件实现。内部的工作方式寄存器(也称模式寄存器)可用来设置传送数据的长度以及从收到读命令(与CAS 信号同时发出)到开始传送数据的延迟时间等前者称为突发长度(burst length，BL)，后者称为CAS潜伏期(CAS latency，CL)。根据所设定的 BL和CL，CPU 可以确定何时开始从总线上取数以及连续取多少个数据在开始的第一个数据读出后，同一行的所有数据都被送到行缓冲器中，因此，以后每个时钟可从SDRAM读取一个数据，并在下一个时钟内通过总线传送到 CPU。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%e3%80%8b%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0-%e7%ac%ac7%e8%ae%b2-%e5%86%85%e9%83%a8%e5%ad%98%e5%82%a8%e5%99%a8/e408d144336de24dd3b59c2a6482d6c.png" alt="e408d144336de24dd3b59c2a6482d6c" style="zoom:50%;" /></div></li><li>DDR SDRAM<ul><li>Double Data Rate：每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在下降沿。</li><li>通过三种途径获得更高的数据速率，DDR -&gt; DDR2 -&gt;  DDR3 -&gt; DDR4 -&gt; DDR5<ul><li>数据传输被同步到时钟的上升沿和下降沿，而不仅仅在上升沿，使得数据速率加倍。</li><li>使用更高的总线时钟频率。</li><li>使用缓冲方案。<div align="center"><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/image-20231212192727683.png" alt="image-20231212192727683" style="zoom:100%;" /> <img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/image-20231212192717520.png" alt="image-20231212192717520" style="zoom:100%;" /><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/d9de3049edd4019913d6b9fecaec64e.png" alt="d9de3049edd4019913d6b9fecaec64e" style="zoom:100%;" /><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/762c7f6add775ffee42a7e0c099b8b4.png" alt="762c7f6add775ffee42a7e0c099b8b4" style="zoom:100%;" /></div></li></ul></li></ul></li></ol><h4 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h4><ol><li>位扩展：地址线不变，数据线增加<ul><li>使用8 块4K*1 bit 的芯片组成4K*8 bit的存储器</li></ul></li><li>字扩展：地址线增加，数据线不变<ul><li>使用4 个16K*8 bit 的芯片组成64K*8bit 的存储器</li></ul></li><li>字、位同时扩展：地址线增加，数据线增加<ul><li>使用8 个16K*4 bit 的芯片组成64K*8bit 的存储器<div align="center"><img src="https://sprooc.github.io/2023/12/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E7%AC%AC7%E8%AE%B2-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/399904474e1ad0c8309a6027406e9b7.png" alt="399904474e1ad0c8309a6027406e9b7" style="zoom:80%;" /></div></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20231210周记</title>
      <link href="/2023/12/10/20231210%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/10/20231210%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本周的算法学习主要是刷题+看书，没有学什么新算法，只零碎地学了一些小的知识点。</p><span id="more"></span><h3 id="二分模版"><a href="#二分模版" class="headerlink" title="二分模版"></a>二分模版</h3><p>虽然以前二分写的不少，但从来没有一次写对过，看了lyd的书之后才知道有两种二分模版。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模版一</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &gt;= x) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">// 避免进入l = mid的死循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模版二</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid] &lt;= x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;  <span class="comment">// 避免进入 r = mid的死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="货仓选址问题"><a href="#货仓选址问题" class="headerlink" title="货仓选址问题"></a>货仓选址问题</h3><p>数轴上有N家商店，坐标分别为A[1]~A[N]，选一个位置建货仓，令货仓到每家商店的距离之和最小。</p><ul><li>货仓必须建在中位数处，证明不难，思考一下。</li></ul><h3 id="矩形面积问题"><a href="#矩形面积问题" class="headerlink" title="矩形面积问题"></a>矩形面积问题</h3><p>复习了一下这几道题，很典型。</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形 - 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/largest-submatrix-with-rearrangements/">1727. 重新排列后的最大子矩阵 - 力扣（LeetCode）</a></p><p>顺便记录一下，力扣400题达成！</p><p><img src="d497adb09462806195c69527368fd00.png" alt="d497adb09462806195c69527368fd00" style="zoom:50%;" /></p><h3 id="第32次CSP认证"><a href="#第32次CSP认证" class="headerlink" title="第32次CSP认证"></a>第32次CSP认证</h3><p>今天去考了csp认证，感觉题目比上几次稍微难一点。</p><ul><li>第一题，签到题，忘了，100分。</li><li>第二题，分解质因数，这周刚刚做过哈哈哈，100分。</li><li>第三题，树。哭了感觉这次第三题不是模拟而是算法了。暴力解60分，加了记忆化还是60分，不会优化了。。。</li><li>第四题，暴力，35分。</li><li>第五题，试图暴力，但找不出哪里写错了，0分。</li></ul><p>最后295分，还以为能上300的。。。问题不大，毕竟氪了西西艾弗的会员，明年再来！</p><h3 id="杂念"><a href="#杂念" class="headerlink" title="杂念"></a>杂念</h3><p>准备了一段时间的csp也结束了，之后学算法的时间应该会缩短了，因为期末周快到了呜。接下来保持每天3道以上的刷题，然后花点时间继续啃lyd的书。其余更多的时间就要用来准备期末考了。另外，为了应对机组机考，下周进行Java复健，刷题尽量写爪哇吧，毕竟一个学期都没咋写过了。</p><p>最近读完了《围城》。读书时只顾情节，不及品悟“围城”的含义。直到最后戛然而止，心想“围城”何在？原来“围城”处处在。方鸿渐一次又一次冲出“围城”，却又进入另一个“围城”。他不断辗转，希望通过“出城”来改善处境，不料处境丝毫未见好转。人生在世，难免有处境不顺的时候。有人埋怨环境，认为是地方不好，以为换一个环境就能过的更好。然而事实往往是，当他们换了一个环境之后，又觉得还是不够好，于是不断辗转，最后却还是没过上称心如意的生活。其实，“围城”真的存在吗？自己的处境，真的是环境造成的吗？我想，围住自己的不是外部的城，而是自己的心墙。一个人内心苍白，无论在哪都无趣；内心没有目标，无论走多远都走不出围城。我们要做的，不是期待遇到一个好人、工作、环境带给自己幸福，而是要让自己成为一个有“幸福力“的人，让自己保持幸福的状态。这样的话，无论和谁在一起，身处何地，都是幸福的。</p><p>一个人的内心是一个人真正的主人。心念所囚即为牢笼，心念所驻即为城池。能困住人的永远不会是墙，困住人的是现实的琐碎和人心的羁绊，是自己筑成的心墙。心若被困住，哪里都是围城，心若没有栖息，哪里都是流浪。<br>需要我们记住的是：自由不在墙外，自由在你心里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机组织结构》机试复习</title>
      <link href="/2023/12/08/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/08/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%8B%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://sprooc.github.io/2023/12/08/《计算机组织结构》机试复习/64.jpg" alt="64" style="zoom:25%;" /></p><hr><span id="more"></span><h3 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h3><p>1.将整数真值（十进制表示）转化成补码表示的二进制，默认长度32位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToBinary</span><span class="params">(String numStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(numStr);</span><br><span class="line">    <span class="keyword">if</span>(num == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="string">&quot;10000000000000000000000000000000&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">        neg = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp.insert(<span class="number">0</span>, num % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> temp.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span> - len; i++) &#123;</span><br><span class="line">        temp.insert(<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span>(neg) &#123;</span><br><span class="line">        ans = addOne(negation(ans));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对二进制的每一位取反</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">negation</span><span class="params">(String num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> num.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i++) &#123;</span><br><span class="line">        sb.append(num.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> :<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二进制数加一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">addOne</span><span class="params">(String num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(num);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> num.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sb.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            sb.setCharAt(i, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.setCharAt(i, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.将补码表示的二进制转化成整数真值（十进制表示）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToInt</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> binStr.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(binStr.charAt(i) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        num += (<span class="number">1</span> &lt;&lt; (len - i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        num -= (<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.将十进制整数的真值转化成NBCD表示（符号位用4位表示）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decimalToNBCD</span><span class="params">(String decimalStr)</span> &#123;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">NBCD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(decimalStr);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           neg = <span class="literal">true</span>;</span><br><span class="line">           num = -num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, getNBCD_4(num % <span class="number">10</span>));</span><br><span class="line">           num /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> NBCD.length();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">28</span> - len; i++) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (neg) &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&quot;1101&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           NBCD.insert(<span class="number">0</span>, <span class="string">&quot;1100&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> NBCD.toString();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 将一位十进制数转化为NBCD码</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNBCD_4</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           sb.setCharAt(loc, i % <span class="number">2</span> == <span class="number">1</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           i /= <span class="number">2</span>;</span><br><span class="line">           loc--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.将NBCD表示（符号位用4位表示）转化成十进制整数的真值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">NBCDToDecimal</span><span class="params">(String NBCDStr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + fourNBCDTOInt(NBCDStr, <span class="number">7</span> + <span class="number">4</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NBCDStr.charAt(<span class="number">3</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fourNBCDTOInt</span><span class="params">(String bits, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        num += (<span class="number">1</span> &lt;&lt; i) * (bits.charAt(r - i) == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.将浮点数真值转化成32位单精度浮点数表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">floatToBinary</span><span class="params">(String floatStr)</span> &#123;</span><br><span class="line">       <span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.valueOf(floatStr);</span><br><span class="line">       <span class="keyword">if</span> (num &gt; Float.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;+Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; -Float.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;-Inf&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; Float.MIN_VALUE &amp;&amp; num &gt; -Float.MIN_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> (floatStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>) + <span class="string">&quot;0000000000000000000000000000000&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           num = -num;</span><br><span class="line">           neg = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> neg ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">bias</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">       <span class="keyword">if</span> (num &lt; Float.MIN_NORMAL) &#123;</span><br><span class="line">           ans += <span class="string">&quot;00000000&quot;</span>;</span><br><span class="line">           System.out.println(<span class="string">&quot;n1 &quot;</span> + num);</span><br><span class="line">           num *= Math.pow(<span class="number">2</span>, <span class="number">126</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;n2 &quot;</span> + num);</span><br><span class="line">           ans += fixToString(num);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (num &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">               num /= <span class="number">2</span>;</span><br><span class="line">               exp++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">               num *= <span class="number">2</span>;</span><br><span class="line">               exp--;</span><br><span class="line">           &#125;</span><br><span class="line">           exp += bias;</span><br><span class="line">           ans += intToBinary(exp+<span class="string">&quot;&quot;</span>).substring(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">           ans += fixToString(num - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 将浮点数转化为23位的二进制数（0&lt;num&lt;1)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">fixToString</span><span class="params">(<span class="type">float</span> num)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">23</span>; i++) &#123;</span><br><span class="line">           num *= <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">               sb.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">               num -= <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>6.将32位单精度浮点数表示转化成浮点数真值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">binaryToFloat</span><span class="params">(String binStr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> binStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> bitsToInt(binStr.substring(<span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">frac</span> <span class="operator">=</span> bitsToInt(binStr.substring(<span class="number">9</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frac == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (neg ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;+&quot;</span>) + <span class="string">&quot;Inf&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;NaN&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf((<span class="type">float</span>) ((neg ? (-<span class="number">1</span>) : <span class="number">1</span>) * frac * Math.pow(<span class="number">2</span>, -<span class="number">149</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf((<span class="type">float</span>) ((neg ? (-<span class="number">1</span>) : <span class="number">1</span>) * (<span class="number">1</span> + frac * Math.pow(<span class="number">2</span>, -<span class="number">23</span>)) * Math.pow(<span class="number">2</span>, exp - <span class="number">127</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bitsToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        num *= <span class="number">2</span>;</span><br><span class="line">        num += (str.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整数算术运算"><a href="#整数算术运算" class="headerlink" title="整数算术运算"></a>整数算术运算</h3><p>1.一位全加器（输出为长度为2 的字符串，包括1 位的进位输入和1 位的加法运算结果）</p><p><img src="a1f8e264b3b7dc7bd44becc79bbb698.png" alt="a1f8e264b3b7dc7bd44becc79bbb698" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">fullAdder</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x - <span class="string">&#x27;0&#x27;</span>) ^ (y - <span class="string">&#x27;0&#x27;</span>) ^ (c - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//三位异或</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> ((x - <span class="string">&#x27;0&#x27;</span>) &amp; (y - <span class="string">&#x27;0&#x27;</span>)) | ((y - <span class="string">&#x27;0&#x27;</span>) &amp; (c - <span class="string">&#x27;0&#x27;</span>)) | ((x - <span class="string">&#x27;0&#x27;</span>) &amp; (c - <span class="string">&#x27;0&#x27;</span>));  <span class="comment">//有两位为1则产生进位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + carry + bit;  <span class="comment">//第一个空串让后面的加法都变为字符串加法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4位先行进位加法器</p><p><img src="779f91b211dbac0dd55bcde8d454722.png" alt="779f91b211dbac0dd55bcde8d454722" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">claAdder</span><span class="params">(String operand1, String operand2, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">P</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">G</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        P = P + ((operand1.charAt(i) == <span class="string">&#x27;1&#x27;</span> || operand2.charAt(i) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        G = G + ((operand1.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; operand2.charAt(i) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        C = ((G.charAt(i) == <span class="string">&#x27;1&#x27;</span> || P.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; C.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>) + C;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C.charAt(<span class="number">0</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        result = result + fullAdder(operand1.charAt(i), operand2.charAt(i), C.charAt(i + <span class="number">1</span>)).charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现16 位的部分先行进位加法器（基于上述方法claAdder）</p><p><img src="16bc6143fed111070678490bfa0a843.png" alt="16bc6143fed111070678490bfa0a843" style="zoom:33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">pclaAdder</span><span class="params">(String operand1, String operand2, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = claAdder(operand1.substring(i * <span class="number">4</span>, i * <span class="number">4</span> + <span class="number">4</span>), operand2.substring(i * <span class="number">4</span>, i * <span class="number">4</span> + <span class="number">4</span>), c);</span><br><span class="line">        c = temp.charAt(<span class="number">0</span>);</span><br><span class="line">        result = temp.substring(<span class="number">1</span>) + result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c + result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.实现32位整数加法（基于fullAdder方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> fullAdder(operand1.charAt(i), operand2.charAt(i), c);</span><br><span class="line">        result.append(temp.charAt(<span class="number">1</span>));</span><br><span class="line">        c = temp.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(result.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.实现32位整数减法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(src.toString());</span><br><span class="line">negAndAddOne(str);</span><br><span class="line">      <span class="keyword">return</span> add(<span class="keyword">new</span> <span class="title class_">DataType</span>(str.toString()), dest);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 取反加一</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">negAndAddOne</span><span class="params">(StringBuilder str)</span>&#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (flip) &#123;</span><br><span class="line">              str.setCharAt(i, str.charAt(i) == <span class="string">&#x27;1&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              flip = str.charAt(i) == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一次遍历实现取反加一：假设原二进制数最低位的1在第n位（最低位为第0位），那么该二进制数可以表示为：xx…xx10…0（后缀n个0）。取反之后为：xx…xx01…1，前面的x全部取反。再加一之后变为：xx…xx10…0可以发现，最后的10…0没有改变，只有前面的x取反了一次。所以我们只需要从后面开始遍历，在遇到第一个1之前不作改变，遇到1之后再开始取反。</p><p>6.实现32位整数布斯乘法</p><p><img src="bdd5337ccfca477eced16a1580b3bd3.png" alt="bdd5337ccfca477eced16a1580b3bd3" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">       <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> src.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">       negAndAddOne(sb);</span><br><span class="line">       <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2 + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(product.charAt(<span class="number">63</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; product.charAt(<span class="number">64</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">               highAdd(operand1, product);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(product.charAt(<span class="number">63</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; product.charAt(<span class="number">64</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">               highAdd(negOperand1, product);</span><br><span class="line">           &#125;</span><br><span class="line">           ASR(product);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(product.substring(<span class="number">32</span>,<span class="number">64</span>));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 在dest的高32位上加上src</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">highAdd</span><span class="params">(String src, StringBuilder dest)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> dest.substring(<span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">       temp = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(temp), <span class="keyword">new</span> <span class="title class_">DataType</span>(src)).toString();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           dest.setCharAt(i, temp.charAt(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 算数右移</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASR</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">       sb.insert(<span class="number">0</span>, sb.charAt(<span class="number">0</span>));</span><br><span class="line">       sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>7.恢复余数的32位整数除法</p><p><img src="37a20113d188fa2949334ee757f2a11.png" alt="37a20113d188fa2949334ee757f2a11" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">    negAndAddOne(temp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span> (operand1.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    StringBuilder product;</span><br><span class="line">    <span class="keyword">if</span> (operand2.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span> + operand2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        LeftShift(product, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            highAdd(negOperand1, product);</span><br><span class="line">            <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) != operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                highAdd(operand1, product);</span><br><span class="line">                c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            highAdd(operand1, product);</span><br><span class="line">            <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                highAdd(negOperand1, product);</span><br><span class="line">                c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        product.setCharAt(<span class="number">63</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(product.substring(<span class="number">0</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="comment">// 若除数与被除数异号，商取反加一</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">quotient</span> <span class="operator">=</span> product.substring(<span class="number">32</span>, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span> (operand1.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(quotient);</span><br><span class="line">        negAndAddOne(temp);</span><br><span class="line">        quotient = temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理特殊情况：余数与除数相等，余数改为0，商加一；</span></span><br><span class="line">    <span class="comment">//             余数与除数相反，余数改为0，商减一。</span></span><br><span class="line">    <span class="keyword">if</span>(remainderReg.toString().equals(operand1)) &#123;</span><br><span class="line">        remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        quotient = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(quotient), <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000001&quot;</span>)).toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(remainderReg.toString().equals(negOperand1)) &#123;</span><br><span class="line">        remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        quotient = add(<span class="keyword">new</span> <span class="title class_">DataType</span>(quotient), <span class="keyword">new</span> <span class="title class_">DataType</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span>)).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(quotient);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">LeftShift</span><span class="params">(StringBuilder sb, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.不恢复余数的32位整数除法</p><p><img src="9a4262aaef43f3886d50bf544803d39.png" alt="9a4262aaef43f3886d50bf544803d39" style="zoom:30%;" /></p><p><img src="fcb272820a3b29419ddc6112b7b0a80.png" alt="fcb272820a3b29419ddc6112b7b0a80" style="zoom:30%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand1</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">operand2</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(operand1);</span><br><span class="line">    negAndAddOne(temp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">negOperand1</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">    <span class="keyword">if</span> (operand1.equals(<span class="string">&quot;00000000000000000000000000000000&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    StringBuilder product;</span><br><span class="line">    <span class="keyword">if</span> (operand2.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;11111111111111111111111111111111&quot;</span> + operand2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span> + operand2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        highAdd(negOperand1, product);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        highAdd(operand1, product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            LeftShift(product, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            highAdd(negOperand1, product);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LeftShift(product, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            highAdd(operand1, product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">quotientSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(product.substring(<span class="number">32</span>, <span class="number">64</span>));</span><br><span class="line">    <span class="comment">// 商修正：商左移一位，若余数寄存器与除数同号，低位补1；若异号，低位补0.</span></span><br><span class="line">    <span class="keyword">if</span> (product.charAt(<span class="number">0</span>) == operand1.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        LeftShift(quotientSB, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LeftShift(quotientSB, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若被除数与除数异号，商加一</span></span><br><span class="line">    <span class="keyword">if</span>(operand1.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        highAdd(<span class="string">&quot;00000000000000000000000000000001&quot;</span>, quotientSB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 余数修正：若余数与被除数同号，不修正；</span></span><br><span class="line">    <span class="comment">//          若余数与被除数异号：若被除数与除数同号，余数减去除数；</span></span><br><span class="line">    <span class="comment">//                           若被除数与除数异号，余数加上除数。</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">remainderSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(product.substring(<span class="number">0</span>, <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">if</span> (remainderSB.charAt(<span class="number">0</span>) != operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operand1.charAt(<span class="number">0</span>) == operand2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            highAdd(negOperand1, remainderSB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            highAdd(operand1, remainderSB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若余数与除数相等，余数改为0，商加一；</span></span><br><span class="line">    <span class="comment">//若余数与除数相反，余数改为0，商减一。</span></span><br><span class="line">    <span class="keyword">if</span> (remainderSB.toString().equals(operand1)) &#123;</span><br><span class="line">        remainderSB = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        highAdd(<span class="string">&quot;00000000000000000000000000000001&quot;</span>, quotientSB);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remainderSB.toString().equals(negOperand1)) &#123;</span><br><span class="line">        remainderSB = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;00000000000000000000000000000000&quot;</span>);</span><br><span class="line">        highAdd(<span class="string">&quot;11111111111111111111111111111111&quot;</span>, quotientSB);</span><br><span class="line">    &#125;</span><br><span class="line">    remainderReg = <span class="keyword">new</span> <span class="title class_">DataType</span>(remainderSB.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(quotientSB.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数算数运算"><a href="#浮点数算数运算" class="headerlink" title="浮点数算数运算"></a>浮点数算数运算</h3><p>1.计算两个浮点数的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">add</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(addCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="keyword">if</span>(isZero(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(isFinite(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> Math.max(xexp, yexp);</span><br><span class="line">    <span class="keyword">if</span> (yexp &lt; exp) &#123;</span><br><span class="line">        yfrac = rightShift(yfrac, exp - yexp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xexp &lt; exp) &#123;</span><br><span class="line">        xfrac = rightShift(xfrac, exp - xexp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    String frac;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) &#123;</span><br><span class="line">        frac = ALU.add(<span class="string">&quot;0&quot;</span> + xfrac, <span class="string">&quot;0&quot;</span> + yfrac).toString();</span><br><span class="line">        s = xs;</span><br><span class="line">        exp++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xs == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ys == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = ALU.sub(<span class="string">&quot;0&quot;</span> + yfrac, <span class="string">&quot;0&quot;</span> + xfrac).toString();</span><br><span class="line">        s = frac.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            frac = ALU.negation(frac);</span><br><span class="line">        &#125;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        frac = ALU.sub(<span class="string">&quot;0&quot;</span> + xfrac, <span class="string">&quot;0&quot;</span> + yfrac).toString();</span><br><span class="line">        s = frac.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            frac = ALU.negation(frac);</span><br><span class="line">        &#125;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(round(s, Transformer.intToBinary(exp + <span class="string">&quot;&quot;</span>).substring(<span class="number">32</span> - <span class="number">8</span>), frac.substring(<span class="number">0</span>, <span class="number">27</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.计算两个浮点数的差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">sub</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    src = <span class="keyword">new</span> <span class="title class_">DataType</span>((s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>) + s.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> add(src, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.计算两个浮点数的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">mul</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(mulCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) s = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isZero(x) || isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(x) || isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> xexp + yexp - <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">frac</span> <span class="operator">=</span> ALU.mul(xfrac, yfrac).toString();</span><br><span class="line">    <span class="keyword">if</span> (frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        exp++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        frac = frac.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (exp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">        exp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.计算两个浮点数的商。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataType <span class="title function_">div</span><span class="params">(DataType src, DataType dest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> src.toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> dest.toString();</span><br><span class="line">    <span class="keyword">if</span> (x.matches(IEEE754Float.NaN_Regular) || y.matches(IEEE754Float.NaN_Regular)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(IEEE754Float.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> cornerCheck(divCorner, x, y);</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(temp);</span><br><span class="line">    <span class="type">char</span> <span class="variable">xs</span> <span class="operator">=</span> x.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> <span class="variable">ys</span> <span class="operator">=</span> y.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="keyword">if</span> (xs == ys) s = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> s = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isZero(x)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">    <span class="keyword">if</span> (isZero(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(x)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_ZERO : IEEE754Float.P_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (isFinite(y)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="type">int</span> <span class="variable">xexp</span> <span class="operator">=</span> Integer.valueOf(x.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yexp</span> <span class="operator">=</span> Integer.valueOf(y.substring(<span class="number">1</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (xexp == <span class="number">0</span>) xexp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yexp == <span class="number">0</span>) yexp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xfrac</span> <span class="operator">=</span> getFrac(x);</span><br><span class="line">    <span class="type">String</span> <span class="variable">yfrac</span> <span class="operator">=</span> getFrac(y);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> yexp - xexp + <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">frac</span> <span class="operator">=</span> ALU.div(xfrac, yfrac).toString();</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span> &amp;&amp; frac.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        frac = LeftShift(frac, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        exp--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(s == <span class="string">&#x27;1&#x27;</span> ? IEEE754Float.N_INF : IEEE754Float.P_INF);</span><br><span class="line">    <span class="keyword">if</span> (exp == <span class="number">0</span>) &#123;</span><br><span class="line">        frac = rightShift(frac, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataType</span>(round(s, Transformer.intToBinary(exp + <span class="string">&quot;&quot;</span>).substring(<span class="number">32</span> - <span class="number">8</span>), frac));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h3><p>1.计算使用先来先服务算法（FCFS）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">FCFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> loc : request) &#123;</span><br><span class="line">        result += Math.abs(start - loc);</span><br><span class="line">        start = loc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.计算最短寻到时间优先算法（SSTF）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SSTF</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> request.length;</span><br><span class="line">    LinkedList&lt;Integer&gt; requests = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : request) &#123;</span><br><span class="line">        requests.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!requests.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> findMinDistance(start, requests);</span><br><span class="line">        result += Math.abs(start - requests.get(loc));</span><br><span class="line">        start = requests.get(loc);</span><br><span class="line">        requests.remove(loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMinDistance</span><span class="params">(<span class="type">int</span> start, LinkedList&lt;Integer&gt; request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minD</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.size(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newD</span> <span class="operator">=</span> Math.abs(start - request.get(i));</span><br><span class="line">        <span class="keyword">if</span> (newD &lt; minD) &#123;</span><br><span class="line">            minD = newD;</span><br><span class="line">            loc = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.计算扫描算法（SCAN）访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">SCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="type">double</span> result;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="number">0</span>) direction = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == Disk.TRACK_NUM) direction = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">            result = maxTrace - start;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            result = Disk.TRACK_NUM - <span class="number">1</span> - start + Disk.TRACK_NUM - <span class="number">1</span> - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= maxTrace) &#123;</span><br><span class="line">            result = start - minTrace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = start + maxTrace;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.计算C-SCAN算法访问磁道的平均寻道长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CSCAN</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">        result = maxTrace - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; maxTrace) &#123;</span><br><span class="line">        result = Disk.TRACK_NUM - <span class="number">1</span> - start + maxTrace + Disk.TRACK_NUM - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request[i] &lt; start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request[i] &gt; lb) &#123;</span><br><span class="line">                    lb = request[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Disk.TRACK_NUM - <span class="number">1</span> - start + lb + Disk.TRACK_NUM - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.计算LOOK算法访问磁道的平均寻道长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">LOOK</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request, <span class="type">boolean</span> direction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) direction = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= maxTrace) direction = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= minTrace) &#123;</span><br><span class="line">        result = maxTrace - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= maxTrace) &#123;</span><br><span class="line">        result = start - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">        result = maxTrace - start + maxTrace - minTrace;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = start - minTrace + maxTrace - minTrace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * result / request.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.计算C-LOOK算法访问磁道的平均寻道长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">CLOOK</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] request)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTrace</span> <span class="operator">=</span> Arrays.stream(request).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTrace</span> <span class="operator">=</span> Arrays.stream(request).min().getAsInt();</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= minTrace) &#123;</span><br><span class="line">            result = maxTrace - start;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; maxTrace) &#123;</span><br><span class="line">            result = start - minTrace + maxTrace - minTrace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; request.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request[i] &lt; start) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request[i] &gt; lb) &#123;</span><br><span class="line">                        lb = request[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = maxTrace - start + maxTrace - minTrace + lb - minTrace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / request.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组织结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些数学</title>
      <link href="/2023/12/05/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6/"/>
      <url>/2023/12/05/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (LL)ans * a % m;</span><br><span class="line">    a = (LL)a * a % m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>龟速乘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">  a %= p;</span><br><span class="line">  b %= p;</span><br><span class="line">  LL c = (<span class="type">double</span>)a * b / p;</span><br><span class="line">  LL x = a * b;</span><br><span class="line">  LL y = c * p;</span><br><span class="line">  LL ans = (LL)(x % p) - (LL)(y % p);</span><br><span class="line">  <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += p;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等比数列（公比为p，项数为e，以1为首项）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> e, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (e % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)(<span class="number">1</span> + <span class="built_in">pow</span>(p, e / <span class="number">2</span>, m)) * <span class="built_in">sum</span>(p, e / <span class="number">2</span>, m) % m;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">pow</span>(p, e / <span class="number">2</span>, m)) * <span class="built_in">sum</span>(p, e / <span class="number">2</span>, m) % m +</span><br><span class="line">            <span class="built_in">pow</span>(p, e - <span class="number">1</span>, m)) % m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分解质因数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  p[s] = i; c[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">    a /= i; c[s]++;</span><br><span class="line">  &#125;</span><br><span class="line">  s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  p[s] = a; c[s++]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：</p><p><a href="https://www.acwing.com/problem/content/description/99/">97. 约数之和 - AcWing题库</a><br><a href="http://poj.org/problem?id=1995">1995 — Raising Modulo Numbers (poj.org)</a></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/591377294">ACM——常见的几种分解质因子的方法 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231203周记</title>
      <link href="/2023/12/03/20231203%E5%91%A8%E8%AE%B0/"/>
      <url>/2023/12/03/20231203%E5%91%A8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本周主要学习内容：树状数组、线段树、ST表、石子合并问题。</p><span id="more"></span><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>前半周主要学了树状数组，可以很熟练地把模版敲出来了。相关题目可以看<a href="[315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">leetcode315</a>)，以及当时写的小结：<a href="https://sprooc.github.io/2023/11/28/leetcode-315-计算右侧小于当前元素的个数/">[leetcode]315. 计算右侧小于当前元素的个数 | Sprooc</a>。</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>接下来系统梳理了线段树，掌握了懒惰标记和动态开点的方法，参考文章：<br><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713">线段树 从入门到进阶（超清晰，简单易懂）_线段树怎么写-CSDN博客</a><br><a href="https://leetcode.cn/problems/falling-squares/solutions/1518392/by-ac_oier-zpf0/">699. 掉落的方块 - 力扣（LeetCode）</a></p><h4 id="Sparse-Table"><a href="#Sparse-Table" class="headerlink" title="Sparse Table"></a>Sparse Table</h4><p>模版题目：<a href="https://www.luogu.com.cn/problem/solution/P3865">P3865 【模板】ST 表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="CSP真题"><a href="#CSP真题" class="headerlink" title="CSP真题"></a>CSP真题</h4><p>周六限时做了202203的CSP真题。前三题满分还是挺轻松的。第四题写了一个小时，暴力求“通信对”超时拿了50分。后来想改成实时维护“通信对”数量，但总该不对，大概有些细节问题，没有细究了。第五题一脸懵，直接放弃了。三个小时拿了350分。</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="fc1b9f4f1e7383b08328814347efeed.png" alt="fc1b9f4f1e7383b08328814347efeed"></h4><h4 id="石子合并问题"><a href="#石子合并问题" class="headerlink" title="石子合并问题"></a>石子合并问题</h4><p>做csp202203-5时了解到石子合并问题，找了些资料学了一学。参考资料：</p><p><a href="https://www.cnblogs.com/jiu0821/p/4493497.html">石子合并问题（直线版） - jiu~ - 博客园 (cnblogs.com)</a><br><a href="https://zhuanlan.zhihu.com/p/398419302">算法学习笔记(79): 四边形不等式优化DP - 知乎 (zhihu.com)</a></p><h4 id="力扣第374次周赛"><a href="#力扣第374次周赛" class="headerlink" title="力扣第374次周赛"></a>力扣第374次周赛</h4><p>两题遗憾收场，总排名意外的不算太低，感觉这次周赛确实上难度了。</p><p><img src="1635377acebfff7866915f1586771c1.png" alt="1635377acebfff7866915f1586771c1"></p><p><img src="0b495cd39acc31a7289b0558514d06a.png" alt="0b495cd39acc31a7289b0558514d06a"></p><p>第一题送分题。第二题需要自己模拟一下，思路比较难找，但终究还是写出来了。第三题思路本来是对的，先找到满足条件2的子串，再对每个子串求满足条件1的子串数量。求满足条件1的子串用滑动窗口，窗口大小为k的整数倍。当时我按照这种思路写结果超时了，以为有更优的解法。看了别人的代码才发现，不应该将字符串总长度作为窗口大小的上界，窗口最大只能是26k，因为只有26个字母，如果一个字符串满足条件，它的长度最大也只能是每个字母都出现k次，总长度就是26k。只改了一行代码结果结果了。又是细节上出了问题，看来还是经验不足。第四题实则是一道数学题。比赛时来不及做，之后看题解发现思路还是不困难的。但是发现一些原来不知道的数论知识，顺便补了一课：<a href="https://blog.csdn.net/LeBron_Yang/article/details/82948732">逆元（关于除法取模）_除法逆元-CSDN博客</a></p><p>总体来看，这周的收获还是挺大的（也更加感到自己与佬的差距）。目前的问题主要是经验不足和知识体系有很多缺漏。接下来还是要多刷题多总结。当然也要多啃书。另外刚买了一本李煜东的算法竞赛进阶指南，用来给自己补一补洞吧。</p><p>这周大概就是这样了。不知不觉就到了今年的最后一个月了，发现很快2023年就要结束了。感觉时间总是在不知不觉中溜走了，有一种被时间推着走的感觉。还没有做好迎接新一年的准备，就恍恍惚惚地被逼着迈入下一年。无论如何，没准备好也好，也只能硬着头皮走下去了。那么，为了让今年少一点遗憾，最后一个月，加油干吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>石子合并问题</title>
      <link href="/2023/12/03/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/03/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>石子合并问题：有N堆石子，现要将石子有序的合并成一堆，规定如下：每次只能移动相邻的2堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费最小（或最大）。</p><p>这是一道典型的动态规划题目。令<code>dp[i][j]</code>为将第i到j堆石子合并成一堆的最小代价<code>w[i][j]</code>为第i到j堆石子的总数。就可以写出状态转移方程：</p><script type="math/tex; mode=display">dp[i][j] = min_{k=i}^{j-1}(dp[i][k] + dp[k+1][j]) + w[i][j]</script><p>直接暴力求解就可以，复杂度O(n<sup>3</sup>)。</p><p>改进方法是用平行四边形不等式优化，缩小k的范围，复杂度O(n<sup>2</sup>) :<a href="https://zhuanlan.zhihu.com/p/398419302">算法学习笔记(79): 四边形不等式优化DP - 知乎 (zhihu.com)</a></p><p>问题的变种是让石子环形排列，即第一堆和最后一堆看成是相邻的。解决方法是在n堆石子后面再加上与前面一样的n堆石子，这样最后一堆和第一堆就相邻了。把总堆数看成2n，用上面的方法解出来就可以了。最后还需要遍历一下dp数组，求出2n堆石子里面结果最小的n堆石子作为最终结果。</p><p><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">stones</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; s(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; dp1(<span class="number">2</span> * n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sum</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; stones[i];</span><br><span class="line">    stones[n + i] = stones[i];</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + stones[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + stones[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span> * n; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> j = i + r;</span><br><span class="line">      <span class="keyword">if</span> (j &gt; <span class="number">2</span> * n) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>, dp1[i][i] = <span class="number">0</span>, s[i][i] = i;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] = INF;</span><br><span class="line">      dp1[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = s[i][j - <span class="number">1</span>]; k &lt;= min(j - <span class="number">1</span>, s[i + <span class="number">1</span>][j]); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k + <span class="number">1</span>][j]) &#123;</span><br><span class="line">          dp[i][j] = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">          s[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">        dp1[i][j] = max(dp1[i][j], dp1[i][k] + dp1[k + <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] += (sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">      dp1[i][j] += (sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> re1 = INF;</span><br><span class="line">  <span class="type">int</span> re2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    re1 = min(re1, dp[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    re2 = max(re2, dp1[i][i + n - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, re1, re2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sparse Table(稀疏表)</title>
      <link href="/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/"/>
      <url>/2023/12/01/Sparse%20Table(%E7%A8%80%E7%96%8F%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<p>Sparse Table简称ST，用于对一组静态数据进行区间查询。</p><span id="more"></span><p>例如：</p><ul><li>RMQ：区间最大（最小）值</li><li>RGQ：区间最大公因数</li></ul><p>这两个问题都可以用线段树解决。但线段树的查询时间是O(logn)，ST可以在O(1)时间内完成查询。代价是是ST不能对数组进行动态维护，数组在查询之前就固定下来。因此，如果需要动态维护数组，用线段树；反之，用ST。</p><p>什么样的问题可以用ST解决？例如说，求区间最小值，我们可以先把一个区间分成两个小区间，两个小区间的的最小值就是大区间的最小值。最大公因数也同理，求一个大区间的最大公因数，先求两个小区间的最大公因数，再求这两个数的最大公因数就是大区间的最大公因数。类似这类问题都能用ST解决。形式化的，ST能解决的问题为：</p><ul><li><p>求数组的某一区间S的某一性质F(S)，性质F满足：</p><script type="math/tex; mode=display">若{s_1}\cup {s_2}=S，则F(S)=F(F(s_1),F(s_2)).</script><p>可以验证，min和gcd都满足以上要求。</p><p>详细内容参照<a href="[ST稀疏表(Sparse Table">这篇文章</a>算法笔记-CSDN博客](<a href="https://blog.csdn.net/narcissus2_/article/details/89423591))。">https://blog.csdn.net/narcissus2_/article/details/89423591))。</a></p></li></ul><p>下面是代码（read函数是快速读入一个整数的函数，只是用来过洛谷的oj）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">21</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="built_in">log2</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="built_in">gcd</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(dp[k][l], dp[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  n = <span class="built_in">read</span>();</span><br><span class="line">  m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    l = <span class="built_in">read</span>();</span><br><span class="line">    r = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(l - <span class="number">1</span>, r - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[leetcode]315. 计算右侧小于当前元素的个数</title>
      <link href="/2023/11/28/leetcode-315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2023/11/28/leetcode-315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>力扣315，没有花里胡哨的题面，属于树状数组的模版题了。正好复习一下BIT。先看题目：</p><h1 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="[计算右侧小于当前元素的个数]"></a>[计算右侧小于当前元素的个数]</h1><div class="table-container"><table><thead><tr><th style="text-align:center">Category</th><th style="text-align:center">Difficulty</th><th style="text-align:center">Likes</th><th style="text-align:center">Dislikes</th></tr></thead><tbody><tr><td style="text-align:center">algorithms</td><td style="text-align:center">Hard (43.45%)</td><td style="text-align:center">1032</td><td style="text-align:center">-</td></tr></tbody></table></div><p>给你一个整数数组 <code>nums</code> ，按要求返回一个新数组 <code>counts</code> 。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0] </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有 1 个更小的元素 (1)</span><br><span class="line">1 的右侧有 0 个更小的元素</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,-1]</span><br><span class="line">输出：[0,0]</span><br></pre></td></tr></table></figure><p>看完题目，很自然想到用树状数组来做。关于树状数组，可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组 - 知乎 (zhihu.com)</a></p><p>思路大概是：</p><ul><li>通过排序获得<code>num</code>中每个数在数组中的由小到大排位，该排位值就是该数在树状数组里的下标。</li><li>由于查询每个点时，我们只需要知道右侧元素中小于该数的元素数量。因此从右往左遍历数组，遍历到某一点时，可以保证右侧元素对应的树状数组位置已被更新过。先用<code>query</code>查询，再将用该数更新数组。</li><li>遍历完成，返回答案。</li></ul><p>下面是代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; loc &lt;= n; loc += <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">      tree[loc]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> loc)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; loc &gt; <span class="number">0</span>; loc -= <span class="built_in">lowbit</span>(loc)) &#123;</span><br><span class="line">      ans += tree[loc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    tree = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; sortNums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">locOfNum</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      sortNums.<span class="built_in">emplace_back</span>(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sortNums.<span class="built_in">begin</span>(), sortNums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      locOfNum[sortNums[i].second] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      result[i] = <span class="built_in">query</span>(locOfNum[i]);</span><br><span class="line">      <span class="built_in">update</span>(locOfNum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了用树状数组，还有没有其它O(nlogn)的算法呢？答案是有的。用归并排序求逆序对的数量也能解决本题。</p><p>首先定义<strong>逆序对</strong>。对于数组<code>nums</code>的下标<code>i</code>, <code>j</code>，若<code>i&lt;j</code>且<code>nums[i]&gt;nums[j]</code>，则称<code>(nums[i], nums[j])</code>是一对逆序对。题目中所要求的<code>count[i]</code>，就是以<code>nums[i]</code>为左边元素的逆序对的个数。这样问题就被转化为了求逆序对。</p><p>考虑由两个数组<code>L</code>, <code>R</code>，分别从两数组中取一个元素<code>a</code>和<code>b</code>，求使<code>(a, b)</code>为逆序对的取法由多少种。如果暴力枚举，复杂度为O(n<sup>2</sup>)，不符合我们的期望。然而，如果<code>L</code>和<code>R</code>是两个从小到大排列好的数组，问题将会很好解决。首先定义两个指针<code>p1</code>和<code>p2</code>，初始时分别指向<code>L</code>和<code>R</code>的第一个元素，然后执行以下算法：</p><p>1、右移<code>p2</code>直到<code>R[p2]&gt;=L[p1]</code>。由于<code>R[p2]</code>是数组<code>R</code>中第一个大于等于<code>L[p1]</code>的元素，即数组<code>R</code>中<code>p2</code>之前的元素均小于<code>L[p1]</code>，均能与<code>L[p1]</code>组成逆序对。故数组<code>R</code>开头到<code>p2</code>的元素个数就是能与<code>L[p1]</code>组成逆序对的元素个数。<br>2、右移<code>p1</code>，回到第一步求L中下一个元素能组成的逆序对个数。</p><p>该算法p1和p2均只经历一次遍历，时间复杂度为O(n)，符合我们的要求。然而这个算法只能求分别从两个数组各取一个元素所能组成的逆序对，不能求在同一个数组中元素形成的逆序对。为使用上述算法，我们希望找到一个办法，<strong>让数组中的任意两个元素都有且仅有一次地被置于两个数组之中，并按上述算法求判断它们能否组成逆序对</strong>。这样我们不会遗漏任一逆序对，也不会重复计算。归并排序恰好能实现我们的期望。归并排序每次都会将数组分成两个小数组，通过递归调用分别将这两个小数组排好序，再合并这两个数组。如果我们在两个小数组排序好之后，对这两个数组执行计算逆序对的算法，之后再合并，能否满足要求呢？下面我们证明确实可以。</p><ul><li>首先，证明<strong>任意两个元素都至少有一次被置于两个不同的数组中，且对这两个数组执行求逆序对算法</strong>。归并排序递归的终止状态是待排序的数组中只有一个元素。也就是说，数组中的每一个元素，最初都处于只含有自己一个元素的数组中。而在排序的最后，所有元素都处在同一个数组中。也就是说，数组中的任意两个元素，最初都在不同的数组中，然而有一个合并的过程，将它们所在的两个数组合并为一个数组。只要在该次合并之前执行求逆序对算法，就能保证任意两个元素都有一次被置于两个不同的数组中求逆序对。</li><li>接着，证明<strong>任意两个元素被分别置于两个数组求逆序对的经历只有一次</strong>。我们已经证明的该过程必有一次。而经历了这一次之后，两个元素被合并到同一个数组之中，以后不可能再被置于不同数组中了。因此可以保证只有一次。</li><li>容易知道，原数组中的任意两个元素<code>a</code>和<code>b</code>，若<code>a</code>位于<code>b</code>的左侧，则在归并排序过程中，<code>a</code>所在的数组和<code>b</code>所在的数组在执行求逆序对过程中，<code>a</code>所在数组一定在<code>b</code>所在数组左侧。</li></ul><p>证明完成。另外还有一点，排序之后元素顺序被打乱了，但我们需要知道每个元素在原数组中的下标，以将其所能组成的逆序对数量记录在数组counts的相应位置。我们可以将原数组中的元素换成二元组<code>(元素值，下标)</code>。如此我们在排序过程中就能知道元素在原数组中的下标了。至此，思路已经很清晰了，下面看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;pii&gt; tem;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;pii&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, begin, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="type">int</span> l = begin;</span><br><span class="line">    <span class="type">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">      <span class="keyword">while</span> (r &lt;= end &amp;&amp; nums[r] &lt; nums[l]) r++;</span><br><span class="line">      result[nums[l].second] += (r - mid - <span class="number">1</span>);</span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = begin;</span><br><span class="line">    l = begin;</span><br><span class="line">    r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[l] &lt; nums[r]) &#123;</span><br><span class="line">        tem[k++] = nums[l++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tem[k++] = nums[r++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">      tem[k++] = nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; r; i++) &#123;</span><br><span class="line">      nums[i] = tem[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    result = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    tem = <span class="built_in">vector</span>&lt;pii&gt;(n);</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">indexNums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      indexNums[i] = &#123;nums[i], i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MergeSort</span>(indexNums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231128小记</title>
      <link href="/2023/11/28/20231128%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/11/28/20231128%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>近日思绪繁多，终得明朗，记于此。</p><span id="more"></span><p>近日常思考今后的学习方向，是研究技术搞开发，还是研究算法搞理论。不是算法学不起，学习技术更有性价比。学习算法成本高风险大。但若学有所成，不论是对学业还是未来工作都大有所益。故算法这条道虽难走，但亦值得一试。犹豫之时，忽忆起前日前辈经验分享会上一席话：“你们才大二，有的是试错的机会。如果犹豫走哪个方向，不如都试一试。“既然如此，即可放手一搏，研究算法之道。既定下决心，记于此处，以自勉。</p><p>今日起，日刷力扣五题，并力肝算法导论一书。每周末小记本周学习心得与收获，总结反思，亦可记录成长的足迹。</p><p>“行路难！行路难！多歧路，今安在？”。惟愿“长风破浪会有时，直挂云帆济沧海”！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS-PA3 实验记录</title>
      <link href="/2023/11/15/ICS-PA3%20docs/"/>
      <url>/2023/11/15/ICS-PA3%20docs/</url>
      
        <content type="html"><![CDATA[<p>记录一下pa的完成过程。前面的pa1和pa2没有记录，等以后有机会二刷再补上吧。</p><span id="more"></span><h2 id="PA3-1"><a href="#PA3-1" class="headerlink" title="PA3-1"></a>PA3-1</h2><p>PA3的第一阶段是实现异常响应机制。为实现异常响应，需要添加几个特殊寄存器，称为控制和状态寄存器（CSR）。PA中需要用到的包括：</p><div class="table-container"><table><thead><tr><th style="text-align:center">CSR</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">mepc</td><td style="text-align:center">存放触发异常的PC</td></tr><tr><td style="text-align:center">mcause</td><td style="text-align:center">存放触发异常的原因</td></tr><tr><td style="text-align:center">mstatus</td><td style="text-align:center">存放处理器的状态</td></tr><tr><td style="text-align:center">mtvec</td><td style="text-align:center">存放异常入口地址</td></tr></tbody></table></div><p>触发异常前，需要调用cte_init()函数进行初始化，将异常入口地址存到mtvec寄存器中，并注册一个事件处理回调函数，当触发异常时，将会以上下文信息和信息为参数调用此回调函数，执行异常处理操作。</p><p>RISCV32通过ecall指令触发自陷。具体来说，ecall指令执行的操作为：</p><ul><li>CSR[mepc] &lt;- pc</li><li>CSR[mcause] &lt;- 异常号</li><li>PC &lt;- CSR[mtvec] （执行异常响应程序）</li></ul><p>完成异常响应程序后，恢复上下文信息，通过mret指令将PC从mepc中恢复（并+4），从中断处继续执行。</p><p>大致理解机制之后，再RTFM和RTFSC之后就可以敲代码了。</p><p>首先是在代码中添加寄存器，直接加一个数组就好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">word_t</span> gpr[MUXDEF(CONFIG_RVE, <span class="number">16</span>, <span class="number">32</span>)];</span><br><span class="line">  <span class="type">vaddr_t</span> pc;</span><br><span class="line">  <span class="type">word_t</span> csr[<span class="number">4</span>];</span><br><span class="line">&#125; MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);</span><br></pre></td></tr></table></figure><p>接下来实现csrr和cswr指令，实现CSR的读写。这两条指令是通过I类指令的立即数来指代某一个CSR的，通过RTFM可以找到找到寄存器对应的代码。</p><p><img src="f70598671b2221a0543914666a6f06b.png" alt="f70598671b2221a0543914666a6f06b"></p><p>方便起见，写一个函数将代码做个映射：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">checkCSR</span><span class="params">(<span class="type">int</span> gr)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (gr)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x342</span>: <span class="comment">//mcause</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x300</span>: <span class="comment">//mstatus</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x341</span>: <span class="comment">//mepc</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x305</span>: <span class="comment">//mtvec</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    panic(<span class="string">&quot;Unknow csr %x&quot;</span>, gr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再定义一个宏来访问对应的寄存器，这样就能很方便的查找CSR了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CSRs(gr) (cpu.csr[checkCSR(gr)])</span></span><br></pre></td></tr></table></figure></p><p>实现指令就是直接抄手册了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 001 ????? 11100 11&quot;</span>, csrrw  , I, <span class="type">word_t</span> t = CSRs(imm); CSRs(imm) = src1; R(rd) = t); </span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? 010 ????? 11100 11&quot;</span>, csrrs  , I, <span class="type">word_t</span> t = CSRs(imm); CSRs(imm) = (t | src1); R(rd) = t);</span><br></pre></td></tr></table></figure></p><p>接下来实现ecall指令。ecall的操作在isa_raise_intr()函数里实现，按要求写就行，没啥别的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">word_t</span> <span class="title function_">isa_raise_intr</span><span class="params">(<span class="type">word_t</span> NO, <span class="type">vaddr_t</span> epc)</span> &#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cpu.csr[<span class="number">2</span>] = epc;</span><br><span class="line">  cpu.csr[<span class="number">0</span>] = NO;</span><br><span class="line">  <span class="keyword">return</span> cpu.csr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的实现很简单，主要问题是参数NO从哪来？查手册发现riscv自陷Exception Code是11, 所以ecall指令的操作就是以11和PC值为参数调用isa_raise_intr()，再将函数返回值赋值给s-&gt;dnpc就可以了。</p><p>最后mret指令就更容易了，置PC就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(<span class="string">&quot;0000000 00000 00000 000 00000 11100 11&quot;</span>, ecall  , I, s-&gt;dnpc = isa_raise_intr(<span class="number">11</span>, s-&gt;pc));</span><br><span class="line">INSTPAT(<span class="string">&quot;0011000 00010 00000 000 00000 11100 11&quot;</span>, mret   , R, s-&gt;dnpc = CSRs(<span class="number">0x341</span>) + <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><p>再此尝试运行yield test，得到错误输出“Unhandled event”。发现是在注册的回调函数simple_trap()中，事件编号错误。想了很久才发现原因：</p><p>执行ecall之后会跳转到__am_asm_trap函数，这个函数是用汇编写的，定义在trap.S中。此函数会保存上下文信息，然后跳转到__am_irq_handle()函数，这个函数参数为刚才保存的上下文信息Context，包含通用寄存器和CSR的值。它将根据mcause的值设置事件编号，并调用回调函数。默认时事件编号都会被设置为EVENT_ERROR，肯定会发生错误，所以添加一条case，mcause为11时事件编号设为EVENT_YIELD，这样一来理论上应该就没问题了。</p><p>然而还是出错了。。。</p><p>再是一番冥思苦想，发现am_asm_trap里一串代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)</span><br><span class="line">#define OFFSET_STATUS ((NR_REGS + 1) * XLEN)</span><br><span class="line">#define OFFSET_EPC    ((NR_REGS + 2) * XLEN)</span><br></pre></td></tr></table></figure></p><p>这几个宏定义的是设置参数Context时三个寄存器在栈中的位移，按顺序应该是mcause, mstatus, mepc，并且都是更在32个通用寄存器后面。但Context结构体却是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> fix the order of these members to match trap.S</span></span><br><span class="line">  <span class="type">uintptr_t</span>  mcause, mstatus, gpr[NR_REGS], mepc;</span><br><span class="line">  <span class="type">void</span> *pdir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>明显顺序有误，应该调整一下顺序。改完之后yield test就通了。</p><p>写到这里我真的心情复杂，这么难发现的坑怎么不再文档里面说？？气愤之时继续往下做，突然发现后面文档里面有写要调整结构体顺序。。。原来是我没看完文档，只看了第一部分就开始做，结果绕了大弯。而且糊里糊涂地把后面的内容都做完了。。。不过虽然走了弯路耗时长了一点，但相应的理解也更深刻了。算是吸取个教训，以后要看完文档再动手。</p><p>最后的etrace轻松完成，至此第一阶段完成，耗时4小时。（大部分时间在走弯路。。。）</p><h5 id="必答题-理解上下文结构体的前世今生"><a href="#必答题-理解上下文结构体的前世今生" class="headerlink" title="必答题- 理解上下文结构体的前世今生"></a>必答题- 理解上下文结构体的前世今生</h5><blockquote><p>你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>, <code>c</code>指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? <code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?</p></blockquote><p>上下文结构体在__am_asm_trap()函数的调用栈中。阅读trap.S的代码可以知道，32个通用寄存器、三个CSR依次被压入栈中，依次完成Context结构体的赋值。之后作为参数传入__am_irq_handle()函数。</p><h5 id="必答题-理解穿越时空的旅程"><a href="#必答题-理解穿越时空的旅程" class="headerlink" title="必答题 - 理解穿越时空的旅程"></a>必答题 - 理解穿越时空的旅程</h5><blockquote><p>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么? 软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量. 事实上, 上文的必答题”理解上下文结构体的前世今生”已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.</p></blockquote><p>yield test中，首先调用cte_init()进行初始化，具体操作为：<br>1、将__am_asm_trap()函数的地址存在mtvec寄存器中。<br> 2、注册回调函数simple_trap。<br> 然后进入hello_intr()函数，输出一些信息。然后进入循环调用yield()函数。yield()函数使用内联汇编”li a7 -1”指令将异常号存在a7中，然后执行指令ecall。ecall指令依次完成一下操作：<br> 1、CSR[mepc] &lt;- pc<br> 2、CSR[mcause] &lt;- a7<br> 3、PC &lt;- CSR[mtvec]<br> 这时PC将会指向__am_asm_trap函数并执行。此函数首先会将32个通用寄存器、3个CSR的值压入栈中，构成Context结构体c，将该结构体作为参数调用__am_irq_handle()函数。此函数会定义一个Event结构体，根据c中储存有的mcause值，设置Event结构体的事件编号，再以Context和Event两个结构体为参数调用之前注册的回调函数simple_trap()。此函数会根据Event结构体中的事件编号识别事件，做出相应的输出。由于循环很大，程序会不断输出y，之后退出异常响应是否正确实现不得而知。</p><h2 id="PA3-2"><a href="#PA3-2" class="headerlink" title="PA3-2"></a>PA3-2</h2><p>PA3第二阶段主要是引入操作系统nanos-lite，实现操作系统加载用户程序和系统调用。目前nanos-lite的功能很简陋，大概看一下main.c就大致明白它的工作流程了：初始化设备和存储器，加载程序，最后触发yield自陷。</p><p>我们的第一个任务时使操作系统能加载程序，即实现loader()。这里的程序指的是ELF文件，它存放在硬盘(ramdisk.img)。我们需要解析ELF文件，并将其加载到运行时内存。解析ELF可以按照以下流程：</p><ul><li><p>读取ELF头，根据魔数e_ident检查是否为ELF文件。</p></li><li><p>从ELF头获取程序头program header的位移e_phoff和程序头的数量e_phnum。</p></li><li>逐个读取程序头，判断其类型是否为PT_LOAD。</li><li>若是，将该节加载到内存。加载的地址、长度都包含在程序头里面了。</li><li>完成加载，loader()函数返回程序入口e_entry。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> <span class="title function_">loader</span><span class="params">(PCB *pcb, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> phdr_size = <span class="keyword">sizeof</span>(Elf_Phdr);</span><br><span class="line">  Elf_Ehdr *ehdr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  Elf_Phdr *phdr = <span class="built_in">malloc</span>(phdr_size);</span><br><span class="line">  ramdisk_read((<span class="type">void</span>*)ehdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  assert(*(<span class="type">uint32_t</span> *)ehdr-&gt;e_ident == <span class="number">0x464c457f</span>);</span><br><span class="line">  assert(EXPECT_TYPE == ehdr-&gt;e_machine);</span><br><span class="line">  <span class="type">uint32_t</span> phdr_num = ehdr-&gt;e_phnum;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; phdr_num; i++) &#123;</span><br><span class="line">    ramdisk_read((<span class="type">void</span>*)phdr, ehdr-&gt;e_phoff + i * phdr_size, phdr_size);</span><br><span class="line">    <span class="keyword">if</span>(phdr-&gt;p_type != PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">    ramdisk_read((<span class="type">void</span>*)phdr-&gt;p_vaddr, phdr-&gt;p_offset, phdr-&gt;p_filesz);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)phdr-&gt;p_vaddr + phdr-&gt;p_filesz, <span class="number">0</span>, phdr-&gt;p_memsz - phdr-&gt;p_filesz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ehdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在init_proc()里调用naive_uload()，naive_uload()会加载硬盘中的程序，并获取入口地址，跳转到入口地址执行。这样操作系统就能够加载用户程序并执行了。</p><p>接下来编译并在nanos运行dummy。第一次编译dummy可能需要重启ternimal，应该刚配置的NAVY_HOME环境变量还没生效，Makefile还无法识别。</p><p>dummy程序会触发系统调用。触发系统调用和上一阶段实现的自陷都是用ecall指令实现的，如何区分它们？阅读源码可知，系统调用前会往GPR1(a7)里面填入type，yield()在ecall之前也会往a7里填入-1。因此，我们可以根据a7里的值区分EVENT_YIELD和EVENT_SYSCALL。而寄存器内容都保存在上下文信息c里面了，我们很容易读取。因此，修改cte.c内代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Context* __am_irq_handle(Context *c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user_handler) &#123;</span><br><span class="line">    Event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (c-&gt;mcause) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>: </span><br><span class="line">        <span class="keyword">if</span>(c-&gt;GPR1 == <span class="number">-1</span>) ev.event = EVENT_YIELD;</span><br><span class="line">        <span class="keyword">else</span> ev.event = EVENT_SYSCALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ev.event = EVENT_ERROR; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = user_handler(ev, c);</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定事件类型之后会调用注册的回调函数。在nanos中为do_event()。这里做点简单判断就行了，如果是EVENT_SYSCALL就交给do_syscall()处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Context* <span class="title function_">do_event</span><span class="params">(Event e, Context* c)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.event) &#123;</span><br><span class="line">    <span class="keyword">case</span> EVENT_YIELD: <span class="built_in">printf</span>(<span class="string">&quot;Event: yield!\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EVENT_SYSCALL: do_syscall(c); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">&quot;Unhandled eventdd ID = %d&quot;</span>, e.event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用也有不同的类型。在do_syscall里，我们只需要根据GPR1识别系统调用类型，然后把任务分配给给个sys_xxx()函数实现系统调用即可。实现sys_yield和sys_exit，dummy就可以通了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_yield</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  yield();</span><br><span class="line">  c-&gt;GPRx = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  halt(c-&gt;GPR1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现标准输出sys_write，这里按照手册写就可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_write</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = (<span class="type">int</span>)c-&gt;GPR2;</span><br><span class="line">  <span class="type">void</span> *buf = (<span class="type">void</span> *)c-&gt;GPR3;</span><br><span class="line">  <span class="type">size_t</span> count = (<span class="type">size_t</span>)c-&gt;GPR4;</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">1</span> || fd == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      putch(((<span class="type">char</span> *)buf)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  c-&gt;GPRx = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们还需要给用户程序提供标准输入的接口_write()，把系统调用抽象成一个屏蔽底层细节的接口。其实将系统调用做个封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count) &#123;</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_write, fd, (<span class="type">intptr_t</span>)buf, count); <span class="comment">//记得设返回值，不然printf会重复输出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是实现堆区管理。这里的用户接口是_sbrk(int increment)，参数是请求分配的长度。它负责维护program break，即当前堆区终点。其工作方式如下：</p><ul><li>将program break初始化到end位置。</li><li>被调用时，计算新的program break = program_bread + increment。</li><li>通过SYS_brk向操作系统请求分配到新program break的堆空间。</li><li>若系统调用返回0，分配成功，更新program break，并将旧program break的值作为返回值返回。</li><li>若失败，返回-1。</li></ul><p>这里end的使用方法需要查手册。end是一个被放在程序数据段结尾的字符，&amp;end可以读出它的地址，即数据段结尾地址，也就是堆区起点。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end;</span><br><span class="line"><span class="type">void</span> *program_break = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> *_sbrk(<span class="type">intptr_t</span> increment) &#123;</span><br><span class="line">  <span class="keyword">if</span> (program_break == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    program_break = &amp;end; <span class="comment">//如果是第一次被调用，要初始化program_break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">void</span> *addr = program_break + increment;</span><br><span class="line">  <span class="keyword">if</span> (_syscall_(SYS_brk, (<span class="type">intptr_t</span>)addr, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    program_break = addr;</span><br><span class="line">    <span class="keyword">return</span> addr - increment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_brk</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行hello就可以顺利输出字符串了。</p><p>PA3-2 over!</p><h5 id="必答题-hello程序是什么-它从而何来-要到哪里去"><a href="#必答题-hello程序是什么-它从而何来-要到哪里去" class="headerlink" title="必答题 - hello程序是什么, 它从而何来, 要到哪里去"></a>必答题 - hello程序是什么, 它从而何来, 要到哪里去</h5><blockquote><p>我们知道<code>navy-apps/tests/hello/hello.c</code>只是一个C源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?</p></blockquote><p>hello被编译成ELF文件后，我们将它放进了硬盘(ramdisk.img)里，然后nanos在执行到init_proc()时，调用naive_uload()，naive_uload()又调用loader()加载ramdisk.img里面的hello程序。loader()会依次读取hello的ELF头和program header，根据从program header获取需要加载的内容在ELF中的位置、要加载到的内存位置、需加载的文件长度等信息，根据这些信息将程序加载到内存空间。它的第一条指令由ELF头的e_entry指示，它是loader函数的返回值。naive_uload获取到入口地址之后就跳转到第一条指令开始执行。</p><p>hello通过printf()输出字符串。printf在经过一系列逻辑处理之后，通过标准输出的用户接口_write()。这个函数会将参数储存在规定的寄存器中，然后触发SYS_write的系统调用。当程序运行到ecall时，跳转到中断响应程序。识别事件类型为系统调用后，交给nanos注册的回调函数do_event处理。do_event识别系统调用类型为SYS_write，调用sys_write，最后通过putch一个个输出字符。</p><h2 id="PA3-3"><a href="#PA3-3" class="headerlink" title="PA3-3"></a>PA3-3</h2><h3 id="简易文件系统"><a href="#简易文件系统" class="headerlink" title="简易文件系统"></a>简易文件系统</h3><p>下面在nanos里实现一个简易文件系统。PA中的硬盘是用ramdisk.img这个文件模拟的。每次更新navy-apps中的内容并编译更新之后，更新的文件会被载入到ramdisk.img文件中，同时更新文件记录表ramdisk.h。需要读取某一个文件时，只需要查这个表，获得所需文件在ramdisk.img内的位置和长度，然后读取文件即可。框架代码已经实现了部分功能，我们只需要实现以下四个函数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>这些函数在c语言中都有原型，可以通过手册查看它们的功能。</p><p>首先是fs_open。我们可以无视flags和mode，只关注文件名pathname即可。这个函数需要在文件目录内查找匹配文件名，然后返回文件描述符。这里文件描述符直接用文件记录表中的下标，之后读写文件就可以用这个下标来访问文件了。</p><p>实现另外几个函数之前，先给Finfo结构体增加一个成员变量open_offset，用于记录此文件的目前操作位置。每次读写几个字节，open_offset就增加多少，这样下次读写文件就可以直接从上次的末尾继续了。</p><p>fs_read()和fs_write()的实现类似。首先，为防止操作越过文件边界，确定最大文件读写长度，为<code>文件大小-open_offset</code>和参数<code>len</code>的较小值。然后通过<code>ramdisk_read()</code>和<code>ramdisk_write()</code>对文件进行读写。最后修改<code>open_offset</code>。</p><p>另外，stdin, stdout, stderr是虚拟的文件，ramdisk内不存在并没有它们，所以对它们读写需要特殊操作。我们只需要处理stdout和stderr的写入。注意到，Finfo结构体有两个函数变量read和write。普通文件的这两个变量为空，它们应该用正常方式读写。特殊文件这两个变量不为空时，需要用这两个函数读写。stdout和stderr的写入就是将字符输出到串口。所以我们需要实现device.c中的serial_write()，通过putch把buf存储的字符串一个个输出来。然后修改file_table，把stdin和stdout的write函数修改成serial_write。最后还要在fs_read()和fs_write()里做个判断，如果存在特殊读写函数，调用读写函数；否则，按普通方式读写文件。</p><p>最后实现fs_leek()。这个函数将open_offset移动到指定为止。根据whence，有三种不同的偏移方式：</p><ul><li>SEEK_SET：从文件头开始偏移，open_offset = offset</li><li>SEEK_CUR：从当前位置开始偏移，open_offset += offset</li><li>SEEK_END：从文件末尾开始偏移，open_offset = file_size + offset （此时offset一般为负数；offset为0可读取文件长度）</li></ul><p>最后还要检查是否超出文件边界。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fs_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_files; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pathname, file_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">      file_table[i].open_offset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;no such file&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (file_table[fd].read) <span class="keyword">return</span> file_table[fd].read(buf, file_table[fd].open_offset, len);</span><br><span class="line">  <span class="type">size_t</span> max_len = file_table[fd].size - file_table[fd].open_offset;</span><br><span class="line">  len = len &lt; max_len ? len : max_len;</span><br><span class="line">  <span class="type">int</span> rl = ramdisk_read(buf, file_table[fd].disk_offset + file_table[fd].open_offset, len);</span><br><span class="line">  file_table[fd].open_offset += len;</span><br><span class="line">  <span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (file_table[fd].write) <span class="keyword">return</span> file_table[fd].write(buf, file_table[fd].open_offset, len);</span><br><span class="line">  <span class="type">size_t</span> max_len = file_table[fd].size - file_table[fd].open_offset;</span><br><span class="line">  len = len &lt; max_len ? len : max_len;</span><br><span class="line">  <span class="type">int</span> rl = ramdisk_write(buf, file_table[fd].disk_offset + file_table[fd].open_offset, len);</span><br><span class="line">  file_table[fd].open_offset += len;</span><br><span class="line">  <span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fs_lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> offset, <span class="type">int</span> whence)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> new_offset;</span><br><span class="line">  <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEEK_SET: new_offset = offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_CUR: new_offset = file_table[fd].open_offset + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEEK_END: new_offset = file_table[fd].size + offset; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_offset &gt;= file_table[fd].size) new_offset = file_table[fd].size;</span><br><span class="line">  file_table[fd].open_offset = new_offset;</span><br><span class="line">  <span class="keyword">return</span> new_offset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fs_close</span><span class="params">(<span class="type">int</span> fd)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>接下来在Navy和Nanos的syscall.c里添加相应的系统调用，就可以通过file_test了。</p><p>之前实现的loader默认要执行的程序放在文件开头，现在有了文件系统，就可以通过文件名找到程序在文件中的位置了。实现很简单，在loader函数中，先用fs_open打开文件，获取文件描述符fd，下面用fs_read(fd, …)操作就行了。完成之后，修改proc.c的init_proc()函数，调用naive_uload()时第二个参数改为“/bin/file-test”，就可以将要执行的文件名传给loader了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load program here</span></span><br><span class="line">naive_uload(<span class="literal">NULL</span>, <span class="string">&quot;/bin/file-test&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在Navy的Makefile内，test后加上file-test，update，run，运行测试。PASS！</p><h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><p>时钟时输入设备，但一般通过一个单独的系统调用来获取时间，而不是抽象成文件。获取时间使用系统调用gettimeofday。下面实现此系统调用。sys_gettimeofday()函数需要用io_read()获取当前时刻，将当前时刻的秒和微秒写入一个结构体Timeval。PA2实现的ioe忘记怎么用了，重温~/ics2023/abstract-machine/am/src/platform/nemu/ioe/。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_gettimeofday</span><span class="params">(Context *c)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">tv</span> =</span> (<span class="keyword">struct</span> timeval *)c-&gt;GPR2;</span><br><span class="line">  <span class="type">uint64_t</span> time = io_read(AM_TIMER_UPTIME).us; </span><br><span class="line">  tv-&gt;tv_sec = time / <span class="number">1000000</span>;</span><br><span class="line">  tv-&gt;tv_usec = time % <span class="number">1000000</span>;</span><br><span class="line">  c-&gt;GPRx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加系统调用。下面实现NDL_GetTicks()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">NDL_GetTicks</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">   gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个ioe是键盘。操作系统要向用户程序传递键盘信息，首先要规定信息的格式。我们使用简单的字符串</p><ul><li>按下按键事件, 如<code>kd RETURN</code>表示按下回车键</li><li>松开按键事件, 如<code>ku A</code>表示松开<code>A</code>键</li></ul><p>用户程序通过系统调用请求键盘信息时，操作系统直接将上述字符串填入buf，传给用户程序。这样，用户程序就可以像读取文件一样读取键盘信息了。所以，把键盘抽象成一个虚拟文件<code>/dev/events</code>，并用函数events_read()来读取信息。在file_table添加表项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, events_read&#125; <span class="comment">// 不必实现lseek，位移和大小都是0就行</span></span><br></pre></td></tr></table></figure><p>接下来需要实现events_read()。用io_read(AM_INPUT_KEYBRD)读取键盘信息，然后写入字符串。这里我为了防止字符串长度超出限制，先填入另一个字符串，确定长度之后再写入buf。或许有点过分谨慎了。。。而且应该用sprintf更优雅，但是懒得改了。最后在字符串末尾填0，不然后续问题很麻烦。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">events_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123; </span><br><span class="line">  <span class="comment">//这段代码写得及其丑陋。。。</span></span><br><span class="line">  <span class="type">int</span> real_len = <span class="number">0</span>; </span><br><span class="line">  <span class="type">char</span> str_buf[<span class="number">15</span>];</span><br><span class="line">  AM_INPUT_KEYBRD_T kbd = io_read(AM_INPUT_KEYBRD);</span><br><span class="line">  <span class="keyword">if</span> (kbd.keycode == AM_KEY_NONE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (kbd.keydown) <span class="built_in">strcpy</span>(str_buf, <span class="string">&quot;kd &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">strcpy</span>(str_buf, <span class="string">&quot;ku &quot;</span>);</span><br><span class="line">  real_len += <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(str_buf + real_len, keyname[kbd.keycode]);</span><br><span class="line">  real_len += <span class="built_in">strlen</span>(keyname[kbd.keycode]);</span><br><span class="line">  len = len &lt; real_len ? len : real_len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    ((<span class="type">char</span> *)buf)[i] = str_buf[i];</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">char</span> *)buf)[len] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> NDL_PollEvent()就很简单了，用读文件的方式读取键盘就可以了。返回值需要注意一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_PollEvent</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/events&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ret = read(fd, buf, len);</span><br><span class="line">  <span class="keyword">return</span> ret == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是VGA。我们需要添加两个虚拟文件：显存(fb)和屏幕尺寸信息(dispinfo)，并使用特殊写入函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, fb_write&#125;,</span><br><span class="line">&#123;<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, dispinfo_read&#125;,</span><br></pre></td></tr></table></figure><p>跟键盘信息一样，屏幕信息也用字符串表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WIDTH : <span class="number">400</span></span><br><span class="line">HEIGHT : <span class="number">300</span></span><br></pre></td></tr></table></figure><p>所以，dispinfo_read()要做的就是把读取屏幕信息，并把字符串填入buf。另外，由于下面实现fb_write()需要屏幕长宽信息，所以在dispinfo_read()读取屏幕长宽之后，我顺便把它们存起来，方便后面使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> screen_w = <span class="number">0</span>, screen_h = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">dispinfo_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_GPU_CONFIG_T cfg = io_read(AM_GPU_CONFIG);</span><br><span class="line">  screen_w = cfg.width; screen_h = cfg.height;</span><br><span class="line">  <span class="comment">// snprintf, 如此优雅！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, len, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, screen_w, screen_h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是显存。由于它需要支持lseek，但我们无法在编写代码时确定文件大小（即屏幕大小），需要在inif_fs()中初始化显存大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> initialize the size of /dev/fb</span></span><br><span class="line">file_table[FD_FB].size = io_read(AM_GPU_CONFIG).vmemsz;</span><br></pre></td></tr></table></figure><p>接下来是实现fb_write()，需要调用io_write(AM_GPU_FBDRAW, …)写入显存。由于fb_write()只知道写入的起始位置和长度，不知道应该在何处换行，因此虽然io_write(AM_GPU_FBDRAW, …)能同时填充多行的矩形，fb_write()一次调用也只能填充一行。在dispinfo_read()被调用时已经保存了屏幕长宽，再根据offset就可以计算出写入的起始坐标了。因为只能写一行，填入矩形的宽为len，高为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="comment">// 以四字节为一个单位，需要做一些转化。</span></span><br><span class="line">  io_write(AM_GPU_FBDRAW, (offset % (screen_w * <span class="number">4</span>)) / <span class="number">4</span>,</span><br><span class="line">           offset / (screen_w * <span class="number">4</span>), (<span class="type">uint32_t</span> *)buf, len / <span class="number">4</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备好了操作系统写入显存的功能，就可以实现NDL的一些图像函数了。在NDL中，我们也需要直到屏幕的尺寸，所以可以在NDL_init()里首先从/proc/dispinfo文件读出屏幕信息并记录在全局变量screen_w和screen_h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NDL_Init</span><span class="params">(<span class="type">uint32_t</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> dispinfo = open(<span class="string">&quot;/proc/dispinfo&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  read(dispinfo, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH : %d\nHEIGHT : %d\n&quot;</span>, &amp;screen_w, &amp;screen_h);</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;NWM_APP&quot;</span>)) &#123;</span><br><span class="line">    evtdev = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NDL_OpenCanvas()只需要记录画布大小即可。查阅API手册，发现若NDL_OpenCanvas()传入的参数w, h都指向0，需要分别修改为屏幕长和高，即让画布占满屏幕。否则将画布长和高设为w和h，并将画布长和高记录在全局变量canvas_w和canvas_h里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(*w == <span class="number">0</span> &amp;&amp; *h == <span class="number">0</span>) &#123;</span><br><span class="line">    *w = screen_w;</span><br><span class="line">    *h = screen_h;</span><br><span class="line">  &#125; </span><br><span class="line">  canvas_w = *w;</span><br><span class="line">  canvas_h = *h;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写下来是NDL_DrawRect()。它需要把一个颜色信息填充到指定位置的矩形矩形。由于上面实现的写入显存只能逐行写入，这里也需要逐行填充。先打开显存文件/dev/fb，写入每一行前，先用lseek把文件指针移动到此行要写入的第一个像素点处，再写入一行的信息。同样需要注意一单位为四字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_DrawRect</span><span class="params">(<span class="type">uint32_t</span> *pixels, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fd, (screen_w * (i + y) + x) * <span class="number">4</span>, SEEK_SET);</span><br><span class="line">    write(fd, pixels + w * i, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行bmp-test可以看到屏幕上显示Logo。</p><p><img src="9d1f5d7b92ded7a96638233931b2731.png" alt="9d1f5d7b92ded7a96638233931b2731"></p><h3 id="更丰富的运行时环境"><a href="#更丰富的运行时环境" class="headerlink" title="更丰富的运行时环境"></a>更丰富的运行时环境</h3><p>PA3剩下的部分基本是去运行一些应用程序了。很多应用程序都会调用SDL库，而SDL库大部分函数都没有实现。为了防止程序运行时用到了某个没有实现的函数还傻傻没发现，我们先在每个未实现函数中加一句assert(0)。若程序调用某个未实现函数，程序就会立即停止，我们就很容易找到它了。</p><p>nemu没有实现浮点数运算，但是可以用定点算数来进行实数运算。这是一种不同于IEEE754的一种及其简单的32位实数表示法。简单来说就是前24位是整数位，后8位是小数位。这种表示法的实数做加减法运算只需要将它当场整数运算就行。做乘法需要相乘后右移八位，做除法需要相除后左移八位。这样一来，即使硬件不支持实数运算，也可以用软件来实现了。这里只涉及一些简单的数学推导，难度不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Multiplies a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_muli</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A * B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Divides a fixedpt number with an integer, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_divi</span><span class="params">(fixedpt A, <span class="type">int</span> B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A / B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Multiplies two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_mul</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">int64_t</span>)A * B) &gt;&gt; FIXEDPT_FBITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Divides two fixedpt numbers, returns the result. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_div</span><span class="params">(fixedpt A, fixedpt B)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">uint64_t</span>)(A &lt;&lt; FIXEDPT_FBITS) / B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_abs</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A &gt; <span class="number">0</span> ? A : -A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_floor</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (A &gt;&gt; FIXEDPT_FBITS) &lt;&lt; FIXEDPT_FBITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fixedpt <span class="title function_">fixedpt_ceil</span><span class="params">(fixedpt A)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fixedpt_floor(A + <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navy中的应用程序"><a href="#Navy中的应用程序" class="headerlink" title="Navy中的应用程序"></a>Navy中的应用程序</h3><p>尝试在Nanos中运行NSlider播放幻灯片。需要实现void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h)。先看它的参数，s是一个SDL_Surface结构体，包含了一帧画面信息。其变量w, h是画布长和高，pixels数组是每个像素点的颜色，按行优先排列。其实SDL_UpdateRect()和NDL_DrawRect()实现的功能基本相同。只是SDL_UpdateRect()的参数s中包含了整个屏幕的颜色信息，而NDL_DrawRect()的参数pixels只含有需要填充的矩形的颜色信息。故SDL_UpdateRect()只需要将从s-&gt;pexels中提取中需要填充的矩形的颜色信息，再调用NDL_DrawRect()就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_UpdateRect</span><span class="params">(SDL_Surface *s, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>) &#123; <span class="comment">// w=h=0时，使用默认大小即全屏</span></span><br><span class="line">    w = s-&gt;w;</span><br><span class="line">    h = s-&gt;h;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="type">uint32_t</span> *pixel = <span class="built_in">malloc</span>(w * h * <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> *src = (<span class="type">uint32_t</span> *)s-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(pixel + w * i, src + (y + i) * s-&gt;w + x, w * <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  NDL_DrawRect(pixel, x, y, w, h);</span><br><span class="line">  <span class="built_in">free</span>(pixel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个要实现的SDL函数是 SDL_WaitEvent()。这个函数不停通过NDL_PollEvent()读取键盘信息，直到读取到键盘按下或弹起，然后根据读入字符串的第2位是’d’还是’u’来判断是键盘按下还是弹起，再把字符串第4位起的子字符串与keyname中的按键名称逐一比对，确定按键。将按键信息存入传入的结构体指针，再返回1。实现了这个函数就可以通过按键给幻灯片翻页了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_WaitEvent</span><span class="params">(SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    event-&gt;type = buf[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span> ? SDL_KEYUP : SDL_KEYDOWN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">83</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyname[i], buf + <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        event-&gt;key.keysym.sym = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后可以将导入的PDF转化成幻灯片显示出来了。运行convert.sh前需要先<code>sudo apt install imagemagick</code>，安装ImageMagick。运行nslider就可以看到幻灯片了。还能通过up和down键翻页。</p><p><img src="09be4fd6e56ae4ae02d45830c7d0fe9.png" alt="09be4fd6e56ae4ae02d45830c7d0fe9"></p><p>下一个应用程序是开机菜单Menu。需要实现两个SDL函数：SDL_BlitSurface()和SDL_FillRect()。</p><p>SDL_BlitSurface():将一张画布中的指定矩形区域复制到另一张画布的指定位置。首先需要确定源矩形和目标矩形的位置，以及矩形大小。需要分别考虑srcrect和dstrect分别为空和非空的情况。按以下规定来确定。</p><ul><li>规定符号 w: 画布宽 h: 画布高 (sx, sy): 源矩形位置坐标 (dx, dy): 目标矩形位置坐标</li><li>srcrect不为空时， 按srcrect设置w, h, sx, sy；</li><li>srcrect为空时，(sx, xy) = (0, 0)，w, h设为src的w, h(画布的宽和高)，即整个画布；</li><li>dstrect不为空时，按dstrect设置dx, dy；</li><li>dstrect为空时，(dx, dy) = (0, 0)。</li></ul><p>之后将src-&gt;pixels的内容复制到dst-&gt;pixels对应位置就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_BlitSurface</span><span class="params">(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst,</span></span><br><span class="line"><span class="params">                     SDL_Rect *dstrect)</span> &#123;</span><br><span class="line">  assert(dst &amp;&amp; src);</span><br><span class="line">  assert(dst-&gt;format-&gt;BitsPerPixel == src-&gt;format-&gt;BitsPerPixel);</span><br><span class="line">  <span class="type">int</span> w, h;</span><br><span class="line">  <span class="type">int</span> sx, sy, dx, dy;</span><br><span class="line">  <span class="keyword">if</span> (srcrect) &#123;</span><br><span class="line">    w = srcrect-&gt;w; h = srcrect-&gt;h;</span><br><span class="line">    sx = srcrect-&gt;x; sy = srcrect-&gt;y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sx = sy = <span class="number">0</span>;</span><br><span class="line">    w = src-&gt;w; h = src-&gt;h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dstrect) &#123;</span><br><span class="line">    dx = dstrect-&gt;x; dy = dstrect-&gt;y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dx = dy = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> *sp = (<span class="type">uint32_t</span> *)src-&gt;pixels;</span><br><span class="line">  <span class="type">uint32_t</span> *dp = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      dp[(dy + i) * dst-&gt;w + dx + j] = sp[(sy + i) * src-&gt;w + sx + j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>SDL_FillRect()往画布的指定矩形区域中填充指定的颜色。同样要处理dstrect为空和非空的情况，方法和SDL_BlitSurface相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SDL_FillRect</span><span class="params">(SDL_Surface *dst, SDL_Rect *dstrect, <span class="type">uint32_t</span> color)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y, w, h;</span><br><span class="line">  <span class="keyword">if</span> (dstrect) &#123;</span><br><span class="line">    x = dstrect-&gt;x; y = dstrect-&gt;y;</span><br><span class="line">    w = dstrect-&gt;w; h = dstrect-&gt;h;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w = dst-&gt;w;  h = dst-&gt;h;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> *pixels = (<span class="type">uint32_t</span> *)dst-&gt;pixels;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      pixels[(y + i) * dst-&gt;w + x + j] = color;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Menu可以看到菜单界面。</p><p><img src="94de8b722d07ac6f014b4ee35f35638.png" alt="94de8b722d07ac6f014b4ee35f35638"></p><p>下一个应用程序Nterm，一个简易终端。需要实现两个SDL函数SDL_GetTicks()和SDL_PollEvent()。</p><p>SDL_GetTicks()直接返回NDL_GetTicks()就行了，两者功能完全相同。</p><p>SDL_PollEvent()和SDL_WaitEvent()相似，只是SDL_WaitEvent()会不停读取键盘信息直到有事件发生，而SDL_PollEvent()只读取一次，若没有事件发生，直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SDL_PollEvent</span><span class="params">(SDL_Event *ev)</span> &#123;</span><br><span class="line">  CallbackHelper(<span class="number">2</span>);</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">if</span> (NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  ev-&gt;type = buf[<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span> ? SDL_KEYUP : SDL_KEYDOWN;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">83</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(keyname[i], buf + <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      ev-&gt;key.keysym.sym = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面运行一个游戏Flappy Bird。需要实现IMF-Koad()，实现方式文件写得很清楚了：</p><ol><li>用libc中的文件操作打开文件, 并获取文件大小size</li><li>申请一段大小为size的内存区间buf</li><li>将整个文件读取到buf中</li><li>将buf和size作为参数, 调用<code>STBIMG_LoadFromMemory()</code>, 它会返回一个<code>SDL_Surface</code>结构的指针</li><li>关闭文件, 释放申请的内存</li><li>返回<code>SDL_Surface</code>结构指针</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SDL_Surface* <span class="title function_">IMG_Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">  <span class="type">void</span> *buf = <span class="built_in">malloc</span>(size);</span><br><span class="line">  lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  read(fd, buf, size);</span><br><span class="line">  SDL_Surface *surface = STBIMG_LoadFromMemory((<span class="type">char</span> *)buf, size);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好之后运行游戏。帧数有点低，但是能玩。</p><p><img src="7104bd4e45b94cb7afad614f757f2b9.png" alt="7104bd4e45b94cb7afad614f757f2b9"></p><p>终于到PAL(仙剑奇侠传)啦！PAL不需要实现其它的函数，但是要增强一些SDL函数的功能，让它支持8位像素格式。其实只要增加一个条件判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(src-&gt;format-&gt;BitsPerPixel == <span class="number">32</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(src-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现内容基本一样。SDL_UpdateRect()在最后调用NDL_DrawRect()，传入的参数pixels必须是32位格式的，不然会显示错误颜色。因此需要现将8位颜色转为32位的，再填入pixels。s-&gt;format-&gt;palette-&gt;colors是一个SDL_Color类型的数组，以8位颜色为下标时可以获得其对应的SDL_Color，结构体包含rgba四个8位数字，再写一个函数将4个8位数字转化为一个32位数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">color_translater</span><span class="params">(SDL_Color *c)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (c-&gt;a &lt;&lt; <span class="number">24</span>) | (c-&gt;r &lt;&lt; <span class="number">16</span>) | (c-&gt;g &lt;&lt; <span class="number">8</span>) | c-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填充pixel:</span></span><br><span class="line">pixel[i * w + j] = color_translater(&amp;s-&gt;format-&gt;palette-&gt;colors[src[(y + i) * s-&gt;w + x + j]]);</span><br></pre></td></tr></table></figure><p>尝试运行PAL，发现assert(0)了。原来是SDL_GetKeyState()没有实现。这个函数需要返回一个指针，指向一个数组，这个数组实时反映按键的状态，若某个按键被按下，对应位置为1，否则为0。所以我们要维护一个数组，大小为按键数目。在SDL_PollEvent()或SDL_WaitEvent()发现按键按下时，将数组对应位置改为1，按键弹起时，重置为0。SDL_GetKsyState()直接返回这个数组地址。另外还要往参数numkeys指向位置写入按键的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *<span class="title function_">SDL_GetKeyState</span><span class="params">(<span class="type">int</span> *numkeys)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (numkeys) *numkeys = <span class="number">83</span>;</span><br><span class="line">  <span class="keyword">return</span> key_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，可以运行PAL了。</p><p><img src="c67a925b441a8c1312d8df31c39ad80.png" alt="c67a925b441a8c1312d8df31c39ad80" style="zoom:75%;" /></p><p><img src="df624eba8247425258fef010a24c817.png" alt="df624eba8247425258fef010a24c817"></p><p>接下来实现AM的API。首先是ioe_read()和ioe_write()。由于用户程序是跑在Nanos上的，它并不能直接调用AM的ioe_read和ioe_write，这是直接跑在Nemu上的Nanos的权限。所以用户程序需要通过系统调用实现ioe。用什么系统调用呢？当然是read和write，因为它们的本质都是读写文件，只要把ioe也当成文件就可以了。但ioe的设备寄存器有很多个，难道要为每个设备寄存器设置一个文件吗？其实有个方法，我们用文件指针来表示读取哪个寄存器。所有的ioe都抽象为同一个文件，用文件的open_offset区分具体指向哪一个ioe。用户程序打开这个文件后，将文件指针移动到<code>reg</code>位置上，再读写。操作系统处理读写时，就以<code>open_offset</code>判断读取哪个寄存器就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件记录表中添加表项</span></span><br><span class="line">&#123;<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">128</span>, <span class="number">0</span>, am_ioe_read, am_ioe_write&#125;</span><br><span class="line"><span class="comment">// 实现两个读写操作函数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">am_ioe_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  ioe_read(offset, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">am_ioe_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  ioe_write(offset, (<span class="type">void</span> *)buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~/ics2023/navy-apps/libs/libam/src/ioe.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_read</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lseek(fd, reg, SEEK_SET);</span><br><span class="line">  read(fd, buf, <span class="number">0</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ioe_write</span><span class="params">(<span class="type">int</span> reg, <span class="type">void</span> *buf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/am_ioe&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lseek(fd, reg, SEEK_SET);</span><br><span class="line">  write(fd, buf, <span class="number">0</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以在nanos上运行am应用打字游戏了。</p><p>运行FCEUX不需要其它写另外的代码，但是有个坑。fceux的main函数在此处<code>/home/sprooc/ics2023/fceux-am/src/drivers/sdl/sdl.cpp</code>。RTFSC可以发现，如果定义了宏<code>__NO_FILE_SYSTEM__</code>，main函数有一个参数<code>romname</code>，表示要运行的游戏名称，但我们没法给main函数传参（或许有的，只是我实在搞不懂），所以<code>romname</code>是个空指针，后面会读取空指针导致错误。但是，如果我们不定义<code>__NO_FILE_SYSTEM__</code>，就会从argv里获取游戏名称，如果没有传入参数，使用默认的游戏路径，这样即使不传参也可以运行了。所以要取消掉宏定义<code>__NO_FILE_SYSTEM__</code>。加一句<code>undef</code>或修改Makefile都可以。下面是在Nanos打开的fceux界面。</p><p><img src="1818d9d700c49467344ebf58e7b25e3.png" alt="1818d9d700c49467344ebf58e7b25e3"></p><p>下面实现运行Nplayer。由于我最后没有成功运行，所以不保证以下内容的正确性。</p><p>添加两个音频相关的设备文件：声卡的流缓冲区，声卡控制和状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;/dev/sb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, sb_write&#125;,</span><br><span class="line">&#123;<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, sbctl_read, sbctl_write&#125;,</span><br></pre></td></tr></table></figure><p>然后实现它们的读写函数。<code>sb_write()</code>（名字有点不文雅，但它确实叫这名）调用<code>ioe_write()</code>写入流缓冲区，需要Area结构体参数，结构体包含start(写入内容起始地址), end(写入内容末尾地址)。在<code>sb_write()</code>填好这个结构体，调用ioe_write就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sb_write</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  Area wbuf;</span><br><span class="line">  wbuf.start = (<span class="type">void</span> *)buf;</span><br><span class="line">  wbuf.end = (<span class="type">void</span> *)buf + len;</span><br><span class="line">  io_write(AM_AUDIO_PLAY, wbuf);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sbctl_write()</code>往声卡的控制寄存器写入三个值：<code>freq</code>, <code>channels</code>, <code>samples</code>，它们会被依次放在buf后的12个字节。以它们为参数调用<code>io_write(AM_AUDIO_CTRL, ...)</code>就行了。<code>stctl_write()</code>要读取声卡流缓冲区的空闲字节数。AM_AUDIO_CONFIG和AM_AUDIO_STATUS分别存有流缓冲区的总容量和已写入字节数，它们的差值就是空闲字符数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sbctl_read</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  AM_AUDIO_CONFIG_T cfg = io_read(AM_AUDIO_CONFIG);</span><br><span class="line">  AM_AUDIO_STATUS_T stat = io_read(AM_AUDIO_STATUS);</span><br><span class="line">  *((<span class="type">uint32_t</span> *)buf) = cfg.bufsize - stat.count;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再NDL对这些音频文件的读写操作做个简单的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenAudio</span><span class="params">(<span class="type">int</span> freq, <span class="type">int</span> channels, <span class="type">int</span> samples)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sbctl = open(<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">uint32_t</span> buf[] = &#123;freq, channels, samples&#125;;</span><br><span class="line">  write(sbctl, (<span class="type">void</span> *)buf, <span class="number">12</span>);</span><br><span class="line">  close(sbctl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_PlayAudio</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sb = open(<span class="string">&quot;/dev/sb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> write(sb, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">NDL_QueryAudio</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> sbctl = open(<span class="string">&quot;/dev/sbctl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  read(sbctl, (<span class="type">void</span> *)&amp;size, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在SDL做进一步封装。首先看SDL_OpenAudio()，这个函数需要从desired获取freq, channels, samples三个信息，使用它们初始化声卡设备。desired还有一个参数callback，这是一个用户程序注册回调函数，这个函数用于填充音频数据，需要由SDL定期调用它来获取音频数据，并将获得的数据写到声卡流缓冲区。这貌似要用多线程，因为在定期调用和其它代码的执行应该是并行的。使用多线程应该是正解，但在Navy里面实现太麻烦了，我们另辟蹊径。查看nplayer的代码，SDL_PauseAudio(0)之后音频开始播放，这之后SDL应该定期调用回调函数。同时nplayer进入一个循环，重复调用SDL_PollEvent(&amp;ev)查询事件，直到音频播放完成。我们不如让SDL_PollEvent()调用回调函数，这样同样可以实现nplayer循环和SDL回调函数同时运行的效果。我们实现一个函数CallbackHelper()，维护一个计时器和音频播放状态。<code>st</code>为1时，播放，<code>st</code>为0时，停止播放。传入的参数flag用于修改st。flag为1时，st设为1；flag为0时，st设为0；flag为2时，不改变状态。因此开始播放时以1为参数调用它；SDL_PollEvent以2为参数调用，使其保持运行状态以定期调用回调函数；关闭音频时以0为参数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CallbackHelper</span><span class="params">(<span class="type">int</span> flag)</span> &#123; <span class="comment">//1: start; 0: stop; 2: contunue</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> timer = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> st = <span class="number">0</span>; <span class="comment">// 1 running ; 0 no working</span></span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">1</span>) st = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(flag == <span class="number">0</span>) st = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(st == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(SDL_GetTicks() - timer &lt; gap) <span class="keyword">return</span>;</span><br><span class="line">  timer = SDL_GetTicks();</span><br><span class="line">  callback(<span class="literal">NULL</span>, stream, samples);</span><br><span class="line">  NDL_PlayAudio(stream, samples);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">SDL_OpenAudio</span><span class="params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span> &#123;</span><br><span class="line">  freq = desired-&gt;freq;</span><br><span class="line">  gap = <span class="number">1000</span> / freq;</span><br><span class="line">  channels = desired-&gt;channels;</span><br><span class="line">  samples = desired-&gt;samples;</span><br><span class="line">  callback = desired-&gt;callback;</span><br><span class="line">  NDL_OpenAudio(freq, channels, samples);</span><br><span class="line">  stream = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(samples);</span><br><span class="line">  CallbackHelper(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_CloseAudio</span><span class="params">()</span> &#123; CallbackHelper(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SDL_PauseAudio</span><span class="params">(<span class="type">int</span> pause_on)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(pause_on != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">uint32_t</span> delay = <span class="number">1000</span> / freq;</span><br><span class="line">  <span class="type">uint8_t</span> *stream = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(samples);</span><br><span class="line">  CallbackHelper(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现好之后运行nplayer，却在音频解析的时候就错误了，跟自己实现的函数应该没有关系。我弄不清楚于是就放弃了。</p><p><img src="95de1c1a4545547ca9a098de6b929a2.png" alt="95de1c1a4545547ca9a098de6b929a2"></p><h3 id="基础设施-3"><a href="#基础设施-3" class="headerlink" title="基础设施(3)"></a>基础设施(3)</h3><p>这部分不太想写。。。</p><h3 id="展示你的批处理系统"><a href="#展示你的批处理系统" class="headerlink" title="展示你的批处理系统"></a>展示你的批处理系统</h3><p>实现系统调用sys_execve:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sys_execve</span><span class="params">(Context *c)</span> &#123; naive_uload(<span class="literal">NULL</span>, (<span class="type">const</span> <span class="type">char</span> *)c-&gt;GPR2); &#125;</span><br></pre></td></tr></table></figure><p>再修改sys_exit，就可以使用开机菜单来选择要运行的程序了。</p><p>接下来尝试换成nterm。主要是实现nterm的<code>sh_handle_cmd()</code>函数。这里有点坑，命令字符串的末尾会有一个换行，如果直接用这个字符串作为文件名会因为多了个换行符无法匹配，所以要把换行符去掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sh_handle_cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  <span class="type">char</span> *str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">  <span class="built_in">strncpy</span>(str, cmd, len - <span class="number">1</span>);</span><br><span class="line">  str[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// execve(str, NULL, NULL);</span></span><br><span class="line">  execvp(str, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="必答题-理解计算机系统"><a href="#必答题-理解计算机系统" class="headerlink" title="必答题 - 理解计算机系统"></a>必答题 - 理解计算机系统</h5><blockquote><p>仙剑奇侠传究竟如何运行 运行仙剑奇侠传时会播放启动动画, 动画里仙鹤在群山中飞过. 这一动画是通过<code>navy-apps/apps/pal/repo/src/main.c</code>中的<code>PAL_SplashScreen()</code>函数播放的. 阅读这一函数, 可以得知仙鹤的像素信息存放在数据文件<code>mgo.mkf</code>中. 请回答以下问题: 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来帮助仙剑奇侠传的代码从<code>mgo.mkf</code>文件中读出仙鹤的像素信息, 并且更新到屏幕上? 换一种PA的经典问法: 这个过程究竟经历了些什么? (Hint: 合理使用各种trace工具, 可以帮助你更容易地理解仙剑奇侠传的行为)</p></blockquote><p>每一次更新画面，先从mgo.mkf中读取此帧的像素信息，用SDL_BlitSurface()等函数填充Surface的缓冲区，最后调用SDL_UpdateRect()更新画面。SDL_UpdateRect()读取相应信息之后调用NDL_DrawRect()，NDL_DrawRect()通过系统调用打开显存设备文件，往显存里面写入画面数据。用户程序最终会调用libos里的__syscall__()函数发起系统调用，然后转移到nanos执行。nanos通过fb_write()函数处理这个写入显存的操作。它会调用AM提供的接口io_write()往设备寄存器AM_GPU_FBDRAW写入数据。这段指令在机器代码中被会被翻译成往FB_ADDR这个地址里写入数据。当Nemu执行到这个写指令时，会发现这个地址映射到显存，故并不实际地往里面写数据，而是调用SDL库把画面显示到屏幕上。到此完成了更新屏幕画面的全过程。</p><p>PA3到此结束！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ics-pa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, world!</title>
      <link href="/2023/11/15/Hello-world/"/>
      <url>/2023/11/15/Hello-world/</url>
      
        <content type="html"><![CDATA[<p>诞生于2023/11/14。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
